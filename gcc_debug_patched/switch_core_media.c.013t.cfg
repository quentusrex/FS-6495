
;; Function switch_core_media_deinit (switch_core_media_deinit)

Scope blocks:

{ Scope block #0 

}
switch_core_media_deinit ()
{
<bb 2>:
  return;

}



;; Function switch_core_media_init (switch_core_media_init)

Scope blocks:

{ Scope block #0 

}
switch_core_media_init ()
{
<bb 2>:
  switch_core_gen_certs ("dtls-srtp.pem");
  return;

}



;; Function switch_core_media_recover_session (switch_core_media_recover_session)

Scope blocks:

{ Scope block #0 
  const char * ip; (unused)
  const char * port; (unused)
  const char * a_ip; (unused)
  const char * r_ip; (unused)
  const char * r_port; (unused)
  const char * tmp; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_recover_session"; (unused)
  static const char __func__[34] = "switch_core_media_recover_session"; (unused)

  { Scope block #0 
    const char * vtmp; (unused)

  }

  { Scope block #0 
    char * tmp_codec_string; (unused)

  }

  { Scope block #0 
    int idx; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       57 (fallthru)
<bb 5>:
goto <bb 57>;


Removing basic block 8
;; basic block 8, loop depth 0, count 0
;; prev block 7, next block 9
;; pred:      
;; succ:       57 (fallthru)
<bb 8>:
goto <bb 57>;


Removing basic block 51
;; basic block 51, loop depth 0, count 0
;; prev block 50, next block 52
;; pred:      
;; succ:       57 (fallthru)
<bb 51>:
goto <bb 57>;


switch_core_media_recover_session (struct switch_core_session_t * session)
{
  int idx;
  char * tmp_codec_string;
  const char * vtmp;
  static const char __func__[34] = "switch_core_media_recover_session";
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_recover_session";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  const char * tmp;
  const char * r_port;
  const char * r_ip;
  const char * a_ip;
  const char * port;
  const char * ip;
  switch_payload_t D.40294;
  switch_payload_t D.40293;
  uint8_t D.40290;
  unsigned char[64] * D.40289;
  uint32_t D.40288;
  int D.40287;
  switch_size_t D.40286;
  int D.40285;
  unsigned char[64] * D.40284;
  uint32_t idx.2;
  struct switch_rtp_t * D.40282;
  struct switch_channel_t * D.40281;
  char * D.40280;
  struct switch_secure_settings_t * D.40279;
  unsigned int D.40278;
  struct switch_secure_settings_t[10] * D.40277;
  char * D.40276;
  char * D.40273;
  switch_rtp_crypto_key_type_t D.40272;
  switch_status_t D.40267;
  short unsigned int D.40266;
  int D.40265;
  switch_port_t D.40262;
  short unsigned int D.40261;
  int D.40260;
  uint32_t D.40259;
  int D.40258;
  long unsigned int D.40255;
  long unsigned int D.40254;
  int D.40253;
  const char * D.40250;
  const char * D.40249;
  unsigned char D.40248;
  int D.40247;
  switch_payload_t D.40244;
  unsigned char D.40243;
  int D.40242;
  struct payload_map_t * D.40241;
  uint32_t D.40236;
  short unsigned int D.40235;
  int D.40234;
  _Bool D.40231;
  _Bool D.40230;
  _Bool D.40229;
  char * D.40228;
  int D.40225;
  char * D.40224;
  char * D.40223;
  int D.40220;
  switch_port_t D.40219;
  short unsigned int D.40218;
  int D.40217;
  char * D.40216;
  uint32_t D.40215;
  unsigned char D.40214;
  int D.40213;
  switch_payload_t D.40210;
  unsigned char D.40209;
  int D.40208;
  uint32_t D.40205;
  int D.40204;
  long unsigned int D.40201;
  long unsigned int D.40200;
  int D.40199;
  unsigned char D.40196;
  int D.40195;
  unsigned char D.40192;
  int D.40191;
  int D.40188;
  int D.40187;
  const struct switch_codec_implementation_t *[50] * D.40186;
  int D.40185;
  unsigned int D.40184;
  char *[50] * D.40183;
  struct switch_core_session_t * D.40182;
  const char * iftmp.1;
  char * iftmp.0;
  char * D.40169;
  struct switch_core_media_params_t * D.40168;
  const char * D.40165;
  char * D.40164;
  const char * D.40163;
  struct payload_map_t * D.40162;
  _Bool D.40161;
  _Bool D.40160;
  _Bool D.40159;
  uint32_t D.40157;
  struct switch_channel_t * D.40154;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8557, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 54>;
  else
    goto <bb 5>;

<bb 5>:
  D.40154 = session->channel;
  ip = switch_channel_get_variable_dup (D.40154, "local_media_ip", 1, -1);
  D.40154 = session->channel;
  port = switch_channel_get_variable_dup (D.40154, "local_media_port", 1, -1);
  D.40154 = session->channel;
  D.40157 = switch_channel_test_flag (D.40154, 15);
  if (D.40157 != 0)
    goto <bb 54>;
  else
    goto <bb 6>;

<bb 6>:
  D.40159 = ip == 0B;
  D.40160 = port == 0B;
  D.40161 = D.40159 || D.40160;
  if (D.40161 != 0)
    goto <bb 54>;
  else
    goto <bb 7>;

<bb 7>:
  D.40154 = session->channel;
  a_ip = switch_channel_get_variable_dup (D.40154, "advertised_media_ip", 1, -1);
  D.40154 = session->channel;
  r_ip = switch_channel_get_variable_dup (D.40154, "remote_media_ip", 1, -1);
  D.40154 = session->channel;
  r_port = switch_channel_get_variable_dup (D.40154, "remote_media_port", 1, -1);
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.40162 = a_engine->cur_payload_map;
  D.40162 = a_engine->cur_payload_map;
  D.40154 = session->channel;
  D.40163 = switch_channel_get_variable_dup (D.40154, "rtp_use_codec_name", 1, -1);
  D.40162->rm_encoding = D.40163;
  D.40164 = D.40162->rm_encoding;
  D.40162->iananame = D.40164;
  D.40162 = a_engine->cur_payload_map;
  D.40154 = session->channel;
  D.40165 = switch_channel_get_variable_dup (D.40154, "rtp_use_codec_fmtp", 1, -1);
  D.40162->rm_fmtp = D.40165;
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "switch_r_sdp", 1, -1);
  if (tmp != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.40168 = smh->mparams;
  D.40169 = switch_core_perform_session_strdup (session, tmp, "src/switch_core_media.c", &__func__, 8581);
  D.40168->remote_sdp_str = D.40169;

<bb 9>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_last_audio_codec_string", 1, -1);
  if (tmp != 0B)
    goto <bb 10>;
  else
    goto <bb 17>;

<bb 10>:
  D.40154 = session->channel;
  vtmp = switch_channel_get_variable_dup (D.40154, "rtp_last_video_codec_string", 1, -1);
  D.40154 = session->channel;
  if (vtmp != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  iftmp.0 = ",";
  goto <bb 13>;

<bb 12>:
  iftmp.0 = "";

<bb 13>:
  if (vtmp != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  iftmp.1 = vtmp;
  goto <bb 16>;

<bb 15>:
  iftmp.1 = "";

<bb 16>:
  switch_channel_set_variable_printf (D.40154, "rtp_use_codec_string", "%s%s%s", tmp, iftmp.0, iftmp.1);

<bb 17>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_codec_string", 1, -1);
  if (tmp != 0B)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.40182 = smh->session;
  tmp_codec_string = switch_core_perform_session_strdup (D.40182, tmp, "src/switch_core_media.c", &__func__, 8591);
  D.40183 = &smh->codec_order;
  D.40184 = switch_separate_string (tmp_codec_string, 44, D.40183, 50);
  D.40185 = (int) D.40184;
  smh->codec_order_last = D.40185;
  D.40168 = smh->mparams;
  D.40186 = &smh->codecs;
  D.40183 = &smh->codec_order;
  D.40187 = smh->codec_order_last;
  D.40188 = switch_loadable_module_get_codecs_sorted (D.40186, 50, D.40183, D.40187);
  D.40168->num_codecs = D.40188;

<bb 19>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_2833_send_payload", 1, -1);
  if (tmp != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.40168 = smh->mparams;
  D.40191 = atoi (tmp);
  D.40192 = (unsigned char) D.40191;
  D.40168->te = D.40192;

<bb 21>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_2833_recv_payload", 1, -1);
  if (tmp != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.40168 = smh->mparams;
  D.40195 = atoi (tmp);
  D.40196 = (unsigned char) D.40195;
  D.40168->recv_te = D.40196;

<bb 23>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_codec_rate", 1, -1);
  if (tmp != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

<bb 24>:
  D.40162 = a_engine->cur_payload_map;
  D.40199 = atoi (tmp);
  D.40200 = (long unsigned int) D.40199;
  D.40162->rm_rate = D.40200;
  D.40162 = a_engine->cur_payload_map;
  D.40162 = a_engine->cur_payload_map;
  D.40201 = D.40162->rm_rate;
  D.40162->adv_rm_rate = D.40201;

<bb 25>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_codec_ptime", 1, -1);
  if (tmp != 0B)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  D.40162 = a_engine->cur_payload_map;
  D.40204 = atoi (tmp);
  D.40205 = (uint32_t) D.40204;
  D.40162->codec_ms = D.40205;

<bb 27>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_pt", 1, -1);
  if (tmp != 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

<bb 28>:
  D.40162 = a_engine->cur_payload_map;
  D.40162 = a_engine->cur_payload_map;
  D.40208 = atoi (tmp);
  D.40209 = (unsigned char) D.40208;
  D.40162->agreed_pt = D.40209;
  D.40210 = D.40162->agreed_pt;
  D.40162->pt = D.40210;

<bb 29>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_audio_recv_pt", 1, -1);
  if (tmp != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  D.40162 = a_engine->cur_payload_map;
  D.40213 = atoi (tmp);
  D.40214 = (unsigned char) D.40213;
  D.40162->recv_pt = D.40214;

<bb 31>:
  D.40168 = smh->mparams;
  D.40215 = D.40168->codec_flags;
  switch_core_media_set_codec (session, 1, D.40215);
  D.40168 = smh->mparams;
  D.40168->extrtpip = ip;
  D.40216 = D.40168->extrtpip;
  a_engine->adv_sdp_ip = D.40216;
  D.40217 = atoi (port);
  D.40218 = (short unsigned int) D.40217;
  a_engine->local_sdp_port = D.40218;
  D.40219 = a_engine->local_sdp_port;
  a_engine->adv_sdp_port = D.40219;
  D.40220 = _zstr (ip);
  if (D.40220 == 0)
    goto <bb 32>;
  else
    goto <bb 33>;

<bb 32>:
  D.40223 = switch_core_perform_session_strdup (session, ip, "src/switch_core_media.c", &__func__, 8627);
  a_engine->local_sdp_ip = D.40223;
  D.40168 = smh->mparams;
  D.40224 = a_engine->local_sdp_ip;
  D.40168->rtpip = D.40224;

<bb 33>:
  D.40225 = _zstr (a_ip);
  if (D.40225 == 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  D.40228 = switch_core_perform_session_strdup (session, a_ip, "src/switch_core_media.c", &__func__, 8632);
  a_engine->adv_sdp_ip = D.40228;

<bb 35>:
  D.40229 = r_ip != 0B;
  D.40230 = r_port != 0B;
  D.40231 = D.40229 && D.40230;
  if (D.40231 != 0)
    goto <bb 36>;
  else
    goto <bb 37>;

<bb 36>:
  D.40162 = a_engine->cur_payload_map;
  D.40162->remote_sdp_ip = r_ip;
  D.40162 = a_engine->cur_payload_map;
  D.40234 = atoi (r_port);
  D.40235 = (short unsigned int) D.40234;
  D.40162->remote_sdp_port = D.40235;

<bb 37>:
  D.40154 = session->channel;
  D.40236 = switch_channel_test_flag (D.40154, 23);
  if (D.40236 != 0)
    goto <bb 38>;
  else
    goto <bb 48>;

<bb 38>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_video_pt", 1, -1);
  if (tmp != 0B)
    goto <bb 39>;
  else
    goto <bb 40>;

<bb 39>:
  D.40241 = v_engine->cur_payload_map;
  D.40241 = v_engine->cur_payload_map;
  D.40242 = atoi (tmp);
  D.40243 = (unsigned char) D.40242;
  D.40241->agreed_pt = D.40243;
  D.40244 = D.40241->agreed_pt;
  D.40241->pt = D.40244;

<bb 40>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_video_recv_pt", 1, -1);
  if (tmp != 0B)
    goto <bb 41>;
  else
    goto <bb 42>;

<bb 41>:
  D.40241 = v_engine->cur_payload_map;
  D.40247 = atoi (tmp);
  D.40248 = (unsigned char) D.40247;
  D.40241->recv_pt = D.40248;

<bb 42>:
  D.40241 = v_engine->cur_payload_map;
  D.40154 = session->channel;
  D.40249 = switch_channel_get_variable_dup (D.40154, "rtp_use_video_codec_name", 1, -1);
  D.40241->rm_encoding = D.40249;
  D.40241 = v_engine->cur_payload_map;
  D.40154 = session->channel;
  D.40250 = switch_channel_get_variable_dup (D.40154, "rtp_use_video_codec_fmtp", 1, -1);
  D.40241->rm_fmtp = D.40250;
  D.40154 = session->channel;
  ip = switch_channel_get_variable_dup (D.40154, "local_video_ip", 1, -1);
  D.40154 = session->channel;
  port = switch_channel_get_variable_dup (D.40154, "local_video_port", 1, -1);
  D.40154 = session->channel;
  r_ip = switch_channel_get_variable_dup (D.40154, "remote_video_ip", 1, -1);
  D.40154 = session->channel;
  r_port = switch_channel_get_variable_dup (D.40154, "remote_video_port", 1, -1);
  D.40154 = session->channel;
  switch_channel_set_flag_value (D.40154, 98, 1);
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_video_codec_rate", 1, -1);
  if (tmp != 0B)
    goto <bb 43>;
  else
    goto <bb 44>;

<bb 43>:
  D.40241 = v_engine->cur_payload_map;
  D.40253 = atoi (tmp);
  D.40254 = (long unsigned int) D.40253;
  D.40241->rm_rate = D.40254;
  D.40241 = v_engine->cur_payload_map;
  D.40241 = v_engine->cur_payload_map;
  D.40255 = D.40241->rm_rate;
  D.40241->adv_rm_rate = D.40255;

<bb 44>:
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_use_video_codec_ptime", 1, -1);
  if (tmp != 0B)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  D.40241 = v_engine->cur_payload_map;
  D.40258 = atoi (tmp);
  D.40259 = (uint32_t) D.40258;
  D.40241->codec_ms = D.40259;

<bb 46>:
  D.40260 = atoi (port);
  D.40261 = (short unsigned int) D.40260;
  v_engine->local_sdp_port = D.40261;
  D.40262 = v_engine->local_sdp_port;
  v_engine->adv_sdp_port = D.40262;
  D.40229 = r_ip != 0B;
  D.40230 = r_port != 0B;
  D.40231 = D.40229 && D.40230;
  if (D.40231 != 0)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  D.40241 = v_engine->cur_payload_map;
  D.40241->remote_sdp_ip = r_ip;
  D.40241 = v_engine->cur_payload_map;
  D.40265 = atoi (r_port);
  D.40266 = (short unsigned int) D.40265;
  D.40241->remote_sdp_port = D.40266;

<bb 48>:
  switch_core_media_gen_local_sdp (session, 0, 0B, 0, 0B, 1);
  switch_core_media_set_video_codec (session, 1);
  D.40267 = switch_core_media_activate_rtp (session);
  if (D.40267 != 0)
    goto <bb 54>;
  else
    goto <bb 49>;

<bb 49>:
  switch_core_session_get_recovery_crypto_key (session, 0);
  switch_core_session_get_recovery_crypto_key (session, 1);
  D.40154 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40154, "rtp_last_audio_local_crypto_key", 1, -1);
  if (tmp != 0B)
    goto <bb 50>;
  else
    goto <bb 52>;

<bb 50>:
  D.40272 = a_engine->crypto_type;
  D.40273 = a_engine->ssec[D.40272].remote_crypto_key;
  if (D.40273 != 0B)
    goto <bb 51>;
  else
    goto <bb 52>;

<bb 51>:
  idx = atoi (tmp);
  D.40272 = a_engine->crypto_type;
  D.40276 = switch_core_perform_session_strdup (session, tmp, "src/switch_core_media.c", &__func__, 8690);
  a_engine->ssec[D.40272].local_crypto_key = D.40276;
  D.40277 = &a_engine->ssec;
  D.40272 = a_engine->crypto_type;
  D.40278 = D.40272 * 144;
  D.40279 = D.40277 + D.40278;
  D.40272 = a_engine->crypto_type;
  D.40280 = a_engine->ssec[D.40272].local_crypto_key;
  switch_core_media_add_crypto (D.40279, D.40280, 0);
  D.40277 = &a_engine->ssec;
  D.40272 = a_engine->crypto_type;
  D.40278 = D.40272 * 144;
  D.40279 = D.40277 + D.40278;
  D.40272 = a_engine->crypto_type;
  D.40273 = a_engine->ssec[D.40272].remote_crypto_key;
  switch_core_media_add_crypto (D.40279, D.40273, 1);
  D.40182 = smh->session;
  D.40281 = D.40182->channel;
  switch_channel_set_flag_value (D.40281, 92, 1);
  D.40282 = a_engine->rtp_session;
  idx.2 = (uint32_t) idx;
  D.40272 = a_engine->crypto_type;
  D.40272 = a_engine->crypto_type;
  D.40284 = &a_engine->ssec[D.40272].local_raw_key;
  D.40272 = a_engine->crypto_type;
  D.40285 = SUITES[D.40272].keylen;
  D.40286 = (switch_size_t) D.40285;
  switch_rtp_add_crypto_key (D.40282, 0, idx.2, D.40272, D.40284, D.40286);
  D.40282 = a_engine->rtp_session;
  D.40272 = a_engine->crypto_type;
  D.40287 = a_engine->ssec[D.40272].crypto_tag;
  D.40288 = (uint32_t) D.40287;
  D.40272 = a_engine->crypto_type;
  D.40272 = a_engine->crypto_type;
  D.40289 = &a_engine->ssec[D.40272].remote_raw_key;
  D.40272 = a_engine->crypto_type;
  D.40285 = SUITES[D.40272].keylen;
  D.40286 = (switch_size_t) D.40285;
  switch_rtp_add_crypto_key (D.40282, 1, D.40288, D.40272, D.40289, D.40286);

<bb 52>:
  D.40290 = switch_core_media_ready (session, 0);
  if (D.40290 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

<bb 53>:
  D.40282 = a_engine->rtp_session;
  D.40168 = smh->mparams;
  D.40293 = D.40168->te;
  switch_rtp_set_telephony_event (D.40282, D.40293);
  D.40282 = a_engine->rtp_session;
  D.40168 = smh->mparams;
  D.40294 = D.40168->recv_te;
  switch_rtp_set_telephony_recv_event (D.40282, D.40294);

<bb 54>:
  return;

}



;; Function _zstr (_zstr)

Scope blocks:

{ Scope block #0 

}
Merging blocks 6 and 7
_zstr (const char * s)
{
  const char D.40302;
  int iftmp.3;
  int D.40296;

<bb 2>:
  if (s == 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

<bb 3>:
  D.40302 = *s;
  if (D.40302 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  iftmp.3 = 1;
  goto <bb 6>;

<bb 5>:
  iftmp.3 = 0;

<bb 6>:
  D.40296 = iftmp.3;
  return D.40296;

}



;; Function switch_core_session_get_recovery_crypto_key (switch_core_session_get_recovery_crypto_key)

Scope blocks:

{ Scope block #0 
  const char * tmp; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  char * keyvar; (unused)
  char * tagvar; (unused)
  char * ctypevar; (unused)
  static const char __func__[44] = "switch_core_session_get_recovery_crypto_key"; (unused)

  { Scope block #0 
    int tv; (unused)

  }

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       14 (fallthru)
<bb 3>:
goto <bb 14>;


switch_core_session_get_recovery_crypto_key (struct switch_core_session_t * session, switch_media_type_t type)
{
  int tv;
  static const char __func__[44] = "switch_core_session_get_recovery_crypto_key";
  char * ctypevar;
  char * tagvar;
  char * keyvar;
  struct switch_rtp_engine_t * engine;
  const char * tmp;
  char * D.40319;
  switch_rtp_crypto_key_type_t D.40318;
  switch_rtp_crypto_key_type_t D.40317;
  struct switch_channel_t * D.40312;
  unsigned int D.40308;
  struct switch_rtp_engine_t[2] * D.40307;
  struct switch_media_handle_t * D.40304;

<bb 2>:
  D.40304 = session->media_handle;
  if (D.40304 == 0B)
    goto <bb 13>;
  else
    goto <bb 3>;

<bb 3>:
  D.40304 = session->media_handle;
  D.40307 = &D.40304->engines;
  D.40308 = type * 11416;
  engine = D.40307 + D.40308;
  if (type == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  keyvar = "srtp_remote_audio_crypto_key";
  tagvar = "srtp_remote_audio_crypto_tag";
  ctypevar = "srtp_remote_audio_crypto_type";
  goto <bb 6>;

<bb 5>:
  keyvar = "srtp_remote_video_crypto_key";
  tagvar = "srtp_remote_video_crypto_tag";
  ctypevar = "srtp_remote_video_crypto_type";

<bb 6>:
  D.40312 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40312, keyvar, 1, -1);
  if (tmp != 0B)
    goto <bb 7>;
  else
    goto <bb 13>;

<bb 7>:
  D.40312 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40312, ctypevar, 1, -1);
  if (tmp != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.40317 = switch_core_media_crypto_str2type (tmp);
  engine->crypto_type = D.40317;

<bb 9>:
  D.40318 = engine->crypto_type;
  D.40319 = switch_core_perform_session_strdup (session, tmp, "src/switch_core_media.c", &__func__, 1015);
  engine->ssec[D.40318].remote_crypto_key = D.40319;
  D.40312 = session->channel;
  tmp = switch_channel_get_variable_dup (D.40312, tagvar, 1, -1);
  if (tmp != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  tv = atoi (tmp);
  D.40318 = engine->crypto_type;
  engine->ssec[D.40318].crypto_tag = tv;
  goto <bb 12>;

<bb 11>:
  D.40318 = engine->crypto_type;
  engine->ssec[D.40318].crypto_tag = 1;

<bb 12>:
  D.40312 = session->channel;
  switch_channel_set_flag_value (D.40312, 92, 1);

<bb 13>:
  return;

}



;; Function atoi (atoi)

Scope blocks:

{ Scope block #0 

}
Merging blocks 2 and 3
atoi (const char * __nptr)
{
  int D.40324;

<bb 2>:
  D.40324 = strtol (__nptr, 0B, 10);
  return D.40324;

}



;; Function switch_core_media_proxy_codec (switch_core_media_proxy_codec)

Scope blocks:

{ Scope block #0 
  struct sdp_media_t * m; (unused)
  struct sdp_parser_t * parser; (unused)
  struct sdp_session_t * sdp; (unused)
  struct sdp_attribute_t * attr; (unused)
  int ptime; (unused)
  int dptime; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_proxy_codec"; (unused)
  static const char __func__[30] = "switch_core_media_proxy_codec"; (unused)

  { Scope block #0 
    struct sdp_rtpmap_t * map; (unused)

  }

}
Removing basic block 29
;; basic block 29, loop depth 0, count 0
;; prev block 28, next block 30
;; pred:      
;; succ:       30 (fallthru)
<bb 29>:
map = map->rm_next;


Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       35 (fallthru)
<bb 5>:
goto <bb 35>;


Removing basic block 7
;; basic block 7, loop depth 0, count 0
;; prev block 6, next block 8
;; pred:      
;; succ:       35 (fallthru)
<bb 7>:
goto <bb 35>;


Merging blocks 27 and 30
Removing basic block 31
;; basic block 31, loop depth 0, count 0
;; prev block 28, next block 32
;; pred:      
;; succ:       34 (fallthru)
<bb 31>:
goto <bb 34>;


switch_core_media_proxy_codec (struct switch_core_session_t * session, const char * r_sdp)
{
  struct sdp_rtpmap_t * map;
  static const char __func__[30] = "switch_core_media_proxy_codec";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_proxy_codec";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  int dptime;
  int ptime;
  struct sdp_attribute_t * attr;
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  struct sdp_media_t * m;
  uint32_t D.40364;
  struct switch_core_media_params_t * D.40363;
  uint32_t ptime.4;
  long unsigned int D.40361;
  char * D.40360;
  const char * D.40359;
  struct payload_map_t * D.40358;
  int D.40353;
  int D.40347;
  sdp_proto_e D.40344;
  const char * D.40343;
  int D.40340;
  int D.40337;
  const char * D.40336;
  int D.40331;
  size_t D.40330;

<bb 2>:
  parser = 0B;
  ptime = 0;
  dptime = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8482, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 30>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  D.40330 = strlen (r_sdp);
  D.40331 = (int) D.40330;
  parser = sdp_parse (0B, r_sdp, D.40331, 0);
  if (parser == 0B)
    goto <bb 30>;
  else
    goto <bb 6>;

<bb 6>:
  sdp = sdp_session (parser);
  if (sdp == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  sdp_parser_free (parser);
  goto <bb 30>;

<bb 8>:
  attr = sdp->sdp_attributes;
  goto <bb 14>;

<bb 9>:
  D.40336 = attr->a_name;
  D.40337 = _zstr (D.40336);
  if (D.40337 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  // predicted unlikely by continue predictor.
  goto <bb 13>;

<bb 11>:
  D.40336 = attr->a_name;
  D.40340 = strcasecmp (D.40336, "ptime");
  if (D.40340 == 0)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  D.40343 = attr->a_value;
  dptime = atoi (D.40343);

<bb 13>:
  attr = attr->a_next;

<bb 14>:
  if (attr != 0B)
    goto <bb 9>;
  else
    goto <bb 15>;

<bb 15>:
  m = sdp->sdp_media;
  goto <bb 28>;

<bb 16>:
  ptime = dptime;
  D.40344 = m->m_proto;
  if (D.40344 == 256)
    goto <bb 17>;
  else
    goto <bb 27>;

<bb 17>:
  attr = m->m_attributes;
  goto <bb 24>;

<bb 18>:
  D.40336 = attr->a_name;
  D.40347 = strcasecmp (D.40336, "ptime");
  if (D.40347 == 0)
    goto <bb 19>;
  else
    goto <bb 23>;

<bb 19>:
  D.40343 = attr->a_value;
  if (D.40343 != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.40343 = attr->a_value;
  ptime = atoi (D.40343);
  goto <bb 23>;

<bb 21>:
  D.40336 = attr->a_name;
  D.40353 = strcasecmp (D.40336, "maxptime");
  if (D.40353 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.40343 = attr->a_value;

<bb 23>:
  attr = attr->a_next;

<bb 24>:
  if (attr != 0B)
    goto <bb 18>;
  else
    goto <bb 25>;

<bb 25>:
  map = m->m_rtpmaps;
  if (map != 0B)
    goto <bb 26>;
  else
    goto <bb 29>;

<bb 26>:
  D.40358 = a_engine->cur_payload_map;
  D.40359 = map->rm_encoding;
  D.40360 = switch_core_perform_session_strdup (session, D.40359, "src/switch_core_media.c", &__func__, 8527);
  D.40358->iananame = D.40360;
  D.40358 = a_engine->cur_payload_map;
  D.40361 = map->rm_rate;
  D.40358->rm_rate = D.40361;
  D.40358 = a_engine->cur_payload_map;
  D.40361 = map->rm_rate;
  D.40358->adv_rm_rate = D.40361;
  D.40358 = a_engine->cur_payload_map;
  ptime.4 = (uint32_t) ptime;
  D.40358->codec_ms = ptime.4;
  D.40363 = smh->mparams;
  D.40364 = D.40363->codec_flags;
  switch_core_media_set_codec (session, 0, D.40364);
  goto <bb 29>;

<bb 27>:
  m = m->m_next;

<bb 28>:
  if (m != 0B)
    goto <bb 16>;
  else
    goto <bb 29>;

<bb 29>:
  sdp_parser_free (parser);

<bb 30>:
  return;

}



;; Function switch_core_media_check_outgoing_proxy (switch_core_media_check_outgoing_proxy)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  const char * r_sdp; (unused)
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_check_outgoing_proxy"; (unused)
  static const char __func__[39] = "switch_core_media_check_outgoing_proxy"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       10 (fallthru)
<bb 5>:
goto <bb 10>;


Removing basic block 7
;; basic block 7, loop depth 0, count 0
;; prev block 6, next block 8
;; pred:      
;; succ:       10 (fallthru)
<bb 7>:
goto <bb 10>;


switch_core_media_check_outgoing_proxy (struct switch_core_session_t * session, struct switch_core_session_t * o_session)
{
  static const char __func__[39] = "switch_core_media_check_outgoing_proxy";
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_check_outgoing_proxy";
  const char * r_sdp;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  struct payload_map_t * D.40380;
  const char * D.40377;
  char * D.40376;
  struct payload_map_t * D.40375;
  struct switch_channel_t * D.40374;
  uint32_t D.40369;
  struct switch_channel_t * D.40368;

<bb 2>:
  r_sdp = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8430, &__PRETTY_FUNCTION__);

<bb 4>:
  D.40368 = o_session->channel;
  D.40369 = switch_channel_test_flag (D.40368, 29);
  if (D.40369 == 0)
    goto <bb 8>;
  else
    goto <bb 5>;

<bb 5>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 8>;
  else
    goto <bb 6>;

<bb 6>:
  D.40368 = o_session->channel;
  r_sdp = switch_channel_get_variable_dup (D.40368, "switch_r_sdp", 1, -1);
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.40374 = session->channel;
  switch_channel_set_flag_value (D.40374, 29, 1);
  D.40375 = a_engine->cur_payload_map;
  D.40376 = switch_core_perform_session_strdup (session, "PROXY", "src/switch_core_media.c", &__func__, 8447);
  D.40375->iananame = D.40376;
  D.40375 = a_engine->cur_payload_map;
  D.40375->rm_rate = 8000;
  D.40375 = a_engine->cur_payload_map;
  D.40375->adv_rm_rate = 8000;
  D.40375 = a_engine->cur_payload_map;
  D.40375->codec_ms = 20;
  D.40377 = switch_stristr ("m=video", r_sdp);
  if (D.40377 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  switch_core_media_choose_port (session, 1, 1);
  D.40380 = v_engine->cur_payload_map;
  D.40380->rm_encoding = "PROXY-VID";
  D.40380 = v_engine->cur_payload_map;
  D.40380->rm_rate = 90000;
  D.40380 = v_engine->cur_payload_map;
  D.40380->adv_rm_rate = 90000;
  D.40380 = v_engine->cur_payload_map;
  D.40380->codec_ms = 0;
  D.40374 = session->channel;
  switch_channel_set_flag_value (D.40374, 23, 1);
  D.40374 = session->channel;
  switch_channel_set_flag_value (D.40374, 98, 1);

<bb 8>:
  return;

}



;; Function switch_core_media_codec_chosen (switch_core_media_codec_chosen)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_codec_chosen"; (unused)

}
switch_core_media_codec_chosen (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_codec_chosen";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  char * D.40390;
  struct payload_map_t * D.40389;
  unsigned int D.40388;
  struct switch_rtp_engine_t[2] * D.40387;
  switch_status_t D.40386;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8407, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40386 = 1;
  goto <bb 9>;

<bb 6>:
  D.40387 = &smh->engines;
  D.40388 = type * 11416;
  engine = D.40387 + D.40388;
  D.40389 = engine->cur_payload_map;
  D.40390 = D.40389->iananame;
  if (D.40390 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40386 = 0;
  goto <bb 9>;

<bb 8>:
  D.40386 = 1;

<bb 9>:
  return D.40386;

}



;; Function switch_core_media_set_sdp_codec_string (switch_core_media_set_sdp_codec_string)

Scope blocks:

{ Scope block #0 
  struct sdp_parser_t * parser; (unused)
  struct sdp_session_t * sdp; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_set_sdp_codec_string"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       10 (fallthru)
<bb 5>:
goto <bb 10>;


switch_core_media_set_sdp_codec_string (struct switch_core_session_t * session, const char * r_sdp, switch_sdp_type_t sdp_type)
{
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_set_sdp_codec_string";
  struct switch_media_handle_t * smh;
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  const char * D.40404;
  int D.40399;
  size_t D.40398;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8105, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 9>;
  else
    goto <bb 5>;

<bb 5>:
  D.40398 = strlen (r_sdp);
  D.40399 = (int) D.40398;
  parser = sdp_parse (0B, r_sdp, D.40399, 0);
  if (parser != 0B)
    goto <bb 6>;
  else
    goto <bb 9>;

<bb 6>:
  sdp = sdp_session (parser);
  if (sdp != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40404 = switch_core_media_get_codec_string (session);
  switch_core_media_set_r_sdp_codec_string (session, D.40404, sdp, sdp_type);

<bb 8>:
  sdp_parser_free (parser);

<bb 9>:
  return;

}



;; Function switch_core_media_set_r_sdp_codec_string (switch_core_media_set_r_sdp_codec_string)

Scope blocks:

{ Scope block #0 
  char buf[1024]; (unused)
  struct sdp_media_t * m; (unused)
  struct sdp_attribute_t * attr; (unused)
  int ptime; (unused)
  int dptime; (unused)
  struct sdp_connection_t * connection; (unused)
  struct sdp_rtpmap_t * map; (unused)
  short int match; (unused)
  int i; (unused)
  int already_did[128]; (unused)
  int num_codecs; (unused)
  char * codec_order[50]; (unused)
  const struct switch_codec_implementation_t * codecs[50]; (unused)
  struct switch_channel_t * channel; (unused)
  int prefer_sdp; (unused)
  const char * var; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[41] = "switch_core_media_set_r_sdp_codec_string"; (unused)
  static const char __func__[41] = "switch_core_media_set_r_sdp_codec_string"; (unused)

  { Scope block #0 
    char * tmp_codec_string; (unused)

  }

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)

  }

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)

  }

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       140 (fallthru)
<bb 5>:
goto <bb 140>;


Removing basic block 13
;; basic block 13, loop depth 0, count 0
;; prev block 12, next block 14
;; pred:      
;; succ:       15 (fallthru)
<bb 13>:
goto <bb 15>;


Removing basic block 16
;; basic block 16, loop depth 0, count 0
;; prev block 15, next block 17
;; pred:      
;; succ:       140 (fallthru)
<bb 16>:
goto <bb 140>;


Removing basic block 78
;; basic block 78, loop depth 0, count 0
;; prev block 77, next block 79
;; pred:      
;; succ:       101 (fallthru)
<bb 78>:
goto <bb 101>;


Removing basic block 101
;; basic block 101, loop depth 0, count 0
;; prev block 100, next block 102
;; pred:      
;; succ:       136 (fallthru)
<bb 101>:
goto <bb 136>;


switch_core_media_set_r_sdp_codec_string (struct switch_core_session_t * session, const char * codec_string, struct sdp_session_t * sdp, switch_sdp_type_t sdp_type)
{
  const struct switch_codec_implementation_t * imp;
  const struct switch_codec_implementation_t * imp;
  const struct switch_codec_implementation_t * imp;
  char * tmp_codec_string;
  static const char __func__[41] = "switch_core_media_set_r_sdp_codec_string";
  static const char __PRETTY_FUNCTION__[41] = "switch_core_media_set_r_sdp_codec_string";
  struct switch_media_handle_t * smh;
  const char * var;
  int prefer_sdp;
  struct switch_channel_t * channel;
  const struct switch_codec_implementation_t * codecs[50];
  char * codec_order[50];
  int num_codecs;
  int already_did[128];
  int i;
  short int match;
  struct sdp_rtpmap_t * map;
  struct sdp_connection_t * connection;
  int dptime;
  int ptime;
  struct sdp_attribute_t * attr;
  struct sdp_media_t * m;
  char buf[1024];
  char D.40591;
  unsigned int D.40590;
  size_t D.40589;
  char * D.40588;
  size_t D.40587;
  unsigned int D.40585;
  size_t D.40584;
  char * D.40583;
  size_t D.40582;
  int D.40576;
  char * const D.40575;
  int D.40570;
  uint32_t D.40561;
  switch_call_direction_t D.40558;
  struct switch_channel_t * D.40557;
  int D.40556;
  int D.40555;
  signed char D.40553;
  const switch_payload_t D.40552;
  const switch_codec_type_t D.40550;
  struct switch_core_session_t * D.40547;
  int D.40535;
  char * const D.40534;
  int D.40529;
  int D.40522;
  int D.40521;
  signed char D.40519;
  const switch_payload_t D.40518;
  const switch_codec_type_t D.40516;
  int D.40510;
  char * const D.40509;
  int D.40506;
  const switch_payload_t D.40505;
  _Bool D.40503;
  int D.40502;
  int D.40501;
  switch_core_media_NDLB_t D.40500;
  struct switch_core_media_params_t * D.40499;
  int D.40497;
  int D.40493;
  int D.40491;
  switch_call_direction_t D.40487;
  struct switch_core_session_t * D.40484;
  struct sdp_connection_t * D.40479;
  int D.40474;
  int D.40471;
  unsigned int D.40466;
  size_t D.40465;
  char * D.40464;
  size_t D.40463;
  uint32_t ptime.5;
  long unsigned int D.40457;
  uint32_t D.40456;
  <unnamed-unsigned:7> D.40455;
  const char * D.40454;
  const char * D.40453;
  switch_media_type_t D.40452;
  int D.40447;
  int D.40444;
  long unsigned int D.40441;
  unsigned int D.40438;
  sdp_media_e D.40437;
  const char * D.40436;
  int D.40433;
  int D.40430;
  const char * D.40429;
  _Bool D.40426;
  _Bool D.40425;
  _Bool D.40424;
  unsigned int D.40420;
  int D.40415;
  int D.40412;

<bb 2>:
  buf = {};
  ptime = 0;
  dptime = 0;
  match = 0;
  already_did = {};
  num_codecs = 0;
  codecs = {};
  channel = switch_core_session_get_channel (session);
  prefer_sdp = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8198, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 135>;
  else
    goto <bb 5>;

<bb 5>:
  var = switch_channel_get_variable_dup (channel, "ep_codec_prefer_sdp", 1, -1);
  if (var != 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 6>:
  D.40412 = switch_true (var);
  if (D.40412 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  prefer_sdp = 1;

<bb 8>:
  D.40415 = _zstr (codec_string);
  if (D.40415 == 0)
    goto <bb 9>;
  else
    goto <bb 12>;

<bb 9>:
  tmp_codec_string = __strdup (codec_string);
  if (tmp_codec_string != 0B)
    goto <bb 10>;
  else
    goto <bb 13>;

<bb 10>:
  D.40420 = switch_separate_string (tmp_codec_string, 44, &codec_order, 50);
  num_codecs = (int) D.40420;
  num_codecs = switch_loadable_module_get_codecs_sorted (&codecs, 50, &codec_order, num_codecs);
  if (tmp_codec_string != 0B)
    goto <bb 11>;
  else
    goto <bb 13>;

<bb 11>:
  free (tmp_codec_string);
  tmp_codec_string = 0B;
  goto <bb 13>;

<bb 12>:
  num_codecs = switch_loadable_module_get_codecs (&codecs, 50);

<bb 13>:
  D.40424 = channel == 0B;
  D.40425 = num_codecs == 0;
  D.40426 = D.40424 || D.40425;
  if (D.40426 != 0)
    goto <bb 135>;
  else
    goto <bb 14>;

<bb 14>:
  attr = sdp->sdp_attributes;
  goto <bb 20>;

<bb 15>:
  D.40429 = attr->a_name;
  D.40430 = _zstr (D.40429);
  if (D.40430 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  // predicted unlikely by continue predictor.
  goto <bb 19>;

<bb 17>:
  D.40429 = attr->a_name;
  D.40433 = strcasecmp (D.40429, "ptime");
  if (D.40433 == 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.40436 = attr->a_value;
  dptime = atoi (D.40436);
  goto <bb 21>;

<bb 19>:
  attr = attr->a_next;

<bb 20>:
  if (attr != 0B)
    goto <bb 15>;
  else
    goto <bb 21>;

<bb 21>:
  switch_core_media_find_zrtp_hash (session, sdp);
  switch_core_media_pass_zrtp_hash (session);
  m = sdp->sdp_media;
  goto <bb 36>;

<bb 22>:
  ptime = dptime;
  D.40437 = m->m_type;
  D.40438 = D.40437 + 4294967294;
  if (D.40438 <= 1)
    goto <bb 23>;
  else
    goto <bb 35>;

<bb 23>:
  D.40441 = m->m_port;
  if (D.40441 != 0)
    goto <bb 24>;
  else
    goto <bb 35>;

<bb 24>:
  map = m->m_rtpmaps;
  goto <bb 34>;

<bb 25>:
  attr = m->m_attributes;
  goto <bb 32>;

<bb 26>:
  D.40429 = attr->a_name;
  D.40444 = _zstr (D.40429);
  if (D.40444 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  // predicted unlikely by continue predictor.
  goto <bb 31>;

<bb 28>:
  D.40429 = attr->a_name;
  D.40447 = strcasecmp (D.40429, "ptime");
  if (D.40447 == 0)
    goto <bb 29>;
  else
    goto <bb 31>;

<bb 29>:
  D.40436 = attr->a_value;
  if (D.40436 != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  D.40436 = attr->a_value;
  ptime = atoi (D.40436);
  goto <bb 33>;

<bb 31>:
  attr = attr->a_next;

<bb 32>:
  if (attr != 0B)
    goto <bb 26>;
  else
    goto <bb 33>;

<bb 33>:
  D.40437 = m->m_type;
  D.40452 = D.40437 != 2;
  D.40453 = map->rm_encoding;
  D.40454 = map->rm_fmtp;
  D.40455 = map->rm_pt;
  D.40456 = (uint32_t) D.40455;
  D.40457 = map->rm_rate;
  ptime.5 = (uint32_t) ptime;
  switch_core_media_add_payload_map (session, D.40452, D.40453, D.40454, sdp_type, D.40456, D.40457, ptime.5, 0);
  map = map->rm_next;

<bb 34>:
  if (map != 0B)
    goto <bb 25>;
  else
    goto <bb 35>;

<bb 35>:
  m = m->m_next;

<bb 36>:
  if (m != 0B)
    goto <bb 22>;
  else
    goto <bb 37>;

<bb 37>:
  m = sdp->sdp_media;
  goto <bb 132>;

<bb 38>:
  ptime = dptime;
  D.40437 = m->m_type;
  if (D.40437 == 8)
    goto <bb 39>;
  else
    goto <bb 41>;

<bb 39>:
  D.40441 = m->m_port;
  if (D.40441 != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  D.40463 = strlen (&buf);
  D.40464 = &buf + D.40463;
  D.40465 = strlen (&buf);
  D.40466 = 1024 - D.40465;
  switch_snprintf (D.40464, D.40466, ",t38");
  goto <bb 131>;

<bb 41>:
  D.40437 = m->m_type;
  if (D.40437 == 2)
    goto <bb 42>;
  else
    goto <bb 97>;

<bb 42>:
  D.40441 = m->m_port;
  if (D.40441 != 0)
    goto <bb 43>;
  else
    goto <bb 97>;

<bb 43>:
  attr = m->m_attributes;
  goto <bb 50>;

<bb 44>:
  D.40429 = attr->a_name;
  D.40471 = _zstr (D.40429);
  if (D.40471 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  // predicted unlikely by continue predictor.
  goto <bb 49>;

<bb 46>:
  D.40429 = attr->a_name;
  D.40474 = strcasecmp (D.40429, "ptime");
  if (D.40474 == 0)
    goto <bb 47>;
  else
    goto <bb 49>;

<bb 47>:
  D.40436 = attr->a_value;
  if (D.40436 != 0B)
    goto <bb 48>;
  else
    goto <bb 49>;

<bb 48>:
  D.40436 = attr->a_value;
  ptime = atoi (D.40436);
  goto <bb 51>;

<bb 49>:
  attr = attr->a_next;

<bb 50>:
  if (attr != 0B)
    goto <bb 44>;
  else
    goto <bb 51>;

<bb 51>:
  connection = sdp->sdp_connection;
  D.40479 = m->m_connections;
  if (D.40479 != 0B)
    goto <bb 52>;
  else
    goto <bb 53>;

<bb 52>:
  connection = m->m_connections;

<bb 53>:
  if (connection == 0B)
    goto <bb 54>;
  else
    goto <bb 55>;

<bb 54>:
  D.40484 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 8285, D.40484, 3, "Cannot find a c= line in the sdp at media or session level!\n");
  goto <bb 133>;

<bb 55>:
  D.40487 = switch_channel_direction (channel);
  if (D.40487 == 0)
    goto <bb 57>;
  else
    goto <bb 56>;

<bb 56>:
  if (prefer_sdp != 0)
    goto <bb 57>;
  else
    goto <bb 75>;

<bb 57>:
  map = m->m_rtpmaps;
  goto <bb 74>;

<bb 58>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 > 127)
    goto <bb 60>;
  else
    goto <bb 59>;

<bb 59>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40493 = already_did[D.40491];
  if (D.40493 != 0)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  // predicted unlikely by continue predictor.
  goto <bb 73>;

<bb 61>:
  i = 0;
  goto <bb 72>;

<bb 62>:
  imp = codecs[i];
  D.40453 = map->rm_encoding;
  D.40497 = _zstr (D.40453);
  if (D.40497 != 0)
    goto <bb 64>;
  else
    goto <bb 63>;

<bb 63>:
  D.40499 = smh->mparams;
  D.40500 = D.40499->ndlb;
  D.40501 = (int) D.40500;
  D.40502 = D.40501 & 1;
  D.40503 = (_Bool) D.40502;
  if (D.40503 != 0)
    goto <bb 64>;
  else
    goto <bb 66>;

<bb 64>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 <= 95)
    goto <bb 65>;
  else
    goto <bb 66>;

<bb 65>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40505 = imp->ianacode;
  D.40506 = (int) D.40505;
  match = D.40491 == D.40506;
  goto <bb 69>;

<bb 66>:
  D.40453 = map->rm_encoding;
  if (D.40453 != 0B)
    goto <bb 67>;
  else
    goto <bb 68>;

<bb 67>:
  D.40453 = map->rm_encoding;
  D.40509 = imp->iananame;
  D.40510 = strcasecmp (D.40453, D.40509);
  match = D.40510 == 0;
  goto <bb 69>;

<bb 68>:
  match = 0;

<bb 69>:
  if (match != 0)
    goto <bb 70>;
  else
    goto <bb 71>;

<bb 70>:
  add_audio_codec (map, ptime, &buf, 1024);
  goto <bb 73>;

<bb 71>:
  i = i + 1;

<bb 72>:
  if (i < num_codecs)
    goto <bb 62>;
  else
    goto <bb 73>;

<bb 73>:
  map = map->rm_next;

<bb 74>:
  if (map != 0B)
    goto <bb 58>;
  else
    goto <bb 131>;

<bb 75>:
  i = 0;
  goto <bb 96>;

<bb 76>:
  imp = codecs[i];
  D.40516 = imp->codec_type;
  if (D.40516 != 0)
    goto <bb 79>;
  else
    goto <bb 77>;

<bb 77>:
  D.40518 = imp->ianacode;
  D.40519 = (signed char) D.40518;
  if (D.40519 < 0)
    goto <bb 79>;
  else
    goto <bb 78>;

<bb 78>:
  D.40518 = imp->ianacode;
  D.40521 = (int) D.40518;
  D.40522 = already_did[D.40521];
  if (D.40522 != 0)
    goto <bb 79>;
  else
    goto <bb 80>;

<bb 79>:
  // predicted unlikely by continue predictor.
  goto <bb 95>;

<bb 80>:
  map = m->m_rtpmaps;
  goto <bb 94>;

<bb 81>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 > 127)
    goto <bb 83>;
  else
    goto <bb 82>;

<bb 82>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40493 = already_did[D.40491];
  if (D.40493 != 0)
    goto <bb 83>;
  else
    goto <bb 84>;

<bb 83>:
  // predicted unlikely by continue predictor.
  goto <bb 93>;

<bb 84>:
  D.40453 = map->rm_encoding;
  D.40529 = _zstr (D.40453);
  if (D.40529 != 0)
    goto <bb 86>;
  else
    goto <bb 85>;

<bb 85>:
  D.40499 = smh->mparams;
  D.40500 = D.40499->ndlb;
  D.40501 = (int) D.40500;
  D.40502 = D.40501 & 1;
  D.40503 = (_Bool) D.40502;
  if (D.40503 != 0)
    goto <bb 86>;
  else
    goto <bb 88>;

<bb 86>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 <= 95)
    goto <bb 87>;
  else
    goto <bb 88>;

<bb 87>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40518 = imp->ianacode;
  D.40521 = (int) D.40518;
  match = D.40491 == D.40521;
  goto <bb 91>;

<bb 88>:
  D.40453 = map->rm_encoding;
  if (D.40453 != 0B)
    goto <bb 89>;
  else
    goto <bb 90>;

<bb 89>:
  D.40453 = map->rm_encoding;
  D.40534 = imp->iananame;
  D.40535 = strcasecmp (D.40453, D.40534);
  match = D.40535 == 0;
  goto <bb 91>;

<bb 90>:
  match = 0;

<bb 91>:
  if (match != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  add_audio_codec (map, ptime, &buf, 1024);
  goto <bb 95>;

<bb 93>:
  map = map->rm_next;

<bb 94>:
  if (map != 0B)
    goto <bb 81>;
  else
    goto <bb 95>;

<bb 95>:
  i = i + 1;

<bb 96>:
  if (i < num_codecs)
    goto <bb 76>;
  else
    goto <bb 131>;

<bb 97>:
  D.40437 = m->m_type;
  if (D.40437 == 3)
    goto <bb 98>;
  else
    goto <bb 131>;

<bb 98>:
  D.40441 = m->m_port;
  if (D.40441 != 0)
    goto <bb 99>;
  else
    goto <bb 131>;

<bb 99>:
  connection = sdp->sdp_connection;
  D.40479 = m->m_connections;
  if (D.40479 != 0B)
    goto <bb 100>;
  else
    goto <bb 101>;

<bb 100>:
  connection = m->m_connections;

<bb 101>:
  if (connection == 0B)
    goto <bb 102>;
  else
    goto <bb 103>;

<bb 102>:
  D.40547 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 8352, D.40547, 3, "Cannot find a c= line in the sdp at media or session level!\n");
  goto <bb 133>;

<bb 103>:
  i = 0;
  goto <bb 130>;

<bb 104>:
  imp = codecs[i];
  D.40550 = imp->codec_type;
  if (D.40550 != 1)
    goto <bb 107>;
  else
    goto <bb 105>;

<bb 105>:
  D.40552 = imp->ianacode;
  D.40553 = (signed char) D.40552;
  if (D.40553 < 0)
    goto <bb 107>;
  else
    goto <bb 106>;

<bb 106>:
  D.40552 = imp->ianacode;
  D.40555 = (int) D.40552;
  D.40556 = already_did[D.40555];
  if (D.40556 != 0)
    goto <bb 107>;
  else
    goto <bb 108>;

<bb 107>:
  // predicted unlikely by continue predictor.
  goto <bb 129>;

<bb 108>:
  D.40557 = session->channel;
  D.40558 = switch_channel_direction (D.40557);
  if (D.40558 == 0)
    goto <bb 109>;
  else
    goto <bb 111>;

<bb 109>:
  D.40557 = session->channel;
  D.40561 = switch_channel_test_flag (D.40557, 114);
  if (D.40561 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

<bb 110>:
  // predicted unlikely by continue predictor.
  goto <bb 129>;

<bb 111>:
  map = m->m_rtpmaps;
  goto <bb 128>;

<bb 112>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 > 127)
    goto <bb 114>;
  else
    goto <bb 113>;

<bb 113>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40493 = already_did[D.40491];
  if (D.40493 != 0)
    goto <bb 114>;
  else
    goto <bb 115>;

<bb 114>:
  // predicted unlikely by continue predictor.
  goto <bb 127>;

<bb 115>:
  D.40453 = map->rm_encoding;
  D.40570 = _zstr (D.40453);
  if (D.40570 != 0)
    goto <bb 117>;
  else
    goto <bb 116>;

<bb 116>:
  D.40499 = smh->mparams;
  D.40500 = D.40499->ndlb;
  D.40501 = (int) D.40500;
  D.40502 = D.40501 & 1;
  D.40503 = (_Bool) D.40502;
  if (D.40503 != 0)
    goto <bb 117>;
  else
    goto <bb 119>;

<bb 117>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  if (D.40491 <= 95)
    goto <bb 118>;
  else
    goto <bb 119>;

<bb 118>:
  D.40455 = map->rm_pt;
  D.40491 = (int) D.40455;
  D.40552 = imp->ianacode;
  D.40555 = (int) D.40552;
  match = D.40491 == D.40555;
  goto <bb 122>;

<bb 119>:
  D.40453 = map->rm_encoding;
  if (D.40453 != 0B)
    goto <bb 120>;
  else
    goto <bb 121>;

<bb 120>:
  D.40453 = map->rm_encoding;
  D.40575 = imp->iananame;
  D.40576 = strcasecmp (D.40453, D.40575);
  match = D.40576 == 0;
  goto <bb 122>;

<bb 121>:
  match = 0;

<bb 122>:
  if (match != 0)
    goto <bb 123>;
  else
    goto <bb 127>;

<bb 123>:
  if (ptime > 0)
    goto <bb 124>;
  else
    goto <bb 125>;

<bb 124>:
  D.40582 = strlen (&buf);
  D.40583 = &buf + D.40582;
  D.40584 = strlen (&buf);
  D.40585 = 1024 - D.40584;
  D.40575 = imp->iananame;
  D.40457 = map->rm_rate;
  switch_snprintf (D.40583, D.40585, ",%s@%uh@%di", D.40575, D.40457, ptime);
  goto <bb 126>;

<bb 125>:
  D.40587 = strlen (&buf);
  D.40588 = &buf + D.40587;
  D.40589 = strlen (&buf);
  D.40590 = 1024 - D.40589;
  D.40575 = imp->iananame;
  D.40457 = map->rm_rate;
  switch_snprintf (D.40588, D.40590, ",%s@%uh", D.40575, D.40457);

<bb 126>:
  D.40552 = imp->ianacode;
  D.40555 = (int) D.40552;
  already_did[D.40555] = 1;
  goto <bb 129>;

<bb 127>:
  map = map->rm_next;

<bb 128>:
  if (map != 0B)
    goto <bb 112>;
  else
    goto <bb 129>;

<bb 129>:
  i = i + 1;

<bb 130>:
  if (i < num_codecs)
    goto <bb 104>;
  else
    goto <bb 131>;

<bb 131>:
  m = m->m_next;

<bb 132>:
  if (m != 0B)
    goto <bb 38>;
  else
    goto <bb 133>;

<bb 133>:
  D.40591 = buf[0];
  if (D.40591 == 44)
    goto <bb 134>;
  else
    goto <bb 135>;

<bb 134>:
  switch_channel_set_variable_var_check (channel, "ep_codec_string", &buf[1], 1);

<bb 135>:
  return;

}



;; Function switch_true (switch_true)

Scope blocks:

{ Scope block #0 

}
Merging blocks 14 and 15
switch_true (const char * expr)
{
  int D.40617;
  switch_bool_t D.40615;
  int D.40613;
  int D.40611;
  int D.40609;
  int D.40607;
  int D.40605;
  int D.40603;
  int D.40601;
  int iftmp.6;
  int D.40595;

<bb 2>:
  if (expr != 0B)
    goto <bb 3>;
  else
    goto <bb 13>;

<bb 3>:
  D.40601 = strcasecmp (expr, "yes");
  if (D.40601 == 0)
    goto <bb 12>;
  else
    goto <bb 4>;

<bb 4>:
  D.40603 = strcasecmp (expr, "on");
  if (D.40603 == 0)
    goto <bb 12>;
  else
    goto <bb 5>;

<bb 5>:
  D.40605 = strcasecmp (expr, "true");
  if (D.40605 == 0)
    goto <bb 12>;
  else
    goto <bb 6>;

<bb 6>:
  D.40607 = strcasecmp (expr, "t");
  if (D.40607 == 0)
    goto <bb 12>;
  else
    goto <bb 7>;

<bb 7>:
  D.40609 = strcasecmp (expr, "enabled");
  if (D.40609 == 0)
    goto <bb 12>;
  else
    goto <bb 8>;

<bb 8>:
  D.40611 = strcasecmp (expr, "active");
  if (D.40611 == 0)
    goto <bb 12>;
  else
    goto <bb 9>;

<bb 9>:
  D.40613 = strcasecmp (expr, "allow");
  if (D.40613 == 0)
    goto <bb 12>;
  else
    goto <bb 10>;

<bb 10>:
  D.40615 = switch_is_number (expr);
  if (D.40615 != 0)
    goto <bb 11>;
  else
    goto <bb 13>;

<bb 11>:
  D.40617 = atoi (expr);
  if (D.40617 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  iftmp.6 = 1;
  goto <bb 14>;

<bb 13>:
  iftmp.6 = 0;

<bb 14>:
  D.40595 = iftmp.6;
  return D.40595;

}



;; Function switch_core_media_find_zrtp_hash (switch_core_media_find_zrtp_hash)

Scope blocks:

{ Scope block #0 
  struct switch_channel_t * channel; (unused)
  struct switch_rtp_engine_t * audio_engine; (unused)
  struct switch_rtp_engine_t * video_engine; (unused)
  struct sdp_media_t * m; (unused)
  struct sdp_attribute_t * attr; (unused)
  int got_audio; (unused)
  int got_video; (unused)
  static const char __func__[33] = "switch_core_media_find_zrtp_hash"; (unused)

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       24 (fallthru)
<bb 3>:
goto <bb 24>;


switch_core_media_find_zrtp_hash (struct switch_core_session_t * session, struct sdp_session_t * sdp)
{
  static const char __func__[33] = "switch_core_media_find_zrtp_hash";
  int got_video;
  int got_audio;
  struct sdp_attribute_t * attr;
  struct sdp_media_t * m;
  struct switch_rtp_engine_t * video_engine;
  struct switch_rtp_engine_t * audio_engine;
  struct switch_channel_t * channel;
  char * D.40656;
  struct switch_core_session_t * D.40655;
  char * D.40651;
  struct switch_core_session_t * D.40650;
  const char * D.40647;
  int D.40645;
  int D.40640;
  const char * D.40639;
  _Bool D.40638;
  _Bool D.40637;
  _Bool D.40636;
  _Bool D.40634;
  _Bool D.40633;
  _Bool D.40632;
  sdp_media_e D.40631;
  long unsigned int D.40628;
  _Bool D.40625;
  _Bool D.40624;
  _Bool D.40623;
  struct switch_core_session_t * D.40622;
  struct switch_media_handle_t * D.40619;

<bb 2>:
  channel = switch_core_session_get_channel (session);
  got_audio = 0;
  got_video = 0;
  D.40619 = session->media_handle;
  if (D.40619 == 0B)
    goto <bb 23>;
  else
    goto <bb 3>;

<bb 3>:
  D.40619 = session->media_handle;
  audio_engine = &D.40619->engines;
  D.40619 = session->media_handle;
  video_engine = &D.40619->engines[1];
  D.40622 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 334, D.40622, 101, "Looking for zrtp-hash\n");
  m = sdp->sdp_media;
  goto <bb 22>;

<bb 4>:
  D.40623 = got_audio != 0;
  D.40624 = got_video != 0;
  D.40625 = D.40623 && D.40624;
  if (D.40625 != 0)
    goto <bb 23>;
  else
    goto <bb 5>;

<bb 5>:
  D.40628 = m->m_port;
  if (D.40628 != 0)
    goto <bb 6>;
  else
    goto <bb 21>;

<bb 6>:
  D.40631 = m->m_type;
  D.40632 = D.40631 == 2;
  D.40633 = got_audio == 0;
  D.40634 = D.40632 && D.40633;
  if (D.40634 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

<bb 7>:
  D.40631 = m->m_type;
  D.40636 = D.40631 == 3;
  D.40637 = got_video == 0;
  D.40638 = D.40636 && D.40637;
  if (D.40638 != 0)
    goto <bb 8>;
  else
    goto <bb 21>;

<bb 8>:
  attr = m->m_attributes;
  goto <bb 20>;

<bb 9>:
  D.40639 = attr->a_name;
  D.40640 = _zstr (D.40639);
  if (D.40640 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  // predicted unlikely by continue predictor.
  goto <bb 19>;

<bb 11>:
  D.40639 = attr->a_name;
  D.40645 = strcasecmp (D.40639, "zrtp-hash");
  if (D.40645 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

<bb 12>:
  D.40647 = attr->a_value;
  if (D.40647 == 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  // predicted unlikely by continue predictor.
  goto <bb 19>;

<bb 14>:
  D.40631 = m->m_type;
  if (D.40631 == 2)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.40650 = switch_channel_get_session (channel);
  D.40647 = attr->a_value;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 343, D.40650, 7, "Found audio zrtp-hash; setting r_sdp_audio_zrtp_hash=%s\n", D.40647);
  D.40647 = attr->a_value;
  switch_channel_set_variable_var_check (channel, "r_sdp_audio_zrtp_hash", D.40647, 1);
  D.40647 = attr->a_value;
  D.40651 = switch_core_perform_session_strdup (session, D.40647, "src/switch_core_media.c", &__func__, 346);
  audio_engine->remote_sdp_zrtp_hash = D.40651;
  got_audio = got_audio + 1;
  goto <bb 18>;

<bb 16>:
  D.40631 = m->m_type;
  if (D.40631 == 3)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.40655 = switch_channel_get_session (channel);
  D.40647 = attr->a_value;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 349, D.40655, 7, "Found video zrtp-hash; setting r_sdp_video_zrtp_hash=%s\n", D.40647);
  D.40647 = attr->a_value;
  switch_channel_set_variable_var_check (channel, "r_sdp_video_zrtp_hash", D.40647, 1);
  D.40647 = attr->a_value;
  D.40656 = switch_core_perform_session_strdup (session, D.40647, "src/switch_core_media.c", &__func__, 352);
  video_engine->remote_sdp_zrtp_hash = D.40656;
  got_video = got_video + 1;

<bb 18>:
  switch_channel_set_flag_value (channel, 75, 1);
  goto <bb 21>;

<bb 19>:
  attr = attr->a_next;

<bb 20>:
  if (attr != 0B)
    goto <bb 9>;
  else
    goto <bb 21>;

<bb 21>:
  m = m->m_next;

<bb 22>:
  if (m != 0B)
    goto <bb 4>;
  else
    goto <bb 23>;

<bb 23>:
  return;

}



;; Function add_audio_codec (add_audio_codec)

Scope blocks:

{ Scope block #0 
  int codec_ms; (unused)
  uint32_t map_bit_rate; (unused)
  char ptstr[20]; (unused)
  char ratestr[20]; (unused)
  char bitstr[20]; (unused)
  struct switch_codec_fmtp_t codec_fmtp; (unused)

}
Removing basic block 12
;; basic block 12, loop depth 0, count 0
;; prev block 11, next block 13
;; pred:      
;; succ:       18 (fallthru)
<bb 12>:
goto <bb 18>;


add_audio_codec (struct sdp_rtpmap_t * map, int ptime, char * buf, switch_size_t buflen)
{
  struct switch_codec_fmtp_t codec_fmtp;
  char bitstr[20];
  char ratestr[20];
  char ptstr[20];
  uint32_t map_bit_rate;
  int codec_ms;
  switch_size_t D.40701;
  size_t D.40700;
  char * D.40699;
  size_t D.40698;
  int D.40689;
  int D.40686;
  switch_status_t D.40683;
  long unsigned int D.40682;
  int D.40678;
  int D.40674;
  int D.40671;
  const char * D.40670;
  int D.40667;
  unsigned char D.40664;
  uint32_t D.40663;
  uint32_t D.40662;
  <unnamed-unsigned:7> D.40661;
  const char * D.40660;

<bb 2>:
  codec_ms = ptime;
  map_bit_rate = 0;
  ptstr = "";
  ratestr = "";
  bitstr = "";
  codec_fmtp = {};
  if (codec_ms == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.40660 = map->rm_encoding;
  D.40661 = map->rm_pt;
  D.40662 = (uint32_t) D.40661;
  D.40663 = switch_default_ptime (D.40660, D.40662);
  codec_ms = (int) D.40663;

<bb 4>:
  D.40661 = map->rm_pt;
  D.40664 = (unsigned char) D.40661;
  map_bit_rate = switch_known_bitrate (D.40664);
  if (ptime == 0)
    goto <bb 5>;
  else
    goto <bb 7>;

<bb 5>:
  D.40660 = map->rm_encoding;
  D.40667 = strcasecmp (D.40660, "g723");
  if (D.40667 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  codec_ms = 30;
  ptime = codec_ms;

<bb 7>:
  D.40670 = map->rm_fmtp;
  D.40671 = _zstr (D.40670);
  if (D.40671 != 0)
    goto <bb 8>;
  else
    goto <bb 12>;

<bb 8>:
  D.40660 = map->rm_encoding;
  D.40674 = strcasecmp (D.40660, "ilbc");
  if (D.40674 == 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  codec_ms = 30;
  ptime = codec_ms;
  map_bit_rate = 13330;
  goto <bb 17>;

<bb 10>:
  D.40660 = map->rm_encoding;
  D.40678 = strcasecmp (D.40660, "isac");
  if (D.40678 == 0)
    goto <bb 11>;
  else
    goto <bb 17>;

<bb 11>:
  codec_ms = 30;
  ptime = codec_ms;
  map_bit_rate = 32000;
  goto <bb 17>;

<bb 12>:
  D.40660 = map->rm_encoding;
  D.40670 = map->rm_fmtp;
  D.40682 = map->rm_rate;
  D.40683 = switch_core_codec_parse_fmtp (D.40660, D.40670, D.40682, &codec_fmtp);
  if (D.40683 == 0)
    goto <bb 13>;
  else
    goto <bb 17>;

<bb 13>:
  D.40686 = codec_fmtp.bits_per_second;
  if (D.40686 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.40686 = codec_fmtp.bits_per_second;
  map_bit_rate = (uint32_t) D.40686;

<bb 15>:
  D.40689 = codec_fmtp.microseconds_per_packet;
  if (D.40689 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.40689 = codec_fmtp.microseconds_per_packet;
  codec_ms = D.40689 / 1000;

<bb 17>:
  D.40682 = map->rm_rate;
  if (D.40682 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.40682 = map->rm_rate;
  switch_snprintf (&ratestr, 20, "@%uh", D.40682);

<bb 19>:
  if (codec_ms != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  switch_snprintf (&ptstr, 20, "@%di", codec_ms);

<bb 21>:
  if (map_bit_rate != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  switch_snprintf (&bitstr, 20, "@%db", map_bit_rate);

<bb 23>:
  D.40698 = strlen (buf);
  D.40699 = buf + D.40698;
  D.40700 = strlen (buf);
  D.40701 = buflen - D.40700;
  D.40660 = map->rm_encoding;
  switch_snprintf (D.40699, D.40701, ",%s%s%s%s", D.40660, &ratestr, &ptstr, &bitstr);
  return;

}



;; Function switch_known_bitrate (switch_known_bitrate)

Scope blocks:

{ Scope block #0 

}
Removing basic block 10
;; basic block 10, loop depth 0, count 0
;; prev block 9, next block 11
;; pred:      
;; succ:       11 (fallthru)
<L7>:


switch_known_bitrate (switch_payload_t payload)
{
  uint32_t D.40703;
  int D.40702;

<bb 2>:
  D.40702 = (int) payload;
  switch (D.40702) <default: <L10>, case 0: <L0>, case 3: <L1>, case 4: <L2>, case 7: <L3>, case 8: <L4>, case 9: <L5>, case 18: <L6>>

<L0>:
  D.40703 = 64000;
  goto <bb 11>;

<L1>:
  D.40703 = 13200;
  goto <bb 11>;

<L2>:
  D.40703 = 6300;
  goto <bb 11>;

<L3>:
  D.40703 = 2400;
  goto <bb 11>;

<L4>:
  D.40703 = 64000;
  goto <bb 11>;

<L5>:
  D.40703 = 64000;
  goto <bb 11>;

<L6>:
  D.40703 = 8000;
  goto <bb 11>;

<L10>:
  D.40703 = 0;

<bb 11>:
  return D.40703;

}



;; Function switch_core_media_get_jb (switch_core_media_get_jb)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[25] = "switch_core_media_get_jb"; (unused)

}
switch_core_media_get_jb (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[25] = "switch_core_media_get_jb";
  struct switch_media_handle_t * smh;
  uint8_t D.40712;
  struct switch_rtp_t * D.40711;
  struct stfu_instance_t * D.40710;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8084, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40710 = 0B;
  goto <bb 9>;

<bb 6>:
  D.40711 = smh->engines[type].rtp_session;
  D.40712 = switch_rtp_ready (D.40711);
  if (D.40712 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40711 = smh->engines[type].rtp_session;
  D.40710 = switch_rtp_get_jitter_buffer (D.40711);
  goto <bb 9>;

<bb 8>:
  D.40710 = 0B;

<bb 9>:
  return D.40710;

}



;; Function switch_core_media_udptl_mode (switch_core_media_udptl_mode)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_udptl_mode"; (unused)

}
switch_core_media_udptl_mode (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_udptl_mode";
  struct switch_media_handle_t * smh;
  uint8_t D.40722;
  struct switch_rtp_t * D.40721;
  switch_status_t D.40720;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8066, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40720 = 1;
  goto <bb 9>;

<bb 6>:
  D.40721 = smh->engines[type].rtp_session;
  D.40722 = switch_rtp_ready (D.40721);
  if (D.40722 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40721 = smh->engines[type].rtp_session;
  D.40720 = switch_rtp_udptl_mode (D.40721);
  goto <bb 9>;

<bb 8>:
  D.40720 = 1;

<bb 9>:
  return D.40720;

}



;; Function switch_core_media_get_stats (switch_core_media_get_stats)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_get_stats"; (unused)

}
switch_core_media_get_stats (struct switch_core_session_t * session, switch_media_type_t type, struct switch_memory_pool_t * pool)
{
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_get_stats";
  struct switch_media_handle_t * smh;
  struct switch_rtp_t * D.40731;
  struct switch_rtp_stats_t * D.40730;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8048, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40730 = 0B;
  goto <bb 9>;

<bb 6>:
  D.40731 = smh->engines[type].rtp_session;
  if (D.40731 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40731 = smh->engines[type].rtp_session;
  D.40730 = switch_rtp_get_stats (D.40731, pool);
  goto <bb 9>;

<bb 8>:
  D.40730 = 0B;

<bb 9>:
  return D.40730;

}



;; Function switch_core_media_set_telephony_recv_event (switch_core_media_set_telephony_recv_event)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[43] = "switch_core_media_set_telephony_recv_event"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_set_telephony_recv_event (struct switch_core_session_t * session, switch_media_type_t type, switch_payload_t te)
{
  static const char __PRETTY_FUNCTION__[43] = "switch_core_media_set_telephony_recv_event";
  struct switch_media_handle_t * smh;
  uint8_t D.40740;
  struct switch_rtp_t * D.40739;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8032, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40739 = smh->engines[type].rtp_session;
  D.40740 = switch_rtp_ready (D.40739);
  if (D.40740 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40739 = smh->engines[type].rtp_session;
  switch_rtp_set_telephony_recv_event (D.40739, te);

<bb 7>:
  return;

}



;; Function switch_core_media_set_telephony_event (switch_core_media_set_telephony_event)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_telephony_event"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_set_telephony_event (struct switch_core_session_t * session, switch_media_type_t type, switch_payload_t te)
{
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_telephony_event";
  struct switch_media_handle_t * smh;
  uint8_t D.40749;
  struct switch_rtp_t * D.40748;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8016, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40748 = smh->engines[type].rtp_session;
  D.40749 = switch_rtp_ready (D.40748);
  if (D.40749 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40748 = smh->engines[type].rtp_session;
  switch_rtp_set_telephony_event (D.40748, te);

<bb 7>:
  return;

}



;; Function switch_core_media_clear_rtp_flag (switch_core_media_clear_rtp_flag)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_clear_rtp_flag"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_clear_rtp_flag (struct switch_core_session_t * session, switch_media_type_t type, switch_rtp_flag_t flag)
{
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_clear_rtp_flag";
  struct switch_media_handle_t * smh;
  uint8_t D.40758;
  struct switch_rtp_t * D.40757;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 8000, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40757 = smh->engines[type].rtp_session;
  D.40758 = switch_rtp_ready (D.40757);
  if (D.40758 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40757 = smh->engines[type].rtp_session;
  switch_rtp_clear_flag (D.40757, flag);

<bb 7>:
  return;

}



;; Function switch_core_media_set_rtp_flag (switch_core_media_set_rtp_flag)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_set_rtp_flag"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_set_rtp_flag (struct switch_core_session_t * session, switch_media_type_t type, switch_rtp_flag_t flag)
{
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_set_rtp_flag";
  struct switch_media_handle_t * smh;
  uint8_t D.40767;
  struct switch_rtp_t * D.40766;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7984, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40766 = smh->engines[type].rtp_session;
  D.40767 = switch_rtp_ready (D.40766);
  if (D.40767 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40766 = smh->engines[type].rtp_session;
  switch_rtp_set_flag (D.40766, flag);

<bb 7>:
  return;

}



;; Function switch_core_media_ready (switch_core_media_ready)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_ready"; (unused)

}
switch_core_media_ready (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_ready";
  struct switch_media_handle_t * smh;
  struct switch_rtp_t * D.40776;
  uint8_t D.40775;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7970, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40775 = 0;
  goto <bb 7>;

<bb 6>:
  D.40776 = smh->engines[type].rtp_session;
  D.40775 = switch_rtp_ready (D.40776);

<bb 7>:
  return D.40775;

}



;; Function switch_core_media_queue_rfc2833_in (switch_core_media_queue_rfc2833_in)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_queue_rfc2833_in"; (unused)

}
switch_core_media_queue_rfc2833_in (struct switch_core_session_t * session, switch_media_type_t type, const struct switch_dtmf_t * dtmf)
{
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_queue_rfc2833_in";
  struct switch_media_handle_t * smh;
  uint8_t D.40784;
  struct switch_rtp_t * D.40783;
  switch_status_t D.40782;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7952, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40782 = 1;
  goto <bb 9>;

<bb 6>:
  D.40783 = smh->engines[type].rtp_session;
  D.40784 = switch_rtp_ready (D.40783);
  if (D.40784 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40783 = smh->engines[type].rtp_session;
  D.40782 = switch_rtp_queue_rfc2833_in (D.40783, dtmf);
  goto <bb 9>;

<bb 8>:
  D.40782 = 1;

<bb 9>:
  return D.40782;

}



;; Function switch_core_media_queue_rfc2833 (switch_core_media_queue_rfc2833)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_queue_rfc2833"; (unused)

}
switch_core_media_queue_rfc2833 (struct switch_core_session_t * session, switch_media_type_t type, const struct switch_dtmf_t * dtmf)
{
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_queue_rfc2833";
  struct switch_media_handle_t * smh;
  uint8_t D.40794;
  struct switch_rtp_t * D.40793;
  switch_status_t D.40792;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7934, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40792 = 1;
  goto <bb 9>;

<bb 6>:
  D.40793 = smh->engines[type].rtp_session;
  D.40794 = switch_rtp_ready (D.40793);
  if (D.40794 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.40793 = smh->engines[type].rtp_session;
  D.40792 = switch_rtp_queue_rfc2833 (D.40793, dtmf);
  goto <bb 9>;

<bb 8>:
  D.40792 = 1;

<bb 9>:
  return D.40792;

}



;; Function switch_core_media_kill_socket (switch_core_media_kill_socket)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_kill_socket"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_kill_socket (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_kill_socket";
  struct switch_media_handle_t * smh;
  uint8_t D.40803;
  struct switch_rtp_t * D.40802;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7918, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40802 = smh->engines[type].rtp_session;
  D.40803 = switch_rtp_ready (D.40802);
  if (D.40803 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40802 = smh->engines[type].rtp_session;
  switch_rtp_kill_socket (D.40802);

<bb 7>:
  return;

}



;; Function switch_core_media_break (switch_core_media_break)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_break"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_media_break (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_break";
  struct switch_media_handle_t * smh;
  uint8_t D.40812;
  struct switch_rtp_t * D.40811;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7902, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 7>;
  else
    goto <bb 5>;

<bb 5>:
  D.40811 = smh->engines[type].rtp_session;
  D.40812 = switch_rtp_ready (D.40811);
  if (D.40812 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.40811 = smh->engines[type].rtp_session;
  switch_rtp_break (D.40811);

<bb 7>:
  return;

}



;; Function switch_core_media_receive_message (switch_core_media_receive_message)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  switch_status_t status; (unused)
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_receive_message"; (unused)
  void end = <<< error >>>; (unused)
  static const char __func__[34] = "switch_core_media_receive_message"; (unused)
  void end_lock = <<< error >>>; (unused)

  { Scope block #0 
    int len; (unused)
    int maxlen; (unused)
    int qlen; (unused)
    int maxqlen; (unused)
    int max_drift; (unused)

    { Scope block #0 
      char * p; (unused)
      char * q; (unused)
      const char * s; (unused)

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

        { Scope block #0 
          const unsigned char * __s1; (unused)
          register int __result; (unused)

        }

      }

    }

  }

  { Scope block #0 
    struct switch_rtp_t * rtp; (unused)
    const char * direction; (unused)

    { Scope block #0 
      switch_rtp_flag_t flags[39]; (unused)
      int both; (unused)
      int set; (unused)

    }

  }

  { Scope block #0 
    const char * val; (unused)
    int ok; (unused)

  }

  { Scope block #0 
    const char * uuid; (unused)
    struct switch_core_session_t * other_session; (unused)
    struct switch_channel_t * other_channel; (unused)
    const char * ip; (unused)
    const char * port; (unused)

  }

  { Scope block #0 
    struct switch_core_session_t * nsession; (unused)

  }

  { Scope block #0 
    struct switch_t38_options_t * t38_options; (unused)

  }

}
Removing basic block 12
;; basic block 12, loop depth 0, count 0
;; prev block 11, next block 13
;; pred:      
;; succ:       142 (fallthru)
<bb 12>:
goto <bb 142>;


Removing basic block 15
;; basic block 15, loop depth 0, count 0
;; prev block 14, next block 16
;; pred:      
;; succ:       142 (fallthru)
<bb 15>:
goto <bb 142>;


Removing basic block 20
;; basic block 20, loop depth 0, count 0
;; prev block 19, next block 21
;; pred:      
;; succ:       142 (fallthru)
<bb 20>:
goto <bb 142>;


Removing basic block 54
;; basic block 54, loop depth 0, count 0
;; prev block 53, next block 55
;; pred:      
;; succ:       56 (fallthru)
<bb 54>:
goto <bb 56>;


Removing basic block 56
;; basic block 56, loop depth 0, count 0
;; prev block 55, next block 57
;; pred:      
;; succ:       58 (fallthru)
<bb 56>:
goto <bb 58>;


Removing basic block 58
;; basic block 58, loop depth 0, count 0
;; prev block 57, next block 59
;; pred:      
;; succ:       142 (fallthru)
<bb 58>:
goto <bb 142>;


Removing basic block 75
;; basic block 75, loop depth 0, count 0
;; prev block 74, next block 76
;; pred:      
;; succ:       77 (fallthru)
<bb 75>:
goto <bb 77>;


Removing basic block 77
;; basic block 77, loop depth 0, count 0
;; prev block 76, next block 78
;; pred:      
;; succ:       177 (fallthru)
<bb 77>:
goto <bb 177> (end);


Removing basic block 81
;; basic block 81, loop depth 0, count 0
;; prev block 80, next block 82
;; pred:      
;; succ:       177 (fallthru)
<bb 81>:
goto <bb 177> (end);


Removing basic block 108
;; basic block 108, loop depth 0, count 0
;; prev block 107, next block 109
;; pred:      
;; succ:       177 (fallthru)
<bb 108>:
goto <bb 177> (end);


Removing basic block 123
;; basic block 123, loop depth 0, count 0
;; prev block 122, next block 124
;; pred:      
;; succ:       177 (fallthru)
<bb 123>:
goto <bb 177> (end);


Removing basic block 126
;; basic block 126, loop depth 0, count 0
;; prev block 125, next block 127
;; pred:      
;; succ:       177 (fallthru)
<bb 126>:
goto <bb 177> (end);


Removing basic block 129
;; basic block 129, loop depth 0, count 0
;; prev block 128, next block 130
;; pred:      
;; succ:       142 (fallthru)
<bb 129>:
goto <bb 142>;


Removing basic block 140
;; basic block 140, loop depth 0, count 0
;; prev block 139, next block 141
;; pred:      
;; succ:       142 (fallthru)
<bb 140>:
goto <bb 142>;


Removing basic block 141
;; basic block 141, loop depth 0, count 0
;; prev block 139, next block 142
;; pred:      
;; succ:       142 (fallthru)
<L163>:


Removing basic block 162
;; basic block 162, loop depth 0, count 0
;; prev block 161, next block 163
;; pred:      
;; succ:       175 (fallthru)
<bb 162>:
goto <bb 175> (end_lock);


Removing basic block 171
;; basic block 171, loop depth 0, count 0
;; prev block 170, next block 172
;; pred:      
;; succ:       175 (fallthru)
<bb 171>:
goto <bb 175> (end_lock);


Removing basic block 174
;; basic block 174, loop depth 0, count 0
;; prev block 173, next block 175
;; pred:      
;; succ:       175 (fallthru)
<L200>:


switch_core_media_receive_message (struct switch_core_session_t * session, struct switch_core_session_message_t * msg)
{
  struct switch_t38_options_t * t38_options;
  struct switch_core_session_t * nsession;
  const char * port;
  const char * ip;
  struct switch_channel_t * other_channel;
  struct switch_core_session_t * other_session;
  const char * uuid;
  int ok;
  const char * val;
  int set;
  int both;
  switch_rtp_flag_t flags[39];
  const char * direction;
  struct switch_rtp_t * rtp;
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  const char * s;
  char * q;
  char * p;
  int max_drift;
  int maxqlen;
  int qlen;
  int maxlen;
  int len;
  static const char __func__[34] = "switch_core_media_receive_message";
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_receive_message";
  switch_status_t status;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  switch_channel_state_t D.41130;
  int D.41128;
  uint32_t D.41119;
  uint32_t D.41113;
  uint8_t D.41108;
  struct switch_core_session_t * nsession.13;
  switch_status_t D.41104;
  char * D.41101;
  struct payload_map_t * D.41100;
  char * iftmp.12;
  char * D.41092;
  struct payload_map_t * D.41091;
  char * iftmp.11;
  const char D.41086;
  switch_channel_state_t D.41083;
  int D.41081;
  struct switch_mutex_t * D.41076;
  char * D.41071;
  struct switch_core_media_params_t * D.41070;
  short unsigned int D.41069;
  int D.41068;
  _Bool D.41065;
  _Bool D.41064;
  _Bool D.41063;
  const char * D.41058;
  int D.41055;
  const char * D.41054;
  uint32_t D.41051;
  uint8_t D.41048;
  uint32_t D.41044;
  uint32_t D.41041;
  uint32_t D.41038;
  uint32_t D.41035;
  char * D.41034;
  uint32_t D.41031;
  char * D.41030;
  uint32_t D.41027;
  unsigned int D.41026;
  unsigned int D.41023;
  uint8_t D.41020;
  switch_core_media_flag_t D.41016;
  uint32_t D.41011;
  uint32_t D.41003;
  uint32_t D.41000;
  char * D.40996;
  uint32_t D.40993;
  uint32_t D.40990;
  unsigned int D.40989;
  smh_flag_t D.40988;
  char * D.40987;
  uint32_t D.40984;
  uint32_t D.40981;
  int D.40980;
  uint8_t D.40974;
  uint32_t D.40971;
  int D.40964;
  switch_rtp_flag_t D.40961;
  switch_rtp_flag_t D.40960;
  int D.40959;
  switch_rtp_flag_t D.40955;
  switch_rtp_flag_t D.40954;
  int D.40953;
  int D.40949;
  int D.40946;
  const char * D.40945;
  int D.40942;
  uint8_t D.40939;
  const char D.40936;
  int D.40929;
  const char * D.40928;
  switch_status_t D.40925;
  uint32_t max_drift.10;
  uint32_t D.40923;
  uint32_t D.40922;
  uint32_t maxqlen.9;
  uint32_t qlen.8;
  long int D.40913;
  int D.40904;
  int D.40903;
  int D.40897;
  const unsigned char D.40896;
  char * D.40895;
  int D.40894;
  const unsigned char D.40893;
  const unsigned char * D.40892;
  _Bool D.40889;
  _Bool D.40888;
  int D.40887;
  const unsigned char D.40886;
  char * D.40885;
  int D.40884;
  const unsigned char D.40883;
  const unsigned char * D.40882;
  _Bool D.40879;
  _Bool D.40878;
  int D.40877;
  const unsigned char D.40876;
  char * D.40875;
  int D.40874;
  const unsigned char D.40873;
  const unsigned char * D.40872;
  _Bool D.40869;
  _Bool D.40868;
  _Bool D.40867;
  int D.40866;
  const unsigned char D.40865;
  char[4] * D.40864;
  int D.40863;
  const unsigned char D.40862;
  int D.39872;
  int iftmp.7;
  int D.39873;
  int D.40854;
  int D.40851;
  int D.40848;
  const char * D.40845;
  uint8_t D.40842;
  int D.40838;
  uint8_t D.40835;
  struct switch_rtp_t * D.40834;
  struct switch_rtp_t * D.40831;
  uint32_t D.40828;
  switch_core_session_message_types_t D.40827;
  switch_channel_state_t D.40826;
  int D.40824;
  struct switch_channel_t * D.40823;
  switch_status_t D.40820;

<bb 2>:
  status = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7477, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.40820 = 1;
  goto <bb 163>;

<bb 6>:
  D.40823 = session->channel;
  D.40824 = switch_channel_check_signal (D.40823, 1);
  if (D.40824 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

<bb 7>:
  D.40823 = session->channel;
  D.40826 = switch_channel_get_state (D.40823);
  if (D.40826 > 9)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.40820 = 1;
  goto <bb 163>;

<bb 9>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.40827 = msg->message_id;
  switch (D.40827) <default: <L211>, case 4: <L93>, case 5: <L126>, case 8: <L147>, case 9: <L150>, case 17: <L10>, case 19: <L88>, case 20: <L144>, case 24: <L65>, case 25: <L13>, case 32: <L19>, case 46: <L7>>

<L7>:
  D.40823 = session->channel;
  D.40828 = switch_channel_test_flag (D.40823, 82);
  if (D.40828 != 0)
    goto <bb 11>;
  else
    goto <bb 127> (<L211>);

<bb 11>:
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 122, 1);
  goto <bb 127> (<L211>);

<L10>:
  D.40831 = v_engine->rtp_session;
  if (D.40831 != 0B)
    goto <bb 13>;
  else
    goto <bb 127> (<L211>);

<bb 13>:
  D.40831 = v_engine->rtp_session;
  switch_rtp_video_refresh (D.40831);
  goto <bb 127> (<L211>);

<L13>:
  D.40834 = a_engine->rtp_session;
  D.40835 = switch_rtp_ready (D.40834);
  if (D.40835 != 0)
    goto <bb 15>;
  else
    goto <bb 127> (<L211>);

<bb 15>:
  D.40838 = msg->numeric_arg;
  if (D.40838 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_set_flag (D.40834, 19);
  goto <bb 127> (<L211>);

<bb 17>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_clear_flag (D.40834, 19);
  goto <bb 127> (<L211>);

<L19>:
  D.40834 = a_engine->rtp_session;
  D.40842 = switch_rtp_ready (D.40834);
  if (D.40842 != 0)
    goto <bb 19>;
  else
    goto <bb 127> (<L211>);

<bb 19>:
  len = 0;
  maxlen = 0;
  qlen = 0;
  maxqlen = 50;
  max_drift = 0;
  D.40845 = msg->string_arg;
  if (D.40845 != 0B)
    goto <bb 20>;
  else
    goto <bb 45>;

<bb 20>:
  D.40845 = msg->string_arg;
  D.40848 = strcasecmp (D.40845, "pause");
  if (D.40848 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 1);
  goto <bb 159> (end);

<bb 22>:
  D.40845 = msg->string_arg;
  D.40851 = strcasecmp (D.40845, "resume");
  if (D.40851 == 0)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 0);
  goto <bb 159> (end);

<bb 24>:
  D.40845 = msg->string_arg;
  D.40854 = strncasecmp (D.40845, "debug:", 6);
  if (D.40854 == 0)
    goto <bb 25>;
  else
    goto <bb 36>;

<bb 25>:
  D.40845 = msg->string_arg;
  s = D.40845 + 6;
  if (s != 0B)
    goto <bb 26>;
  else
    goto <bb 35>;

<bb 26>:
  __s2_len = 3;
  if (__s2_len <= 3)
    goto <bb 27>;
  else
    goto <bb 32>;

<bb 27>:
  __s1 = s;
  D.40862 = *__s1;
  D.40863 = (int) D.40862;
  D.40864 = "off";
  D.40865 = MEM[(const unsigned char *)D.40864];
  D.40866 = (int) D.40865;
  __result = D.40863 - D.40866;
  D.40867 = __s2_len != 0;
  D.40868 = __result == 0;
  D.40869 = D.40867 && D.40868;
  if (D.40869 != 0)
    goto <bb 28>;
  else
    goto <bb 31>;

<bb 28>:
  D.40872 = __s1 + 1;
  D.40873 = *D.40872;
  D.40874 = (int) D.40873;
  D.40875 = &"off"[1];
  D.40876 = MEM[(const unsigned char *)D.40875];
  D.40877 = (int) D.40876;
  __result = D.40874 - D.40877;
  D.40878 = __s2_len > 1;
  D.40868 = __result == 0;
  D.40879 = D.40878 && D.40868;
  if (D.40879 != 0)
    goto <bb 29>;
  else
    goto <bb 31>;

<bb 29>:
  D.40882 = __s1 + 2;
  D.40883 = *D.40882;
  D.40884 = (int) D.40883;
  D.40885 = &"off"[2];
  D.40886 = MEM[(const unsigned char *)D.40885];
  D.40887 = (int) D.40886;
  __result = D.40884 - D.40887;
  D.40888 = __s2_len > 2;
  D.40868 = __result == 0;
  D.40889 = D.40888 && D.40868;
  if (D.40889 != 0)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  D.40892 = __s1 + 3;
  D.40893 = *D.40892;
  D.40894 = (int) D.40893;
  D.40895 = &"off"[3];
  D.40896 = MEM[(const unsigned char *)D.40895];
  D.40897 = (int) D.40896;
  __result = D.40894 - D.40897;

<bb 31>:
  D.39872 = __result;
  iftmp.7 = D.39872;
  goto <bb 33>;

<bb 32>:
  iftmp.7 = __builtin_strcmp (s, "off");

<bb 33>:
  D.39873 = iftmp.7;
  if (D.39873 == 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  s = 0B;

<bb 35>:
  D.40834 = a_engine->rtp_session;
  status = switch_rtp_debug_jitter_buffer (D.40834, s);
  goto <bb 159> (end);

<bb 36>:
  D.40845 = msg->string_arg;
  len = atoi (D.40845);
  if (len != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

<bb 37>:
  D.40903 = a_engine->read_impl.microseconds_per_packet;
  D.40904 = D.40903 / 1000;
  qlen = len / D.40904;
  if (qlen <= 0)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  qlen = 3;

<bb 39>:
  if (qlen != 0)
    goto <bb 40>;
  else
    goto <bb 43>;

<bb 40>:
  D.40845 = msg->string_arg;
  p = __builtin_strchr (D.40845, 58);
  if (p != 0B)
    goto <bb 41>;
  else
    goto <bb 43>;

<bb 41>:
  p = p + 1;
  maxlen = atol (p);
  q = __builtin_strchr (p, 58);
  if (q != 0B)
    goto <bb 42>;
  else
    goto <bb 43>;

<bb 42>:
  q = q + 1;
  D.40913 = atol (q);
  max_drift = ABS_EXPR <D.40913>;

<bb 43>:
  if (maxlen != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

<bb 44>:
  D.40903 = a_engine->read_impl.microseconds_per_packet;
  D.40904 = D.40903 / 1000;
  maxqlen = maxlen / D.40904;

<bb 45>:
  if (qlen != 0)
    goto <bb 46>;
  else
    goto <bb 52>;

<bb 46>:
  if (maxqlen < qlen)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  maxqlen = qlen * 5;

<bb 48>:
  D.40834 = a_engine->rtp_session;
  qlen.8 = (uint32_t) qlen;
  maxqlen.9 = (uint32_t) maxqlen;
  D.40922 = a_engine->read_impl.samples_per_packet;
  D.40923 = a_engine->read_impl.samples_per_second;
  max_drift.10 = (uint32_t) max_drift;
  D.40925 = switch_rtp_activate_jitter_buffer (D.40834, qlen.8, maxqlen.9, D.40922, D.40923, max_drift.10);
  if (D.40925 == 0)
    goto <bb 49>;
  else
    goto <bb 51>;

<bb 49>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7577, session, 7, "Setting Jitterbuffer to %dms (%d frames) (%d max frames) (%d max drift)\n", len, qlen, maxqlen, max_drift);
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 57, 1);
  D.40823 = session->channel;
  D.40928 = switch_channel_get_variable_dup (D.40823, "rtp_jitter_buffer_plc", 1, -1);
  D.40929 = switch_false (D.40928);
  if (D.40929 == 0)
    goto <bb 50>;
  else
    goto <bb 127> (<L211>);

<bb 50>:
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 58, 1);
  goto <bb 127> (<L211>);

<bb 51>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7585, session, 4, "Error Setting Jitterbuffer to %dms (%d frames)\n", len, qlen);
  goto <bb 127> (<L211>);

<bb 52>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_deactivate_jitter_buffer (D.40834);
  goto <bb 127> (<L211>);

<L65>:
  rtp = a_engine->rtp_session;
  direction = msg->string_array_arg[0];
  if (direction != 0B)
    goto <bb 54>;
  else
    goto <bb 56>;

<bb 54>:
  D.40936 = *direction;
  if (D.40936 == 118)
    goto <bb 55>;
  else
    goto <bb 56>;

<bb 55>:
  direction = direction + 1;
  rtp = v_engine->rtp_session;

<bb 56>:
  D.40939 = switch_rtp_ready (rtp);
  if (D.40939 != 0)
    goto <bb 57>;
  else
    goto <bb 159> (end);

<bb 57>:
  D.40942 = _zstr (direction);
  if (D.40942 == 0)
    goto <bb 58>;
  else
    goto <bb 159> (end);

<bb 58>:
  D.40945 = msg->string_array_arg[1];
  D.40946 = _zstr (D.40945);
  if (D.40946 == 0)
    goto <bb 59>;
  else
    goto <bb 159> (end);

<bb 59>:
  flags = {};
  D.40949 = strcasecmp (direction, "both");
  both = D.40949 == 0;
  set = 0;
  if (both != 0)
    goto <bb 61>;
  else
    goto <bb 60>;

<bb 60>:
  D.40953 = strcasecmp (direction, "read");
  if (D.40953 == 0)
    goto <bb 61>;
  else
    goto <bb 62>;

<bb 61>:
  D.40954 = flags[28];
  D.40955 = D.40954 + 1;
  flags[28] = D.40955;
  set = set + 1;

<bb 62>:
  if (both != 0)
    goto <bb 64>;
  else
    goto <bb 63>;

<bb 63>:
  D.40959 = strcasecmp (direction, "write");
  if (D.40959 == 0)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  D.40960 = flags[29];
  D.40961 = D.40960 + 1;
  flags[29] = D.40961;
  set = set + 1;

<bb 65>:
  if (set != 0)
    goto <bb 66>;
  else
    goto <bb 69>;

<bb 66>:
  D.40945 = msg->string_array_arg[1];
  D.40964 = switch_true (D.40945);
  if (D.40964 != 0)
    goto <bb 67>;
  else
    goto <bb 68>;

<bb 67>:
  switch_rtp_set_flags (rtp, &flags);
  goto <bb 159> (end);

<bb 68>:
  switch_rtp_clear_flags (rtp, &flags);
  goto <bb 159> (end);

<bb 69>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7627, session, 3, "Invalid Options\n");
  goto <bb 159> (end);

<L88>:
  D.40834 = a_engine->rtp_session;
  if (D.40834 != 0B)
    goto <bb 71>;
  else
    goto <bb 159> (end);

<bb 71>:
  D.40834 = a_engine->rtp_session;
  D.40971 = switch_rtp_test_flag (D.40834, 15);
  if (D.40971 != 0)
    goto <bb 72>;
  else
    goto <bb 159> (end);

<bb 72>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7634, session, 4, "Pass 2833 mode may not work on a transcoded call.\n");
  goto <bb 159> (end);

<L93>:
  D.40834 = a_engine->rtp_session;
  D.40974 = switch_rtp_ready (D.40834);
  if (D.40974 != 0)
    goto <bb 74>;
  else
    goto <bb 159> (end);

<bb 74>:
  ok = 0;
  D.40823 = session->channel;
  val = switch_channel_get_variable_dup (D.40823, "rtp_jitter_buffer_during_bridge", 1, -1);
  if (val == 0B)
    goto <bb 76>;
  else
    goto <bb 75>;

<bb 75>:
  D.40980 = switch_false (val);
  if (D.40980 != 0)
    goto <bb 76>;
  else
    goto <bb 79>;

<bb 76>:
  D.40823 = session->channel;
  D.40981 = switch_channel_test_flag (D.40823, 57);
  if (D.40981 != 0)
    goto <bb 77>;
  else
    goto <bb 79>;

<bb 77>:
  D.40823 = session->channel;
  D.40984 = switch_channel_test_cap_partner (D.40823, 5);
  if (D.40984 != 0)
    goto <bb 78>;
  else
    goto <bb 79>;

<bb 78>:
  D.40823 = session->channel;
  D.40987 = switch_channel_get_name (D.40823);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7647, session, 7, "%s PAUSE Jitterbuffer\n", D.40987);
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 1);
  D.40988 = smh->flags;
  D.40989 = D.40988 | 4;
  smh->flags = D.40989;

<bb 79>:
  D.40823 = session->channel;
  D.40990 = switch_channel_test_flag (D.40823, 100);
  if (D.40990 != 0)
    goto <bb 80>;
  else
    goto <bb 82>;

<bb 80>:
  D.40823 = session->channel;
  D.40993 = switch_channel_test_flag_partner (D.40823, 36);
  if (D.40993 != 0)
    goto <bb 81>;
  else
    goto <bb 82>;

<bb 81>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_set_flag (D.40834, 15);
  D.40823 = session->channel;
  D.40996 = switch_channel_get_name (D.40823);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7656, session, 7, "%s activate passthru 2833 mode.\n", D.40996);

<bb 82>:
  D.40823 = session->channel;
  val = switch_channel_get_variable_dup (D.40823, "rtp_notimer_during_bridge", 1, -1);
  if (val != 0B)
    goto <bb 83>;
  else
    goto <bb 84>;

<bb 83>:
  ok = switch_true (val);
  goto <bb 85>;

<bb 84>:
  D.40823 = session->channel;
  D.41000 = switch_channel_test_flag (D.40823, 105);
  ok = (int) D.41000;

<bb 85>:
  if (ok != 0)
    goto <bb 86>;
  else
    goto <bb 88>;

<bb 86>:
  D.40834 = a_engine->rtp_session;
  D.41003 = switch_rtp_test_flag (D.40834, 3);
  if (D.41003 == 0)
    goto <bb 87>;
  else
    goto <bb 88>;

<bb 87>:
  ok = 0;

<bb 88>:
  if (ok != 0)
    goto <bb 89>;
  else
    goto <bb 90>;

<bb 89>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_clear_flag (D.40834, 3);
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 99, 1);

<bb 90>:
  if (ok != 0)
    goto <bb 91>;
  else
    goto <bb 93>;

<bb 91>:
  D.40823 = session->channel;
  D.41011 = switch_channel_test_flag (D.40823, 99);
  if (D.41011 != 0)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  ok = 0;
  goto <bb 96>;

<bb 93>:
  D.40823 = session->channel;
  val = switch_channel_get_variable_dup (D.40823, "rtp_autoflush_during_bridge", 1, -1);
  if (val != 0B)
    goto <bb 94>;
  else
    goto <bb 95>;

<bb 94>:
  ok = switch_true (val);
  goto <bb 96>;

<bb 95>:
  D.41016 = smh->media_flags[14];
  ok = (int) D.41016;

<bb 96>:
  if (ok != 0)
    goto <bb 97>;
  else
    goto <bb 98>;

<bb 97>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 1);
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 104, 1);
  goto <bb 159> (end);

<bb 98>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 0);
  goto <bb 159> (end);

<L126>:
  D.40834 = a_engine->rtp_session;
  D.41020 = switch_rtp_ready (D.40834);
  if (D.41020 != 0)
    goto <bb 100>;
  else
    goto <bb 159> (end);

<bb 100>:
  D.40988 = smh->flags;
  D.41023 = D.40988 & 4;
  if (D.41023 != 0)
    goto <bb 101>;
  else
    goto <bb 103>;

<bb 101>:
  D.40988 = smh->flags;
  D.41026 = D.40988 & 4294967291;
  smh->flags = D.41026;
  D.40823 = session->channel;
  D.41027 = switch_channel_test_flag (D.40823, 57);
  if (D.41027 != 0)
    goto <bb 102>;
  else
    goto <bb 103>;

<bb 102>:
  D.40823 = session->channel;
  D.41030 = switch_channel_get_name (D.40823);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7704, session, 7, "%s RESUME Jitterbuffer\n", D.41030);
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 0);

<bb 103>:
  D.40834 = a_engine->rtp_session;
  D.41031 = switch_rtp_test_flag (D.40834, 15);
  if (D.41031 != 0)
    goto <bb 104>;
  else
    goto <bb 105>;

<bb 104>:
  D.40823 = session->channel;
  D.41034 = switch_channel_get_name (D.40823);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7712, session, 7, "%s deactivate passthru 2833 mode.\n", D.41034);
  D.40834 = a_engine->rtp_session;
  switch_rtp_clear_flag (D.40834, 15);

<bb 105>:
  D.40823 = session->channel;
  D.41035 = switch_channel_test_flag (D.40823, 99);
  if (D.41035 != 0)
    goto <bb 106>;
  else
    goto <bb 110>;

<bb 106>:
  D.40834 = a_engine->rtp_session;
  D.41038 = switch_rtp_test_flag (D.40834, 12);
  if (D.41038 == 0)
    goto <bb 107>;
  else
    goto <bb 109>;

<bb 107>:
  D.40834 = a_engine->rtp_session;
  D.41041 = switch_rtp_test_flag (D.40834, 19);
  if (D.41041 == 0)
    goto <bb 108>;
  else
    goto <bb 109>;

<bb 108>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_set_flag (D.40834, 3);

<bb 109>:
  D.40823 = session->channel;
  switch_channel_clear_flag (D.40823, 99);

<bb 110>:
  D.40823 = session->channel;
  D.41044 = switch_channel_test_flag (D.40823, 104);
  if (D.41044 != 0)
    goto <bb 111>;
  else
    goto <bb 112>;

<bb 111>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 2);
  D.40823 = session->channel;
  switch_channel_clear_flag (D.40823, 104);
  goto <bb 159> (end);

<bb 112>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 0);
  goto <bb 159> (end);

<L144>:
  D.40834 = a_engine->rtp_session;
  D.41048 = switch_rtp_ready (D.40834);
  if (D.41048 != 0)
    goto <bb 114>;
  else
    goto <bb 159> (end);

<bb 114>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 0);
  goto <bb 159> (end);

<L147>:
  D.41051 = session->track_duration;
  if (D.41051 != 0)
    goto <bb 116>;
  else
    goto <bb 127> (<L211>);

<bb 116>:
  D.41051 = session->track_duration;
  switch_core_session_enable_heartbeat (session, D.41051);
  goto <bb 127> (<L211>);

<L150>:
  ip = 0B;
  port = 0B;
  D.40823 = session->channel;
  switch_channel_set_flag_value (D.40823, 15, 1);
  a_engine->codec_negotiated = 0;
  v_engine->codec_negotiated = 0;
  switch_core_media_set_local_sdp (session, 0B, 0);
  D.40823 = session->channel;
  D.41054 = switch_channel_get_variable_dup (D.40823, "bypass_keep_codec", 1, -1);
  D.41055 = switch_true (D.41054);
  if (D.41055 != 0)
    goto <bb 118>;
  else
    goto <bb 119>;

<bb 118>:
  D.40823 = session->channel;
  D.40823 = session->channel;
  D.41058 = switch_channel_get_variable_dup (D.40823, "ep_codec_string", 1, -1);
  switch_channel_set_variable_var_check (D.40823, "absolute_codec_string", D.41058, 1);

<bb 119>:
  D.40823 = session->channel;
  uuid = switch_channel_get_partner_uuid (D.40823);
  if (uuid != 0B)
    goto <bb 120>;
  else
    goto <bb 123>;

<bb 120>:
  other_session = switch_core_session_perform_locate (uuid, "src/switch_core_media.c", &__func__, 7768);
  if (other_session != 0B)
    goto <bb 121>;
  else
    goto <bb 123>;

<bb 121>:
  other_channel = switch_core_session_get_channel (other_session);
  ip = switch_channel_get_variable_dup (other_channel, "remote_media_ip", 1, -1);
  port = switch_channel_get_variable_dup (other_channel, "remote_media_port", 1, -1);
  switch_core_session_rwunlock (other_session);
  D.41063 = ip != 0B;
  D.41064 = port != 0B;
  D.41065 = D.41063 && D.41064;
  if (D.41065 != 0)
    goto <bb 122>;
  else
    goto <bb 123>;

<bb 122>:
  switch_core_media_prepare_codecs (session, 1);
  clear_pmaps (a_engine);
  clear_pmaps (v_engine);
  D.41068 = atoi (port);
  D.41069 = (short unsigned int) D.41068;
  switch_core_media_gen_local_sdp (session, 0, ip, D.41069, 0B, 1);

<bb 123>:
  D.41070 = smh->mparams;
  D.41071 = D.41070->local_sdp_str;
  if (D.41071 == 0B)
    goto <bb 124>;
  else
    goto <bb 125>;

<bb 124>:
  switch_core_media_absorb_sdp (session);

<bb 125>:
  D.41051 = session->track_duration;
  if (D.41051 != 0)
    goto <bb 126>;
  else
    goto <bb 127> (<L211>);

<bb 126>:
  D.41051 = session->track_duration;
  switch_core_session_enable_heartbeat (session, D.41051);

<L211>:
  D.41076 = smh->mutex;
  if (D.41076 != 0B)
    goto <bb 128>;
  else
    goto <bb 129>;

<bb 128>:
  D.41076 = smh->mutex;
  switch_mutex_lock (D.41076);

<bb 129>:
  D.40823 = session->channel;
  D.41081 = switch_channel_check_signal (D.40823, 1);
  if (D.41081 != 0)
    goto <bb 131>;
  else
    goto <bb 130>;

<bb 130>:
  D.40823 = session->channel;
  D.41083 = switch_channel_get_state (D.40823);
  if (D.41083 > 9)
    goto <bb 131>;
  else
    goto <bb 132>;

<bb 131>:
  status = 1;
  goto <bb 157> (end_lock);

<bb 132>:
  D.40827 = msg->message_id;
  switch (D.40827) <default: end_lock, case 30: <L198>, case 37: <L186>, case 40: <L170>>

<L170>:
  D.40845 = msg->string_arg;
  if (D.40845 != 0B)
    goto <bb 134>;
  else
    goto <bb 144>;

<bb 134>:
  D.40823 = session->channel;
  switch_channel_set_variable_var_check (D.40823, "absolute_codec_string", 0B, 1);
  D.40845 = msg->string_arg;
  D.41086 = *D.40845;
  if (D.41086 == 61)
    goto <bb 135>;
  else
    goto <bb 136>;

<bb 135>:
  D.40823 = session->channel;
  D.40845 = msg->string_arg;
  switch_channel_set_variable_var_check (D.40823, "codec_string", D.40845, 1);
  goto <bb 143>;

<bb 136>:
  D.40823 = session->channel;
  D.41091 = v_engine->cur_payload_map;
  D.41092 = D.41091->rm_encoding;
  if (D.41092 != 0B)
    goto <bb 137>;
  else
    goto <bb 138>;

<bb 137>:
  D.41091 = v_engine->cur_payload_map;
  iftmp.11 = D.41091->rm_encoding;
  goto <bb 139>;

<bb 138>:
  iftmp.11 = "";

<bb 139>:
  D.41091 = v_engine->cur_payload_map;
  D.41092 = D.41091->rm_encoding;
  if (D.41092 != 0B)
    goto <bb 140>;
  else
    goto <bb 141>;

<bb 140>:
  iftmp.12 = ",";
  goto <bb 142>;

<bb 141>:
  iftmp.12 = "";

<bb 142>:
  D.41100 = a_engine->cur_payload_map;
  D.41101 = D.41100->rm_encoding;
  D.40845 = msg->string_arg;
  switch_channel_set_variable_printf (D.40823, "codec_string", "=%s%s%s,%s", iftmp.11, iftmp.12, D.41101, D.40845);

<bb 143>:
  a_engine->codec_negotiated = 0;
  v_engine->codec_negotiated = 0;
  D.40823 = session->channel;
  switch_channel_clear_flag (D.40823, 98);
  switch_core_media_prepare_codecs (session, 1);
  switch_core_media_check_video_codecs (session);
  switch_core_media_gen_local_sdp (session, 0, 0B, 0, 0B, 1);

<bb 144>:
  switch_media_handle_set_media_flag (smh, 7);
  D.40838 = msg->numeric_arg;
  if (D.40838 != 0)
    goto <bb 145>;
  else
    goto <bb 157> (end_lock);

<bb 145>:
  D.41104 = switch_core_session_perform_get_partner (session, &nsession, "src/switch_core_media.c", &__func__, 7835);
  if (D.41104 == 0)
    goto <bb 146>;
  else
    goto <bb 157> (end_lock);

<bb 146>:
  msg->numeric_arg = 0;
  nsession.13 = nsession;
  switch_core_session_perform_receive_message (nsession.13, msg, "src/switch_core_media.c", &__func__, 7837);
  nsession.13 = nsession;
  switch_core_session_rwunlock (nsession.13);
  goto <bb 157> (end_lock);

<L186>:
  D.40834 = a_engine->rtp_session;
  D.41108 = switch_rtp_ready (D.40834);
  if (D.41108 != 0)
    goto <bb 148>;
  else
    goto <bb 157> (end_lock);

<bb 148>:
  D.40838 = msg->numeric_arg;
  if (D.40838 != 0)
    goto <bb 149>;
  else
    goto <bb 152>;

<bb 149>:
  D.40823 = session->channel;
  D.41113 = switch_channel_test_flag (D.40823, 57);
  if (D.41113 != 0)
    goto <bb 150>;
  else
    goto <bb 151>;

<bb 150>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 1);
  D.40988 = smh->flags;
  D.40989 = D.40988 | 4;
  smh->flags = D.40989;

<bb 151>:
  D.40834 = a_engine->rtp_session;
  rtp_flush_read_buffer (D.40834, 2);
  goto <bb 157> (end_lock);

<bb 152>:
  D.40988 = smh->flags;
  D.41023 = D.40988 & 4;
  if (D.41023 != 0)
    goto <bb 153>;
  else
    goto <bb 157> (end_lock);

<bb 153>:
  D.40988 = smh->flags;
  D.41026 = D.40988 & 4294967291;
  smh->flags = D.41026;
  D.40823 = session->channel;
  D.41119 = switch_channel_test_flag (D.40823, 57);
  if (D.41119 != 0)
    goto <bb 154>;
  else
    goto <bb 157> (end_lock);

<bb 154>:
  D.40834 = a_engine->rtp_session;
  switch_rtp_pause_jitter_buffer (D.40834, 0);
  goto <bb 157> (end_lock);

<L198>:
  D.40823 = session->channel;
  t38_options = switch_channel_get_private (D.40823, "t38_options");
  if (t38_options != 0B)
    goto <bb 156>;
  else
    goto <bb 157> (end_lock);

<bb 156>:
  switch_core_media_start_udptl (session, t38_options);

end_lock:
  D.41076 = smh->mutex;
  if (D.41076 != 0B)
    goto <bb 158>;
  else
    goto <bb 159> (end);

<bb 158>:
  D.41076 = smh->mutex;
  switch_mutex_unlock (D.41076);

end:
  D.40823 = session->channel;
  D.41128 = switch_channel_check_signal (D.40823, 1);
  if (D.41128 != 0)
    goto <bb 161>;
  else
    goto <bb 160>;

<bb 160>:
  D.40823 = session->channel;
  D.41130 = switch_channel_get_state (D.40823);
  if (D.41130 > 9)
    goto <bb 161>;
  else
    goto <bb 162>;

<bb 161>:
  status = 1;

<bb 162>:
  D.40820 = status;

<bb 163>:
  return D.40820;

}



;; Function atol (atol)

Scope blocks:

{ Scope block #0 

}
Merging blocks 2 and 3
atol (const char * __nptr)
{
  long int D.41133;

<bb 2>:
  D.41133 = strtol (__nptr, 0B, 10);
  return D.41133;

}



;; Function switch_false (switch_false)

Scope blocks:

{ Scope block #0 

}
Merging blocks 14 and 15
switch_false (const char * expr)
{
  int D.41157;
  switch_bool_t D.41155;
  int D.41153;
  int D.41151;
  int D.41149;
  int D.41147;
  int D.41145;
  int D.41143;
  int D.41141;
  int iftmp.14;
  int D.41135;

<bb 2>:
  if (expr != 0B)
    goto <bb 3>;
  else
    goto <bb 13>;

<bb 3>:
  D.41141 = strcasecmp (expr, "no");
  if (D.41141 == 0)
    goto <bb 12>;
  else
    goto <bb 4>;

<bb 4>:
  D.41143 = strcasecmp (expr, "off");
  if (D.41143 == 0)
    goto <bb 12>;
  else
    goto <bb 5>;

<bb 5>:
  D.41145 = strcasecmp (expr, "false");
  if (D.41145 == 0)
    goto <bb 12>;
  else
    goto <bb 6>;

<bb 6>:
  D.41147 = strcasecmp (expr, "f");
  if (D.41147 == 0)
    goto <bb 12>;
  else
    goto <bb 7>;

<bb 7>:
  D.41149 = strcasecmp (expr, "disabled");
  if (D.41149 == 0)
    goto <bb 12>;
  else
    goto <bb 8>;

<bb 8>:
  D.41151 = strcasecmp (expr, "inactive");
  if (D.41151 == 0)
    goto <bb 12>;
  else
    goto <bb 9>;

<bb 9>:
  D.41153 = strcasecmp (expr, "disallow");
  if (D.41153 == 0)
    goto <bb 12>;
  else
    goto <bb 10>;

<bb 10>:
  D.41155 = switch_is_number (expr);
  if (D.41155 != 0)
    goto <bb 11>;
  else
    goto <bb 13>;

<bb 11>:
  D.41157 = atoi (expr);
  if (D.41157 == 0)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  iftmp.14 = 1;
  goto <bb 14>;

<bb 13>:
  iftmp.14 = 0;

<bb 14>:
  D.41135 = iftmp.14;
  return D.41135;

}



;; Function clear_pmaps (clear_pmaps)

Scope blocks:

{ Scope block #0 
  struct payload_map_t * pmap; (unused)

}
clear_pmaps (struct switch_rtp_engine_t * engine)
{
  struct payload_map_t * pmap;
  uint8_t D.41160;

<bb 2>:
  pmap = engine->payload_map;
  goto <bb 4>;

<bb 3>:
  pmap->negotiated = 0;
  pmap->current = 0;
  pmap = pmap->next;

<bb 4>:
  if (pmap != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.41160 = pmap->allocated;
  if (D.41160 != 0)
    goto <bb 3>;
  else
    goto <bb 6>;

<bb 6>:
  return;

}



;; Function switch_core_media_start_udptl (switch_core_media_start_udptl)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_start_udptl"; (unused)
  static const char __func__[30] = "switch_core_media_start_udptl"; (unused)

  { Scope block #0 
    char * remote_host; (unused)
    switch_port_t remote_port; (unused)
    const char * err; (unused)
    const char * val; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       24 (fallthru)
<bb 5>:
goto <bb 24>;


Removing basic block 8
;; basic block 8, loop depth 0, count 0
;; prev block 7, next block 9
;; pred:      
;; succ:       24 (fallthru)
<bb 8>:
goto <bb 24>;


switch_core_media_start_udptl (struct switch_core_session_t * session, struct switch_t38_options_t * t38_options)
{
  size_t __s2_len;
  size_t __s1_len;
  const char * val;
  const char * err;
  switch_port_t remote_port;
  char * remote_host;
  static const char __func__[30] = "switch_core_media_start_udptl";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_start_udptl";
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  int D.41204;
  uint32_t D.41200;
  int32_t D.41197;
  const char * err.15;
  switch_status_t D.41190;
  int D.41189;
  int D.39841;
  uint16_t D.41184;
  _Bool D.41181;
  _Bool D.41180;
  _Bool D.41179;
  const char * D.41178;
  uint8_t D.41172;
  struct switch_rtp_t * D.41171;
  switch_channel_state_t D.41170;
  int D.41168;
  struct switch_channel_t * D.41167;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7419, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 22>;
  else
    goto <bb 5>;

<bb 5>:
  D.41167 = session->channel;
  D.41168 = switch_channel_check_signal (D.41167, 1);
  if (D.41168 != 0)
    goto <bb 22>;
  else
    goto <bb 6>;

<bb 6>:
  D.41167 = session->channel;
  D.41170 = switch_channel_get_state (D.41167);
  if (D.41170 > 9)
    goto <bb 22>;
  else
    goto <bb 7>;

<bb 7>:
  a_engine = &smh->engines;
  D.41171 = a_engine->rtp_session;
  D.41172 = switch_rtp_ready (D.41171);
  if (D.41172 != 0)
    goto <bb 8>;
  else
    goto <bb 22>;

<bb 8>:
  D.41171 = a_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.41171);
  D.41171 = a_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.41171);
  D.41167 = session->channel;
  switch_channel_clear_flag (D.41167, 99);
  D.41171 = a_engine->rtp_session;
  switch_rtp_udptl_mode (D.41171);
  if (t38_options == 0B)
    goto <bb 10>;
  else
    goto <bb 9>;

<bb 9>:
  D.41178 = t38_options->remote_ip;
  if (D.41178 == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7441, session, 7, "No remote address\n");
  goto <bb 22>;

<bb 11>:
  D.41179 = remote_host != 0B;
  D.41180 = remote_port != 0;
  D.41181 = D.41179 && D.41180;
  if (D.41181 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

<bb 12>:
  D.41184 = t38_options->remote_port;
  if (D.41184 == remote_port)
    goto <bb 13>;
  else
    goto <bb 15>;

<bb 13>:
  D.41178 = t38_options->remote_ip;
  D.39841 = __builtin_strcmp (remote_host, D.41178);
  if (D.39841 == 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.41178 = t38_options->remote_ip;
  D.41184 = t38_options->remote_port;
  D.41189 = (int) D.41184;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7446, session, 7, "Remote address:port [%s:%d] has not changed.\n", D.41178, D.41189);
  goto <bb 22>;

<bb 15>:
  D.41171 = a_engine->rtp_session;
  D.41178 = t38_options->remote_ip;
  D.41184 = t38_options->remote_port;
  D.41190 = switch_rtp_set_remote_address (D.41171, D.41178, D.41184, 0, 1, &err);
  if (D.41190 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  err.15 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7453, session, 3, "IMAGE UDPTL REPORTS ERROR: [%s]\n", err.15);
  goto <bb 22>;

<bb 17>:
  D.41178 = t38_options->remote_ip;
  D.41184 = t38_options->remote_port;
  D.41189 = (int) D.41184;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7455, session, 7, "IMAGE UDPTL CHANGING DEST TO: [%s:%d]\n", D.41178, D.41189);
  D.41197 = switch_media_handle_test_media_flag (smh, 10);
  if (D.41197 == 0)
    goto <bb 18>;
  else
    goto <bb 22>;

<bb 18>:
  D.41167 = session->channel;
  D.41200 = switch_channel_test_flag (D.41167, 106);
  if (D.41200 == 0)
    goto <bb 19>;
  else
    goto <bb 22>;

<bb 19>:
  D.41167 = session->channel;
  val = switch_channel_get_variable_dup (D.41167, "disable_udptl_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 21>;
  else
    goto <bb 20>;

<bb 20>:
  D.41204 = switch_true (val);
  if (D.41204 == 0)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  D.41171 = a_engine->rtp_session;
  switch_rtp_set_flag (D.41171, 7);

<bb 22>:
  return;

}



;; Function switch_core_media_patch_sdp (switch_core_media_patch_sdp)

Scope blocks:

{ Scope block #0 
  switch_size_t len; (unused)
  char * p; (unused)
  char * q; (unused)
  char * pe; (unused)
  char * qe; (unused)
  int has_video; (unused)
  int has_audio; (unused)
  int has_ip; (unused)
  char port_buf[25]; (unused)
  char vport_buf[25]; (unused)
  char * new_sdp; (unused)
  int bad; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_patch_sdp"; (unused)
  static const char __func__[28] = "switch_core_media_patch_sdp"; (unused)
  void end = <<< error >>>; (unused)

  { Scope block #0 
    char * oe; (unused)
    switch_size_t len; (unused)

    { Scope block #0 
      const char * family; (unused)
      char o_line[1024]; (unused)

    }

  }

  { Scope block #0 
    char * se; (unused)
    switch_size_t len; (unused)

    { Scope block #0 
      char s_line[1024]; (unused)

    }

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       119 (fallthru)
<bb 5>:
goto <bb 119>;


Removing basic block 7
;; basic block 7, loop depth 0, count 0
;; prev block 6, next block 8
;; pred:      
;; succ:       119 (fallthru)
<bb 7>:
goto <bb 119>;


Removing basic block 51
;; basic block 51, loop depth 0, count 0
;; prev block 50, next block 52
;; pred:      
;; succ:       95 (fallthru)
<bb 51>:
goto <bb 95>;


Removing basic block 57
;; basic block 57, loop depth 0, count 0
;; prev block 56, next block 58
;; pred:      
;; succ:       95 (fallthru)
<bb 57>:
goto <bb 95>;


Removing basic block 67
;; basic block 67, loop depth 0, count 0
;; prev block 66, next block 68
;; pred:      
;; succ:       71 (fallthru)
<bb 67>:
goto <bb 71>;


Removing basic block 87
;; basic block 87, loop depth 0, count 0
;; prev block 86, next block 88
;; pred:      
;; succ:       91 (fallthru)
<bb 87>:
goto <bb 91>;


Removing basic block 95
;; basic block 95, loop depth 0, count 0
;; prev block 94, next block 96
;; pred:      
;; succ:       101 (fallthru)
<bb 95>:
goto <bb 101>;


Removing basic block 112
;; basic block 112, loop depth 0, count 0
;; prev block 111, next block 113
;; pred:      
;; succ:       119 (fallthru)
<bb 112>:
goto <bb 119>;


switch_core_media_patch_sdp (struct switch_core_session_t * session)
{
  char s_line[1024];
  switch_size_t len;
  char * se;
  char o_line[1024];
  const char * family;
  switch_size_t len;
  char * oe;
  static const char __func__[28] = "switch_core_media_patch_sdp";
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_patch_sdp";
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  int bad;
  char * new_sdp;
  char vport_buf[25];
  char port_buf[25];
  int has_ip;
  int has_audio;
  int has_video;
  char * qe;
  char * pe;
  char * q;
  char * p;
  switch_size_t len;
  char * D.41397;
  char * D.41396;
  int D.41393;
  char * D.41392;
  switch_channel_state_t D.41391;
  int D.41389;
  size_t D.41367;
  size_t D.41366;
  uint8_t D.41359;
  struct switch_rtp_t * D.41358;
  int D.41355;
  int D.41354;
  switch_port_t D.41353;
  struct payload_map_t * D.41352;
  int D.41345;
  char D.41344;
  size_t D.41337;
  size_t D.41336;
  char D.41330;
  char * D.41329;
  int D.41328;
  int D.41326;
  unsigned int D.41321;
  size_t D.41320;
  size_t D.41319;
  const char * restrict D.41318;
  int D.41317;
  int se.20;
  int D.41309;
  unsigned int D.41307;
  size_t D.41306;
  size_t D.41305;
  char * D.41304;
  const char * restrict D.41303;
  uint32_t D.41302;
  uint32_t D.41299;
  unsigned int D.41298;
  unsigned int D.41297;
  unsigned int D.41296;
  time_t D.41295;
  uint32_t D.41292;
  char * D.41288;
  char * D.41287;
  char[4] * iftmp.19;
  int D.41285;
  int p.18;
  int oe.17;
  int D.41276;
  char D.41275;
  char D.41273;
  _Bool D.41270;
  _Bool D.41269;
  _Bool D.41268;
  char D.41267;
  char D.41266;
  char D.41264;
  size_t D.41260;
  size_t D.41259;
  char * D.41255;
  char * D.41254;
  char[3] * iftmp.16;
  int D.41251;
  unsigned int D.41243;
  size_t D.41242;
  int D.41241;
  char * D.41240;
  struct payload_map_t * D.41239;
  char * D.41238;
  switch_status_t D.41235;
  switch_port_t D.41234;
  int D.41232;
  char * D.41231;
  const char * D.41228;
  const char * D.41226;
  uint32_t D.41223;
  struct switch_channel_t * D.41222;
  unsigned int D.41217;
  switch_core_media_NDLB_t D.41216;
  size_t D.41215;
  int D.41212;
  char * D.41211;
  struct switch_core_media_params_t * D.41210;

<bb 2>:
  has_video = 0;
  has_audio = 0;
  has_ip = 0;
  port_buf = "";
  vport_buf = "";
  bad = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 7134, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 111>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  D.41212 = _zstr (D.41211);
  if (D.41212 != 0)
    goto <bb 111>;
  else
    goto <bb 6>;

<bb 6>:
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  D.41215 = strlen (D.41211);
  len = D.41215 * 2;
  D.41210 = smh->mparams;
  D.41216 = D.41210->ndlb;
  D.41217 = D.41216 & 32;
  if (D.41217 == 0)
    goto <bb 7>;
  else
    goto <bb 11>;

<bb 7>:
  D.41222 = session->channel;
  D.41223 = switch_channel_test_flag (D.41222, 1);
  if (D.41223 != 0)
    goto <bb 8>;
  else
    goto <bb 11>;

<bb 8>:
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  D.41226 = switch_stristr ("sendonly", D.41211);
  if (D.41226 != 0B)
    goto <bb 10>;
  else
    goto <bb 9>;

<bb 9>:
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  D.41228 = switch_stristr ("0.0.0.0", D.41211);
  if (D.41228 != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7152, session, 7, "Skip patch on hold SDP\n");
  goto <bb 111>;

<bb 11>:
  D.41231 = a_engine->local_sdp_ip;
  D.41232 = _zstr (D.41231);
  if (D.41232 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

<bb 12>:
  D.41234 = a_engine->local_sdp_port;
  if (D.41234 == 0)
    goto <bb 13>;
  else
    goto <bb 16>;

<bb 13>:
  D.41235 = switch_core_media_choose_port (session, 0, 1);
  if (D.41235 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.41222 = session->channel;
  D.41238 = switch_channel_get_name (D.41222);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7159, session, 3, "%s I/O Error\n", D.41238);
  goto <bb 111>;

<bb 15>:
  D.41239 = a_engine->cur_payload_map;
  D.41240 = switch_core_perform_session_strdup (session, "PROXY", "src/switch_core_media.c", &__func__, 7163);
  D.41239->iananame = D.41240;
  D.41239 = a_engine->cur_payload_map;
  D.41239->rm_rate = 8000;
  D.41239 = a_engine->cur_payload_map;
  D.41239->adv_rm_rate = 8000;
  D.41239 = a_engine->cur_payload_map;
  D.41239->codec_ms = 20;

<bb 16>:
  new_sdp = switch_core_perform_session_alloc (session, len, "src/switch_core_media.c", &__func__, 7169);
  D.41234 = a_engine->local_sdp_port;
  D.41241 = (int) D.41234;
  switch_snprintf (&port_buf, 25, "%u", D.41241);
  D.41210 = smh->mparams;
  p = D.41210->local_sdp_str;
  q = new_sdp;
  D.41242 = strlen (p);
  pe = p + D.41242;
  D.41243 = len + -1;
  qe = q + D.41243;
  goto <bb 102>;

<bb 17>:
  if (p >= pe)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  bad = 1;
  goto <bb 104> (end);

<bb 19>:
  if (q >= qe)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  bad = 2;
  goto <bb 104> (end);

<bb 21>:
  D.41231 = a_engine->local_sdp_ip;
  if (D.41231 != 0B)
    goto <bb 22>;
  else
    goto <bb 37>;

<bb 22>:
  D.41251 = strncmp ("c=IN IP", p, 7);
  if (D.41251 == 0)
    goto <bb 23>;
  else
    goto <bb 37>;

<bb 23>:
  __builtin_strncpy (q, p, 7);
  p = p + 7;
  q = q + 7;
  D.41254 = a_engine->adv_sdp_ip;
  D.41255 = __builtin_strchr (D.41254, 58);
  if (D.41255 != 0B)
    goto <bb 24>;
  else
    goto <bb 25>;

<bb 24>:
  iftmp.16 = "6 ";
  goto <bb 26>;

<bb 25>:
  iftmp.16 = "4 ";

<bb 26>:
  __builtin_memcpy (q, iftmp.16, 2);
  p = p + 2;
  q = q + 2;
  D.41254 = a_engine->adv_sdp_ip;
  D.41254 = a_engine->adv_sdp_ip;
  D.41259 = strlen (D.41254);
  __builtin_strncpy (q, D.41254, D.41259);
  D.41254 = a_engine->adv_sdp_ip;
  D.41260 = strlen (D.41254);
  q = q + D.41260;
  goto <bb 30>;

<bb 27>:
  if (p >= pe)
    goto <bb 28>;
  else
    goto <bb 29>;

<bb 28>:
  bad = 3;
  goto <bb 104> (end);

<bb 29>:
  p = p + 1;

<bb 30>:
  if (p != 0B)
    goto <bb 31>;
  else
    goto <bb 36>;

<bb 31>:
  D.41264 = *p;
  if (D.41264 != 0)
    goto <bb 32>;
  else
    goto <bb 36>;

<bb 32>:
  D.41266 = *p;
  D.41267 = D.41266 + 208;
  D.41268 = D.41267 <= 9;
  D.41269 = D.41266 == 46;
  D.41270 = D.41268 || D.41269;
  if (D.41270 != 0)
    goto <bb 27>;
  else
    goto <bb 33>;

<bb 33>:
  D.41264 = *p;
  if (D.41264 == 58)
    goto <bb 27>;
  else
    goto <bb 34>;

<bb 34>:
  D.41264 = *p;
  D.41273 = D.41264 + 191;
  if (D.41273 <= 5)
    goto <bb 27>;
  else
    goto <bb 35>;

<bb 35>:
  D.41264 = *p;
  D.41275 = D.41264 + 159;
  if (D.41275 <= 5)
    goto <bb 27>;
  else
    goto <bb 36>;

<bb 36>:
  has_ip = has_ip + 1;
  goto <bb 94>;

<bb 37>:
  D.41276 = strncmp ("o=", p, 2);
  if (D.41276 == 0)
    goto <bb 38>;
  else
    goto <bb 49>;

<bb 38>:
  oe = __builtin_strchr (p, 10);
  if (oe != 0B)
    goto <bb 39>;
  else
    goto <bb 94>;

<bb 39>:
  family = "IP4";
  o_line = "";
  if (oe >= pe)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  bad = 5;
  goto <bb 104> (end);

<bb 41>:
  oe.17 = (int) oe;
  p.18 = (int) p;
  D.41285 = oe.17 - p.18;
  len = (switch_size_t) D.41285;
  p = p + len;
  D.41210 = smh->mparams;
  D.41287 = D.41210->sipip;
  D.41288 = __builtin_strchr (D.41287, 58);
  if (D.41288 != 0B)
    goto <bb 42>;
  else
    goto <bb 43>;

<bb 42>:
  iftmp.19 = "IP6";
  goto <bb 44>;

<bb 43>:
  iftmp.19 = "IP4";

<bb 44>:
  family = iftmp.19;
  D.41292 = smh->owner_id;
  if (D.41292 == 0)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  D.41295 = switch_epoch_time_now (0B);
  D.41296 = (unsigned int) D.41295;
  D.41297 = D.41296 * 31821;
  D.41298 = D.41297 + 13849;
  smh->owner_id = D.41298;

<bb 46>:
  D.41299 = smh->session_id;
  if (D.41299 == 0)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  D.41292 = smh->owner_id;
  smh->session_id = D.41292;

<bb 48>:
  D.41299 = smh->session_id;
  D.41302 = D.41299 + 1;
  smh->session_id = D.41302;
  D.41303 = (const char * restrict) &"o=%s %010u %010u IN %s %s\n"[0];
  D.41210 = smh->mparams;
  D.41304 = D.41210->sdp_username;
  D.41292 = smh->owner_id;
  D.41299 = smh->session_id;
  D.41210 = smh->mparams;
  D.41287 = D.41210->sipip;
  snprintf (&o_line, 1024, D.41303, D.41304, D.41292, D.41299, family, D.41287);
  D.41305 = strlen (&o_line);
  __builtin_strncpy (q, &o_line, D.41305);
  D.41306 = strlen (&o_line);
  D.41307 = D.41306 + -1;
  q = q + D.41307;
  goto <bb 94>;

<bb 49>:
  D.41309 = strncmp ("s=", p, 2);
  if (D.41309 == 0)
    goto <bb 50>;
  else
    goto <bb 54>;

<bb 50>:
  se = __builtin_strchr (p, 10);
  if (se != 0B)
    goto <bb 51>;
  else
    goto <bb 94>;

<bb 51>:
  s_line = "";
  if (se >= pe)
    goto <bb 52>;
  else
    goto <bb 53>;

<bb 52>:
  bad = 5;
  goto <bb 104> (end);

<bb 53>:
  se.20 = (int) se;
  p.18 = (int) p;
  D.41317 = se.20 - p.18;
  len = (switch_size_t) D.41317;
  p = p + len;
  D.41318 = (const char * restrict) &"s=%s\n"[0];
  D.41210 = smh->mparams;
  D.41304 = D.41210->sdp_username;
  snprintf (&s_line, 1024, D.41318, D.41304);
  D.41319 = strlen (&s_line);
  __builtin_strncpy (q, &s_line, D.41319);
  D.41320 = strlen (&s_line);
  D.41321 = D.41320 + -1;
  q = q + D.41321;
  goto <bb 94>;

<bb 54>:
  D.41326 = strncmp ("m=audio ", p, 8);
  if (D.41326 == 0)
    goto <bb 56>;
  else
    goto <bb 55>;

<bb 55>:
  D.41328 = strncmp ("m=image ", p, 8);
  if (D.41328 == 0)
    goto <bb 56>;
  else
    goto <bb 70>;

<bb 56>:
  D.41329 = p + 8;
  D.41330 = *D.41329;
  if (D.41330 != 48)
    goto <bb 57>;
  else
    goto <bb 70>;

<bb 57>:
  __builtin_strncpy (q, p, 8);
  p = p + 8;
  if (p >= pe)
    goto <bb 58>;
  else
    goto <bb 59>;

<bb 58>:
  bad = 4;
  goto <bb 104> (end);

<bb 59>:
  q = q + 8;
  if (q >= qe)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  bad = 5;
  goto <bb 104> (end);

<bb 61>:
  D.41336 = strlen (&port_buf);
  __builtin_strncpy (q, &port_buf, D.41336);
  D.41337 = strlen (&port_buf);
  q = q + D.41337;
  if (q >= qe)
    goto <bb 62>;
  else
    goto <bb 66>;

<bb 62>:
  bad = 6;
  goto <bb 104> (end);

<bb 63>:
  if (p >= pe)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  bad = 7;
  goto <bb 104> (end);

<bb 65>:
  p = p + 1;

<bb 66>:
  if (p != 0B)
    goto <bb 67>;
  else
    goto <bb 69>;

<bb 67>:
  D.41264 = *p;
  if (D.41264 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

<bb 68>:
  D.41264 = *p;
  D.41344 = D.41264 + 208;
  if (D.41344 <= 9)
    goto <bb 63>;
  else
    goto <bb 69>;

<bb 69>:
  has_audio = has_audio + 1;
  goto <bb 94>;

<bb 70>:
  D.41345 = strncmp ("m=video ", p, 8);
  if (D.41345 == 0)
    goto <bb 71>;
  else
    goto <bb 94>;

<bb 71>:
  D.41329 = p + 8;
  D.41330 = *D.41329;
  if (D.41330 != 48)
    goto <bb 72>;
  else
    goto <bb 94>;

<bb 72>:
  if (has_video == 0)
    goto <bb 73>;
  else
    goto <bb 76>;

<bb 73>:
  switch_core_media_choose_port (session, 1, 1);
  D.41352 = v_engine->cur_payload_map;
  D.41352->rm_encoding = "PROXY-VID";
  D.41352 = v_engine->cur_payload_map;
  D.41352->rm_rate = 90000;
  D.41352 = v_engine->cur_payload_map;
  D.41352->adv_rm_rate = 90000;
  D.41352 = v_engine->cur_payload_map;
  D.41352->codec_ms = 0;
  D.41353 = v_engine->adv_sdp_port;
  D.41354 = (int) D.41353;
  switch_snprintf (&vport_buf, 25, "%u", D.41354);
  D.41222 = session->channel;
  D.41355 = switch_channel_test_ready (D.41222, 1, 1);
  if (D.41355 != 0)
    goto <bb 74>;
  else
    goto <bb 76>;

<bb 74>:
  D.41358 = v_engine->rtp_session;
  D.41359 = switch_rtp_ready (D.41358);
  if (D.41359 == 0)
    goto <bb 75>;
  else
    goto <bb 76>;

<bb 75>:
  D.41222 = session->channel;
  switch_channel_set_flag_value (D.41222, 98, 1);
  D.41222 = session->channel;
  switch_channel_set_flag_value (D.41222, 103, 1);
  switch_core_media_activate_rtp (session);

<bb 76>:
  __builtin_strncpy (q, p, 8);
  p = p + 8;
  if (p >= pe)
    goto <bb 77>;
  else
    goto <bb 78>;

<bb 77>:
  bad = 8;
  goto <bb 104> (end);

<bb 78>:
  q = q + 8;
  if (q >= qe)
    goto <bb 79>;
  else
    goto <bb 80>;

<bb 79>:
  bad = 9;
  goto <bb 104> (end);

<bb 80>:
  D.41366 = strlen (&vport_buf);
  __builtin_strncpy (q, &vport_buf, D.41366);
  D.41367 = strlen (&vport_buf);
  q = q + D.41367;
  if (q >= qe)
    goto <bb 81>;
  else
    goto <bb 85>;

<bb 81>:
  bad = 10;
  goto <bb 104> (end);

<bb 82>:
  if (p >= pe)
    goto <bb 83>;
  else
    goto <bb 84>;

<bb 83>:
  bad = 11;
  goto <bb 104> (end);

<bb 84>:
  p = p + 1;

<bb 85>:
  if (p != 0B)
    goto <bb 86>;
  else
    goto <bb 88>;

<bb 86>:
  D.41264 = *p;
  if (D.41264 != 0)
    goto <bb 87>;
  else
    goto <bb 88>;

<bb 87>:
  D.41264 = *p;
  D.41344 = D.41264 + 208;
  if (D.41344 <= 9)
    goto <bb 82>;
  else
    goto <bb 88>;

<bb 88>:
  has_video = has_video + 1;
  goto <bb 94>;

<bb 89>:
  if (p >= pe)
    goto <bb 90>;
  else
    goto <bb 91>;

<bb 90>:
  bad = 12;
  goto <bb 104> (end);

<bb 91>:
  if (q >= qe)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  bad = 13;
  goto <bb 104> (end);

<bb 93>:
  D.41264 = *p;
  *q = D.41264;
  q = q + 1;
  p = p + 1;

<bb 94>:
  if (p != 0B)
    goto <bb 95>;
  else
    goto <bb 97>;

<bb 95>:
  D.41264 = *p;
  if (D.41264 != 0)
    goto <bb 96>;
  else
    goto <bb 97>;

<bb 96>:
  D.41264 = *p;
  if (D.41264 != 10)
    goto <bb 89>;
  else
    goto <bb 97>;

<bb 97>:
  if (p >= pe)
    goto <bb 98>;
  else
    goto <bb 99>;

<bb 98>:
  bad = 14;
  goto <bb 104> (end);

<bb 99>:
  if (q >= qe)
    goto <bb 100>;
  else
    goto <bb 101>;

<bb 100>:
  bad = 15;
  goto <bb 104> (end);

<bb 101>:
  D.41264 = *p;
  *q = D.41264;
  q = q + 1;
  p = p + 1;

<bb 102>:
  if (p != 0B)
    goto <bb 103>;
  else
    goto <bb 104> (end);

<bb 103>:
  D.41264 = *p;
  if (D.41264 != 0)
    goto <bb 17>;
  else
    goto <bb 104> (end);

end:
  if (bad != 0)
    goto <bb 111>;
  else
    goto <bb 105>;

<bb 105>:
  D.41222 = session->channel;
  D.41389 = switch_channel_check_signal (D.41222, 1);
  if (D.41389 != 0)
    goto <bb 107>;
  else
    goto <bb 106>;

<bb 106>:
  D.41222 = session->channel;
  D.41391 = switch_channel_get_state (D.41222);
  if (D.41391 > 9)
    goto <bb 107>;
  else
    goto <bb 108>;

<bb 107>:
  D.41222 = session->channel;
  D.41392 = switch_channel_get_name (D.41222);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7394, session, 7, "%s too late.\n", D.41392);
  goto <bb 111>;

<bb 108>:
  D.41393 = has_ip | has_audio;
  if (D.41393 == 0)
    goto <bb 109>;
  else
    goto <bb 110>;

<bb 109>:
  D.41222 = session->channel;
  D.41396 = switch_channel_get_name (D.41222);
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7400, session, 7, "%s SDP has no audio in it.\n%s\n", D.41396, D.41211);
  goto <bb 111>;

<bb 110>:
  D.41222 = session->channel;
  D.41397 = switch_channel_get_name (D.41222);
  D.41210 = smh->mparams;
  D.41211 = D.41210->local_sdp_str;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7406, session, 7, "%s Patched SDP\n---\n%s\n+++\n%s\n", D.41397, D.41211, new_sdp);
  switch_core_media_set_local_sdp (session, new_sdp, 0);

<bb 111>:
  return;

}



;; Function switch_core_media_set_udptl_image_sdp (switch_core_media_set_udptl_image_sdp)

Scope blocks:

{ Scope block #0 
  char buf[2048]; (unused)
  char max_buf[128]; (unused)
  char max_data[128]; (unused)
  const char * ip; (unused)
  uint32_t port; (unused)
  const char * family; (unused)
  const char * username; (unused)
  const char * bit_removal_on; (unused)
  const char * bit_removal_off; (unused)
  const char * mmr_on; (unused)
  const char * mmr_off; (unused)
  const char * jbig_on; (unused)
  const char * jbig_off; (unused)
  const char * var; (unused)
  int broken_boolean; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_udptl_image_sdp"; (unused)
  static const char __func__[38] = "switch_core_media_set_udptl_image_sdp"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       43 (fallthru)
<bb 5>:
goto <bb 43>;


switch_core_media_set_udptl_image_sdp (struct switch_core_session_t * session, struct switch_t38_options_t * t38_options, int insist)
{
  static const char __func__[38] = "switch_core_media_set_udptl_image_sdp";
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_udptl_image_sdp";
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  int broken_boolean;
  const char * var;
  const char * jbig_off;
  const char * jbig_on;
  const char * mmr_off;
  const char * mmr_on;
  const char * bit_removal_off;
  const char * bit_removal_on;
  const char * username;
  const char * family;
  uint32_t port;
  const char * ip;
  char max_data[128];
  char max_buf[128];
  char buf[2048];
  char * D.41478;
  char * D.41477;
  unsigned int D.41476;
  size_t D.41475;
  char * D.41474;
  size_t D.41473;
  const char * D.41470;
  const char * D.41469;
  switch_bool_t D.41465;
  const char * iftmp.24;
  switch_bool_t D.41460;
  const char * iftmp.23;
  switch_bool_t D.41455;
  const char * iftmp.22;
  uint32_t D.41453;
  int D.41452;
  uint16_t D.41451;
  unsigned int D.41450;
  size_t D.41449;
  char * D.41448;
  size_t D.41447;
  uint32_t D.41442;
  uint32_t D.41439;
  char * D.41435;
  char[4] * iftmp.21;
  uint32_t D.41433;
  uint32_t D.41430;
  unsigned int D.41429;
  unsigned int D.41428;
  time_t D.41427;
  uint32_t D.41424;
  char * D.41423;
  switch_port_t D.41420;
  switch_port_t D.41417;
  char * D.41414;
  struct switch_channel_t * D.41407;
  struct switch_core_media_params_t * D.41406;
  uint16_t D.41405;

<bb 2>:
  buf = "";
  max_buf = "";
  max_data = "";
  family = "IP4";
  bit_removal_on = "a=T38FaxFillBitRemoval\n";
  bit_removal_off = "";
  mmr_on = "a=T38FaxTranscodingMMR\n";
  mmr_off = "";
  jbig_on = "a=T38FaxTranscodingJBIG\n";
  jbig_off = "";
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 6995, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 42>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  if (t38_options == 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  __assert_fail ("t38_options", "src/switch_core_media.c", 7004, &__PRETTY_FUNCTION__);

<bb 7>:
  ip = t38_options->local_ip;
  D.41405 = t38_options->local_port;
  port = (uint32_t) D.41405;
  D.41406 = smh->mparams;
  username = D.41406->sdp_username;
  D.41407 = session->channel;
  var = switch_channel_get_variable_dup (D.41407, "t38_broken_boolean", 1, -1);
  broken_boolean = switch_true (var);
  if (ip == 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

<bb 8>:
  ip = a_engine->adv_sdp_ip;
  if (ip == 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  ip = a_engine->proxy_sdp_ip;

<bb 10>:
  if (ip == 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.41407 = session->channel;
  D.41414 = switch_channel_get_name (D.41407);
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 7022, 0B, 2, "%s NO IP!\n", D.41414);
  goto <bb 42>;

<bb 12>:
  if (port == 0)
    goto <bb 13>;
  else
    goto <bb 15>;

<bb 13>:
  D.41417 = a_engine->adv_sdp_port;
  port = (uint32_t) D.41417;
  if (port == 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.41420 = a_engine->proxy_sdp_port;
  port = (uint32_t) D.41420;

<bb 15>:
  if (port == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.41407 = session->channel;
  D.41423 = switch_channel_get_name (D.41407);
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 7033, 0B, 2, "%s NO PORT!\n", D.41423);
  goto <bb 42>;

<bb 17>:
  D.41424 = smh->owner_id;
  if (D.41424 == 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.41427 = switch_epoch_time_now (0B);
  D.41428 = (unsigned int) D.41427;
  D.41429 = D.41428 - port;
  smh->owner_id = D.41429;

<bb 19>:
  D.41430 = smh->session_id;
  if (D.41430 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.41424 = smh->owner_id;
  smh->session_id = D.41424;

<bb 21>:
  D.41430 = smh->session_id;
  D.41433 = D.41430 + 1;
  smh->session_id = D.41433;
  D.41435 = __builtin_strchr (ip, 58);
  if (D.41435 != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  iftmp.21 = "IP6";
  goto <bb 24>;

<bb 23>:
  iftmp.21 = "IP4";

<bb 24>:
  family = iftmp.21;
  D.41424 = smh->owner_id;
  D.41430 = smh->session_id;
  switch_snprintf (&buf, 2048, "v=0\no=%s %010u %010u IN %s %s\ns=%s\nc=IN %s %s\nt=0 0\n", username, D.41424, D.41430, family, ip, username, family, ip);
  D.41439 = t38_options->T38FaxMaxBuffer;
  if (D.41439 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  D.41439 = t38_options->T38FaxMaxBuffer;
  switch_snprintf (&max_buf, 128, "a=T38FaxMaxBuffer:%d\n", D.41439);

<bb 26>:
  D.41442 = t38_options->T38FaxMaxDatagram;
  if (D.41442 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  D.41442 = t38_options->T38FaxMaxDatagram;
  switch_snprintf (&max_data, 128, "a=T38FaxMaxDatagram:%d\n", D.41442);

<bb 28>:
  if (broken_boolean != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  bit_removal_on = "a=T38FaxFillBitRemoval:1\n";
  bit_removal_off = "a=T38FaxFillBitRemoval:0\n";
  mmr_on = "a=T38FaxTranscodingMMR:1\n";
  mmr_off = "a=T38FaxTranscodingMMR:0\n";
  jbig_on = "a=T38FaxTranscodingJBIG:1\n";
  jbig_off = "a=T38FaxTranscodingJBIG:0\n";

<bb 30>:
  D.41447 = strlen (&buf);
  D.41448 = &buf + D.41447;
  D.41449 = strlen (&buf);
  D.41450 = 2048 - D.41449;
  D.41451 = t38_options->T38FaxVersion;
  D.41452 = (int) D.41451;
  D.41453 = t38_options->T38MaxBitRate;
  D.41455 = t38_options->T38FaxFillBitRemoval;
  if (D.41455 != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  iftmp.22 = bit_removal_on;
  goto <bb 33>;

<bb 32>:
  iftmp.22 = bit_removal_off;

<bb 33>:
  D.41460 = t38_options->T38FaxTranscodingMMR;
  if (D.41460 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  iftmp.23 = mmr_on;
  goto <bb 36>;

<bb 35>:
  iftmp.23 = mmr_off;

<bb 36>:
  D.41465 = t38_options->T38FaxTranscodingJBIG;
  if (D.41465 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  iftmp.24 = jbig_on;
  goto <bb 39>;

<bb 38>:
  iftmp.24 = jbig_off;

<bb 39>:
  D.41469 = t38_options->T38FaxRateManagement;
  D.41470 = t38_options->T38FaxUdpEC;
  switch_snprintf (D.41448, D.41450, "m=image %d udptl t38\na=T38FaxVersion:%d\na=T38MaxBitRate:%d\n%s%s%sa=T38FaxRateManagement:%s\n%s%sa=T38FaxUdpEC:%s\n", port, D.41452, D.41453, iftmp.22, iftmp.23, iftmp.24, D.41469, &max_buf, &max_data, D.41470);
  if (insist != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  D.41473 = strlen (&buf);
  D.41474 = &buf + D.41473;
  D.41475 = strlen (&buf);
  D.41476 = 2048 - D.41475;
  switch_snprintf (D.41474, D.41476, "m=audio 0 RTP/AVP 19\n");

<bb 41>:
  switch_core_media_set_local_sdp (session, &buf, 1);
  D.41407 = session->channel;
  D.41477 = switch_channel_get_name (D.41407);
  D.41406 = smh->mparams;
  D.41478 = D.41406->local_sdp_str;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 7113, session, 7, "%s image media sdp:\n%s\n", D.41477, D.41478);

<bb 42>:
  return;

}



;; Function switch_core_media_absorb_sdp (switch_core_media_absorb_sdp)

Scope blocks:

{ Scope block #0 
  const char * sdp_str; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_absorb_sdp"; (unused)
  static const char __func__[29] = "switch_core_media_absorb_sdp"; (unused)

  { Scope block #0 
    struct sdp_parser_t * parser; (unused)
    struct sdp_session_t * sdp; (unused)
    struct sdp_media_t * m; (unused)
    struct sdp_connection_t * connection; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       23 (fallthru)
<bb 5>:
goto <bb 23>;


switch_core_media_absorb_sdp (struct switch_core_session_t * session)
{
  struct sdp_connection_t * connection;
  struct sdp_media_t * m;
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  static const char __func__[29] = "switch_core_media_absorb_sdp";
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_absorb_sdp";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  const char * sdp_str;
  switch_port_t D.41509;
  char * D.41506;
  short unsigned int D.41505;
  char * D.41504;
  const char * D.41503;
  struct sdp_connection_t * D.41498;
  long unsigned int D.41497;
  sdp_media_e D.41495;
  int D.41488;
  size_t D.41487;
  struct switch_channel_t * D.41484;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 6930, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 22>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  D.41484 = session->channel;
  sdp_str = switch_channel_get_variable_dup (D.41484, "switch_m_sdp", 1, -1);
  if (sdp_str != 0B)
    goto <bb 6>;
  else
    goto <bb 22>;

<bb 6>:
  D.41487 = strlen (sdp_str);
  D.41488 = (int) D.41487;
  parser = sdp_parse (0B, sdp_str, D.41488, 0);
  if (parser != 0B)
    goto <bb 7>;
  else
    goto <bb 21>;

<bb 7>:
  sdp = sdp_session (parser);
  if (sdp != 0B)
    goto <bb 8>;
  else
    goto <bb 20>;

<bb 8>:
  m = sdp->sdp_media;
  goto <bb 19>;

<bb 9>:
  D.41495 = m->m_type;
  if (D.41495 != 2)
    goto <bb 11>;
  else
    goto <bb 10>;

<bb 10>:
  D.41497 = m->m_port;
  if (D.41497 == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  // predicted unlikely by continue predictor.
  goto <bb 18>;

<bb 12>:
  connection = sdp->sdp_connection;
  D.41498 = m->m_connections;
  if (D.41498 != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  connection = m->m_connections;

<bb 14>:
  if (connection != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.41503 = connection->c_address;
  D.41504 = switch_core_perform_session_strdup (session, D.41503, "src/switch_core_media.c", &__func__, 6957);
  a_engine->proxy_sdp_ip = D.41504;

<bb 16>:
  D.41497 = m->m_port;
  D.41505 = (short unsigned int) D.41497;
  a_engine->proxy_sdp_port = D.41505;
  D.41506 = a_engine->proxy_sdp_ip;
  if (D.41506 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.41509 = a_engine->proxy_sdp_port;
  if (D.41509 != 0)
    goto <bb 20>;
  else
    goto <bb 18>;

<bb 18>:
  m = m->m_next;

<bb 19>:
  if (m != 0B)
    goto <bb 9>;
  else
    goto <bb 20>;

<bb 20>:
  sdp_parser_free (parser);

<bb 21>:
  switch_core_media_set_local_sdp (session, sdp_str, 1);

<bb 22>:
  return;

}



;; Function switch_core_media_gen_local_sdp (switch_core_media_gen_local_sdp)

Scope blocks:

{ Scope block #0 
  char * buf; (unused)
  int ptime; (unused)
  uint32_t rate; (unused)
  uint32_t v_port; (unused)
  int use_cng; (unused)
  const char * val; (unused)
  const char * family; (unused)
  const char * pass_fmtp; (unused)
  const char * ov_fmtp; (unused)
  const char * append_audio; (unused)
  const char * append_video; (unused)
  char srbuf[128]; (unused)
  const char * var_val; (unused)
  const char * username; (unused)
  const char * fmtp_out; (unused)
  const char * fmtp_out_var; (unused)
  struct switch_event_t * map; (unused)
  struct switch_event_t * ptmap; (unused)
  const char * local_sdp_audio_zrtp_hash; (unused)
  const char * local_sdp_video_zrtp_hash; (unused)
  const char * tmp; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct ice_t * ice_out; (unused)
  int vp8; (unused)
  int red; (unused)
  struct payload_map_t * pmap; (unused)
  int is_outbound; (unused)
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_gen_local_sdp"; (unused)
  static const char __func__[32] = "switch_core_media_gen_local_sdp"; (unused)

  { Scope block #0 
    int i; (unused)

    { Scope block #0 
      struct switch_core_session_t * orig_session; (unused)

      { Scope block #0 
        const struct switch_codec_implementation_t * imp; (unused)
        switch_payload_t orig_pt; (unused)
        char * orig_fmtp; (unused)

      }

    }

  }

  { Scope block #0 
    char tmp1[11]; (unused)
    char tmp2[11]; (unused)
    uint32_t c1; (unused)
    uint32_t c2; (unused)
    uint32_t c3; (unused)
    uint32_t c4; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

  }

  { Scope block #0 
    int i; (unused)
    int cur_ptime; (unused)
    int this_ptime; (unused)
    int cng_type; (unused)
    const char * mult; (unused)

    { Scope block #0 
      char * bp; (unused)
      int both; (unused)

    }

    { Scope block #0 
      const struct switch_codec_implementation_t * imp; (unused)

      { Scope block #0 
        char * bp; (unused)
        int both; (unused)

      }

    }

  }

  { Scope block #0 
    int loops; (unused)

    { Scope block #0 
      struct payload_map_t * pmap; (unused)

    }

    { Scope block #0 
      int i; (unused)
      int already_did[128]; (unused)

      { Scope block #0 
        const struct switch_codec_implementation_t * imp; (unused)

      }

    }

    { Scope block #0 
      const char * of; (unused)
      struct payload_map_t * pmap; (unused)

    }

    { Scope block #0 
      int i; (unused)
      int already_did[128]; (unused)

      { Scope block #0 
        const struct switch_codec_implementation_t * imp; (unused)
        char * fmtp; (unused)
        uint32_t ianacode; (unused)
        int channels; (unused)

      }

    }

    { Scope block #0 
      char tmp1[11]; (unused)
      char tmp2[11]; (unused)
      uint32_t c1; (unused)
      uint32_t c2; (unused)
      uint32_t c3; (unused)
      uint32_t c4; (unused)
      const char * vbw; (unused)
      int bw; (unused)

      { Scope block #0 
        int v; (unused)

      }

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

      }

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

      }

    }

    { Scope block #0 
      int i; (unused)

      { Scope block #0 
        switch_rtp_crypto_key_type_t j; (unused)

      }

    }

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       416 (fallthru)
<bb 5>:
goto <bb 416>;


Removing basic block 58
;; basic block 58, loop depth 0, count 0
;; prev block 57, next block 59
;; pred:      
;; succ:       60 (fallthru)
<bb 58>:
goto <bb 60>;


Removing basic block 75
;; basic block 75, loop depth 0, count 0
;; prev block 74, next block 76
;; pred:      
;; succ:       416 (fallthru)
<bb 75>:
goto <bb 416>;


Removing basic block 82
;; basic block 82, loop depth 0, count 0
;; prev block 81, next block 83
;; pred:      
;; succ:       416 (fallthru)
<bb 82>:
goto <bb 416>;


Removing basic block 89
;; basic block 89, loop depth 0, count 0
;; prev block 88, next block 90
;; pred:      
;; succ:       416 (fallthru)
<bb 89>:
goto <bb 416>;


Removing basic block 200
;; basic block 200, loop depth 0, count 0
;; prev block 199, next block 201
;; pred:      
;; succ:       240 (fallthru)
<bb 200>:
goto <bb 240>;


Removing basic block 220
;; basic block 220, loop depth 0, count 0
;; prev block 219, next block 221
;; pred:      
;; succ:       240 (fallthru)
<bb 220>:
goto <bb 240>;


Removing basic block 268
;; basic block 268, loop depth 0, count 0
;; prev block 267, next block 269
;; pred:      
;; succ:       284 (fallthru)
<bb 268>:
goto <bb 284>;


Removing basic block 316
;; basic block 316, loop depth 0, count 0
;; prev block 315, next block 317
;; pred:      
;; succ:       352 (fallthru)
<bb 316>:
goto <bb 352>;


switch_core_media_gen_local_sdp (struct switch_core_session_t * session, switch_sdp_type_t sdp_type, const char * ip, switch_port_t port, const char * sr, int force)
{
  switch_rtp_crypto_key_type_t j;
  int i;
  size_t __s2_len;
  size_t __s1_len;
  size_t __s2_len;
  size_t __s1_len;
  int v;
  int bw;
  const char * vbw;
  uint32_t c4;
  uint32_t c3;
  uint32_t c2;
  uint32_t c1;
  char tmp2[11];
  char tmp1[11];
  int channels;
  uint32_t ianacode;
  char * fmtp;
  const struct switch_codec_implementation_t * imp;
  int already_did[128];
  int i;
  struct payload_map_t * pmap;
  const char * of;
  const struct switch_codec_implementation_t * imp;
  int already_did[128];
  int i;
  struct payload_map_t * pmap;
  int loops;
  int both;
  char * bp;
  const struct switch_codec_implementation_t * imp;
  int both;
  char * bp;
  const char * mult;
  int cng_type;
  int this_ptime;
  int cur_ptime;
  int i;
  size_t __s2_len;
  size_t __s1_len;
  size_t __s2_len;
  size_t __s1_len;
  uint32_t c4;
  uint32_t c3;
  uint32_t c2;
  uint32_t c1;
  char tmp2[11];
  char tmp1[11];
  char * orig_fmtp;
  switch_payload_t orig_pt;
  const struct switch_codec_implementation_t * imp;
  struct switch_core_session_t * orig_session;
  int i;
  static const char __func__[32] = "switch_core_media_gen_local_sdp";
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_gen_local_sdp";
  int is_outbound;
  struct payload_map_t * pmap;
  int red;
  int vp8;
  struct ice_t * ice_out;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  const char * tmp;
  const char * local_sdp_video_zrtp_hash;
  const char * local_sdp_audio_zrtp_hash;
  struct switch_event_t * ptmap;
  struct switch_event_t * map;
  const char * fmtp_out_var;
  const char * fmtp_out;
  const char * username;
  const char * var_val;
  char srbuf[128];
  const char * append_video;
  const char * append_audio;
  const char * ov_fmtp;
  const char * pass_fmtp;
  const char * family;
  const char * val;
  int use_cng;
  uint32_t v_port;
  uint32_t rate;
  int ptime;
  char * buf;
  struct switch_event_t * ptmap.39;
  uint32_t D.42507;
  uint32_t D.42505;
  size_t D.42504;
  size_t D.42503;
  char * D.42502;
  size_t D.42501;
  char * D.42498;
  size_t D.42497;
  size_t D.42496;
  char * D.42495;
  size_t D.42494;
  int D.42491;
  char * D.42490;
  switch_rtp_crypto_key_type_t D.42486;
  uint32_t D.42483;
  uint32_t D.42480;
  int D.42477;
  size_t D.42476;
  size_t D.42475;
  char * D.42474;
  size_t D.42473;
  switch_port_t D.42470;
  int D.39675;
  int D.42465;
  char * D.42464;
  int D.42461;
  int D.42460;
  int D.42459;
  size_t D.42458;
  size_t D.42457;
  char * D.42456;
  size_t D.42455;
  uint32_t D.42454;
  _Bool D.42452;
  _Bool D.42451;
  int D.42448;
  size_t D.42447;
  size_t D.42446;
  char * D.42445;
  size_t D.42444;
  int D.39666;
  int D.42437;
  int D.42434;
  char * D.42433;
  size_t D.42432;
  size_t D.42431;
  char * D.42430;
  size_t D.42429;
  size_t D.42428;
  size_t D.42427;
  char * D.42426;
  size_t D.42425;
  size_t D.42424;
  size_t D.42423;
  char * D.42422;
  size_t D.42421;
  size_t D.42420;
  size_t D.42419;
  char * D.42418;
  size_t D.42417;
  size_t D.42416;
  size_t D.42415;
  char * D.42414;
  size_t D.42413;
  size_t D.42412;
  size_t D.42411;
  char * D.42410;
  size_t D.42409;
  uint32_t D.42408;
  size_t D.42407;
  size_t D.42406;
  char * D.42405;
  size_t D.42404;
  size_t D.42403;
  size_t D.42402;
  char * D.42401;
  size_t D.42400;
  size_t D.42397;
  size_t D.42396;
  char * D.42395;
  size_t D.42394;
  uint32_t D.42391;
  size_t D.42388;
  size_t D.42387;
  char * D.42386;
  size_t D.42385;
  uint8_t D.42378;
  uint8_t D.42374;
  char * iftmp.38;
  uint8_t D.42369;
  char * iftmp.37;
  size_t D.42367;
  size_t D.42366;
  char * D.42365;
  size_t D.42364;
  short unsigned int D.42361;
  short unsigned int D.42360;
  uint32_t D.42359;
  size_t D.42358;
  size_t D.42357;
  char * D.42356;
  size_t D.42355;
  size_t D.42353;
  size_t D.42352;
  char * D.42351;
  size_t D.42350;
  size_t D.42349;
  size_t D.42348;
  char * D.42347;
  size_t D.42346;
  int8_t D.42343;
  char[192] * D.42340;
  size_t D.42339;
  size_t D.42338;
  char * D.42337;
  size_t D.42336;
  int D.42333;
  char * D.42332;
  uint32_t D.42329;
  uint32_t D.42328;
  size_t D.42324;
  size_t D.42323;
  char * D.42322;
  size_t D.42321;
  int D.42318;
  int D.42315;
  int D.42312;
  int D.42309;
  char * D.42306;
  int D.42300;
  size_t D.42299;
  size_t D.42298;
  char * D.42297;
  size_t D.42296;
  const uint32_t D.42294;
  size_t D.42293;
  size_t D.42292;
  char * D.42291;
  size_t D.42290;
  int D.42285;
  int D.42282;
  int D.42281;
  const uint8_t D.42280;
  char * const D.42279;
  int D.42274;
  uint32_t D.42269;
  switch_call_direction_t D.42266;
  const switch_codec_type_t D.42263;
  switch_payload_t D.42262;
  const char D.42255;
  unsigned int D.42253;
  size_t D.42252;
  const char D.42249;
  const char * iftmp.36;
  char * iftmp.35;
  size_t D.42246;
  size_t D.42245;
  char * D.42244;
  size_t D.42243;
  uint8_t D.42240;
  uint32_t D.42238;
  char * D.42237;
  int D.42236;
  size_t D.42235;
  size_t D.42234;
  char * D.42233;
  size_t D.42232;
  uint8_t D.42229;
  switch_payload_t D.42226;
  int32_t D.42223;
  size_t D.42222;
  size_t D.42221;
  char * D.42220;
  size_t D.42219;
  const char * D.42209;
  uint32_t D.42205;
  long unsigned int D.42204;
  int D.42203;
  size_t D.42202;
  size_t D.42201;
  char * D.42200;
  size_t D.42199;
  int D.42196;
  int D.42193;
  char * D.42192;
  size_t D.42189;
  size_t D.42188;
  char * D.42187;
  size_t D.42186;
  const int D.42185;
  size_t D.42182;
  size_t D.42181;
  char * D.42180;
  size_t D.42179;
  int D.42176;
  int D.42175;
  signed char D.42172;
  switch_payload_t D.42171;
  uint32_t D.42168;
  switch_call_direction_t D.42165;
  const switch_codec_type_t D.42162;
  uint8_t D.42158;
  int D.42156;
  size_t D.42155;
  size_t D.42154;
  char * D.42153;
  size_t D.42152;
  switch_payload_t D.42149;
  switch_payload_t D.42148;
  int32_t D.42145;
  int D.42144;
  switch_payload_t D.42143;
  struct payload_map_t * D.42142;
  size_t D.42141;
  size_t D.42140;
  char * D.42139;
  size_t D.42138;
  uint8_t D.42135;
  const char * D.42134;
  uint32_t D.42133;
  switch_call_direction_t D.42131;
  uint32_t D.42129;
  int iftmp.34;
  size_t D.42122;
  size_t D.42121;
  char * D.42120;
  size_t D.42119;
  short unsigned int D.42118;
  uint32_t D.42115;
  switch_port_t D.42112;
  uint32_t D.42109;
  switch_port_t D.42106;
  uint32_t D.42103;
  switch_call_direction_t D.42100;
  uint32_t D.42097;
  size_t D.42096;
  size_t D.42095;
  uint32_t D.42092;
  uint32_t D.42090;
  size_t D.42085;
  size_t D.42084;
  size_t D.42083;
  uint32_t D.42082;
  uint32_t D.42081;
  int D.42074;
  int D.42072;
  char * const D.42071;
  const int D.42068;
  const switch_codec_type_t D.42065;
  size_t D.42064;
  size_t D.42063;
  switch_rtp_crypto_mode_t D.42058;
  size_t D.42057;
  struct switch_event_t * map.33;
  uint32_t D.42055;
  uint32_t D.42054;
  uint32_t D.42048;
  uint32_t D.42046;
  int iftmp.32;
  int D.42042;
  uint32_t D.42039;
  int32_t D.42030;
  size_t D.42026;
  size_t D.42025;
  char * D.42024;
  size_t D.42023;
  uint32_t D.42020;
  int D.42017;
  char * D.42016;
  uint32_t D.42013;
  int D.42010;
  size_t D.42009;
  size_t D.42008;
  char * D.42007;
  size_t D.42006;
  int D.39607;
  int D.41999;
  int D.41996;
  int D.41995;
  int D.41994;
  size_t D.41993;
  size_t D.41992;
  char * D.41991;
  size_t D.41990;
  uint32_t D.41989;
  _Bool D.41987;
  _Bool D.41986;
  _Bool D.41985;
  int D.41982;
  size_t D.41981;
  size_t D.41980;
  char * D.41979;
  size_t D.41978;
  switch_port_t D.41975;
  int D.39598;
  int D.41970;
  int D.41967;
  char * D.41966;
  int D.41965;
  switch_port_t D.41964;
  char * D.41963;
  char * D.41962;
  size_t D.41961;
  size_t D.41960;
  char * D.41959;
  size_t D.41958;
  char * D.41957;
  size_t D.41956;
  size_t D.41955;
  char * D.41954;
  size_t D.41953;
  char * D.41952;
  size_t D.41951;
  size_t D.41950;
  char * D.41949;
  size_t D.41948;
  size_t D.41947;
  size_t D.41946;
  char * D.41945;
  size_t D.41944;
  size_t D.41943;
  size_t D.41942;
  char * D.41941;
  size_t D.41940;
  size_t D.41939;
  size_t D.41938;
  char * D.41937;
  size_t D.41936;
  char * D.41935;
  uint32_t D.41934;
  size_t D.41933;
  size_t D.41932;
  char * D.41931;
  size_t D.41930;
  uint8_t D.41927;
  int D.41926;
  size_t D.41925;
  size_t D.41924;
  char * D.41923;
  size_t D.41922;
  size_t D.41920;
  size_t D.41919;
  char * D.41918;
  size_t D.41917;
  size_t D.41916;
  size_t D.41915;
  char * D.41914;
  size_t D.41913;
  int8_t D.41910;
  char[192] * D.41907;
  size_t D.41906;
  size_t D.41905;
  char * D.41904;
  size_t D.41903;
  int D.41900;
  char * D.41899;
  size_t D.41898;
  size_t D.41897;
  char * D.41896;
  size_t D.41895;
  int D.41892;
  size_t D.41891;
  size_t D.41890;
  char * D.41889;
  size_t D.41888;
  size_t D.41885;
  size_t D.41884;
  char * D.41883;
  size_t D.41882;
  const char D.41876;
  unsigned int D.41874;
  size_t D.41873;
  const char D.41870;
  const char * iftmp.31;
  char * iftmp.30;
  size_t D.41867;
  size_t D.41866;
  char * D.41865;
  size_t D.41864;
  size_t D.41859;
  size_t D.41858;
  char * D.41857;
  size_t D.41856;
  size_t D.41852;
  size_t D.41851;
  char * D.41850;
  size_t D.41849;
  int32_t D.41846;
  size_t D.41845;
  size_t D.41844;
  char * D.41843;
  size_t D.41842;
  size_t D.41840;
  size_t D.41839;
  char * D.41838;
  size_t D.41837;
  uint32_t D.41834;
  uint32_t D.41831;
  int32_t D.41829;
  const int D.41825;
  _Bool D.41822;
  _Bool D.41821;
  _Bool D.41820;
  const struct switch_codec_implementation_t * D.41819;
  uint32_t D.41817;
  char * D.41816;
  size_t D.41815;
  size_t D.41814;
  char * D.41813;
  size_t D.41812;
  int32_t D.41807;
  size_t D.41806;
  size_t D.41805;
  char * D.41804;
  size_t D.41803;
  size_t D.41800;
  size_t D.41799;
  char * D.41798;
  size_t D.41797;
  int D.41795;
  switch_payload_t D.41794;
  size_t D.41793;
  size_t D.41792;
  char * D.41791;
  size_t D.41790;
  int D.41787;
  char * D.41786;
  int D.41783;
  size_t D.41782;
  size_t D.41781;
  char * D.41780;
  size_t D.41779;
  size_t D.41778;
  size_t D.41777;
  char * D.41776;
  size_t D.41775;
  int32_t D.41770;
  size_t D.41769;
  size_t D.41768;
  char * D.41767;
  size_t D.41766;
  uint32_t D.41763;
  int32_t D.41761;
  uint8_t D.41757;
  int D.41755;
  size_t D.41754;
  size_t D.41753;
  char * D.41752;
  size_t D.41751;
  switch_payload_t D.41748;
  struct switch_mutex_t * D.41747;
  int32_t D.41744;
  int D.41743;
  switch_payload_t D.41742;
  size_t D.41741;
  size_t D.41740;
  char * D.41739;
  size_t D.41738;
  const char * D.41737;
  switch_rtp_crypto_key_type_t D.41736;
  uint32_t D.41734;
  uint8_t D.41732;
  int iftmp.29;
  int D.41727;
  size_t D.41726;
  size_t D.41725;
  char * D.41724;
  size_t D.41723;
  uint8_t D.41720;
  char * D.41719;
  size_t D.41718;
  size_t D.41717;
  char * D.41716;
  size_t D.41715;
  uint32_t D.41712;
  char * D.41708;
  char[4] * iftmp.28;
  int D.41704;
  int D.41703;
  unsigned int D.41700;
  switch_core_media_NDLB_t D.41699;
  uint32_t D.41696;
  int D.41693;
  const char * D.41692;
  uint32_t D.41689;
  unsigned int D.41688;
  unsigned int D.41687;
  unsigned int D.41686;
  time_t D.41685;
  uint32_t D.41682;
  int D.41676;
  char * D.41673;
  char * D.41664;
  uint32_t D.41655;
  uint32_t D.41653;
  int D.41650;
  _Bool D.41647;
  _Bool D.41646;
  _Bool D.41645;
  int D.41642;
  uint32_t D.41634;
  int D.41633;
  const int D.41632;
  const uint32_t D.41631;
  uint32_t D.41630;
  unsigned char D.41629;
  char * D.41628;
  char * orig_fmtp.27;
  switch_payload_t orig_pt.26;
  switch_status_t D.41622;
  char * const D.41621;
  switch_media_type_t D.41620;
  const switch_codec_type_t D.41619;
  struct switch_core_session_t * orig_session.25;
  int D.41612;
  _Bool D.41609;
  _Bool D.41608;
  _Bool D.41607;
  switch_payload_t D.41606;
  int32_t D.41603;
  int D.41602;
  int D.41599;
  switch_payload_t D.41596;
  switch_core_media_dtmf_t D.41593;
  switch_payload_t D.41590;
  int D.41587;
  const switch_payload_t D.41586;
  const struct switch_codec_implementation_t * D.41585;
  uint32_t D.41581;
  int D.41578;
  int D.41577;
  int D.41575;
  int32_t D.41572;
  struct payload_map_t * D.41566;
  int D.41565;
  const char * D.41564;
  uint32_t D.41562;
  int D.41557;
  int D.41554;
  int D.41551;
  const char * D.41550;
  uint32_t D.41547;
  uint32_t D.41546;
  uint32_t D.41544;
  int D.41538;
  struct switch_channel_t * D.41535;
  struct switch_core_session_t * D.41534;
  int D.41531;
  const char * D.41530;
  char * D.41527;
  const char * D.41526;
  char * D.41523;
  struct switch_core_media_params_t * D.41522;
  int D.41519;
  const char * D.41518;
  switch_call_direction_t D.41513;
  struct switch_channel_t * D.41512;

<bb 2>:
  ptime = 0;
  rate = 0;
  use_cng = 1;
  D.41512 = session->channel;
  pass_fmtp = switch_channel_get_variable_dup (D.41512, "rtp_video_fmtp", 1, -1);
  D.41512 = session->channel;
  ov_fmtp = switch_channel_get_variable_dup (D.41512, "rtp_force_video_fmtp", 1, -1);
  D.41512 = session->channel;
  append_audio = switch_channel_get_variable_dup (D.41512, "rtp_append_audio_sdp", 1, -1);
  D.41512 = session->channel;
  append_video = switch_channel_get_variable_dup (D.41512, "rtp_append_video_sdp", 1, -1);
  srbuf = "";
  D.41512 = session->channel;
  fmtp_out_var = switch_channel_get_variable_dup (D.41512, "rtp_force_audio_fmtp", 1, -1);
  map = 0B;
  ptmap = 0B;
  local_sdp_audio_zrtp_hash = switch_core_media_get_zrtp_hash (session, 0, 1);
  local_sdp_video_zrtp_hash = switch_core_media_get_zrtp_hash (session, 1, 1);
  vp8 = 0;
  red = 0;
  D.41512 = session->channel;
  D.41513 = switch_channel_direction (D.41512);
  is_outbound = D.41513 == 1;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 6025, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 407>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.41512 = session->channel;
  D.41518 = switch_channel_get_variable_dup (D.41512, "rtcp_mux", 1, -1);
  D.41519 = switch_true (D.41518);
  if (D.41519 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  a_engine->rtcp_mux = 1;
  v_engine->rtcp_mux = 1;

<bb 7>:
  D.41522 = smh->mparams;
  D.41523 = D.41522->rtcp_audio_interval_msec;
  if (D.41523 == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.41522 = smh->mparams;
  D.41512 = session->channel;
  D.41526 = switch_channel_get_variable_dup (D.41512, "rtcp_audio_interval_msec", 1, -1);
  D.41522->rtcp_audio_interval_msec = D.41526;

<bb 9>:
  D.41522 = smh->mparams;
  D.41527 = D.41522->rtcp_video_interval_msec;
  if (D.41527 == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.41522 = smh->mparams;
  D.41512 = session->channel;
  D.41530 = switch_channel_get_variable_dup (D.41512, "rtcp_video_interval_msec", 1, -1);
  D.41522->rtcp_video_interval_msec = D.41530;

<bb 11>:
  D.41531 = dtls_ok (session);
  if (D.41531 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

<bb 12>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  tmp = switch_channel_get_variable_dup (D.41535, "webrtc_enable_dtls", 1, -1);
  if (tmp != 0B)
    goto <bb 13>;
  else
    goto <bb 15>;

<bb 13>:
  D.41538 = switch_false (tmp);
  if (D.41538 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  switch_channel_clear_flag (D.41535, 111);
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  switch_channel_clear_flag (D.41535, 109);

<bb 15>:
  if (is_outbound != 0)
    goto <bb 18>;
  else
    goto <bb 16>;

<bb 16>:
  D.41512 = session->channel;
  D.41544 = switch_channel_test_flag (D.41512, 84);
  if (D.41544 != 0)
    goto <bb 18>;
  else
    goto <bb 17>;

<bb 17>:
  D.41512 = session->channel;
  D.41546 = switch_channel_test_flag (D.41512, 112);
  if (D.41546 != 0)
    goto <bb 18>;
  else
    goto <bb 27>;

<bb 18>:
  D.41512 = session->channel;
  D.41547 = switch_channel_test_flag (D.41512, 106);
  if (D.41547 == 0)
    goto <bb 19>;
  else
    goto <bb 21>;

<bb 19>:
  D.41512 = session->channel;
  D.41550 = switch_channel_get_variable_dup (D.41512, "media_webrtc", 1, -1);
  D.41551 = switch_true (D.41550);
  if (D.41551 != 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.41512 = session->channel;
  switch_channel_set_flag_value (D.41512, 106, 1);
  D.41512 = session->channel;
  switch_channel_set_flag_value (D.41512, 108, 1);
  D.41522 = smh->mparams;
  D.41522->rtcp_audio_interval_msec = "5000";
  D.41522 = smh->mparams;
  D.41522->rtcp_video_interval_msec = "5000";

<bb 21>:
  D.41554 = switch_rtp_has_dtls ();
  if (D.41554 != 0)
    goto <bb 22>;
  else
    goto <bb 26>;

<bb 22>:
  D.41557 = dtls_ok (session);
  if (D.41557 != 0)
    goto <bb 23>;
  else
    goto <bb 26>;

<bb 23>:
  D.41512 = session->channel;
  D.41562 = switch_channel_test_flag (D.41512, 106);
  if (D.41562 != 0)
    goto <bb 25>;
  else
    goto <bb 24>;

<bb 24>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  D.41564 = switch_channel_get_variable_dup (D.41535, "rtp_use_dtls", 1, -1);
  D.41565 = switch_true (D.41564);
  if (D.41565 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  switch_channel_set_flag_value (D.41535, 109, 1);
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  switch_channel_set_flag_value (D.41535, 92, 1);
  generate_local_fingerprint (smh, 0);

<bb 26>:
  switch_core_session_parse_crypto_prefs (session);
  switch_core_session_check_outgoing_crypto (session);

<bb 27>:
  D.41566 = a_engine->cur_payload_map;
  fmtp_out = D.41566->fmtp_out;
  D.41522 = smh->mparams;
  username = D.41522->sdp_username;
  buf = calloc (1, 65536);
  if (buf == 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

<bb 28>:
  __assert_fail ("(buf = calloc(1, (65536)))", "src/switch_core_media.c", 6078, &__PRETTY_FUNCTION__);

<bb 29>:
  switch_core_media_check_dtmf_type (session);
  D.41572 = switch_media_handle_test_media_flag (smh, 9);
  if (D.41572 != 0)
    goto <bb 34>;
  else
    goto <bb 30>;

<bb 30>:
  D.41512 = session->channel;
  val = switch_channel_get_variable_dup (D.41512, "supress_cng", 1, -1);
  if (val != 0B)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  D.41575 = switch_true (val);
  if (D.41575 != 0)
    goto <bb 34>;
  else
    goto <bb 32>;

<bb 32>:
  D.41512 = session->channel;
  val = switch_channel_get_variable_dup (D.41512, "suppress_cng", 1, -1);
  if (val != 0B)
    goto <bb 33>;
  else
    goto <bb 35>;

<bb 33>:
  D.41577 = switch_true (val);
  if (D.41577 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  use_cng = 0;
  D.41522 = smh->mparams;
  D.41522->cng_pt = 0;

<bb 35>:
  D.41578 = smh->payload_space;
  if (D.41578 == 0)
    goto <bb 36>;
  else
    goto <bb 62>;

<bb 36>:
  D.41512 = session->channel;
  D.41581 = switch_channel_test_flag (D.41512, 106);
  if (D.41581 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  smh->payload_space = 102;
  goto <bb 39>;

<bb 38>:
  smh->payload_space = 98;

<bb 39>:
  i = 0;
  goto <bb 41>;

<bb 40>:
  D.41585 = smh->codecs[i];
  D.41586 = D.41585->ianacode;
  smh->ianacodes[i] = D.41586;
  i = i + 1;

<bb 41>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 > i)
    goto <bb 40>;
  else
    goto <bb 42>;

<bb 42>:
  if (sdp_type == 0)
    goto <bb 43>;
  else
    goto <bb 62>;

<bb 43>:
  orig_session = 0B;
  switch_core_session_perform_get_partner (session, &orig_session, "src/switch_core_media.c", &__func__, 6108);
  i = 0;
  goto <bb 59>;

<bb 44>:
  imp = smh->codecs[i];
  orig_pt = 0;
  orig_fmtp = 0B;
  D.41590 = smh->ianacodes[i];
  if (D.41590 > 64)
    goto <bb 45>;
  else
    goto <bb 58>;

<bb 45>:
  D.41522 = smh->mparams;
  D.41593 = D.41522->dtmf_type;
  if (D.41593 == 0)
    goto <bb 46>;
  else
    goto <bb 49>;

<bb 46>:
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  if (D.41596 > 95)
    goto <bb 47>;
  else
    goto <bb 49>;

<bb 47>:
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  D.41599 = (int) D.41596;
  D.41578 = smh->payload_space;
  if (D.41599 == D.41578)
    goto <bb 48>;
  else
    goto <bb 49>;

<bb 48>:
  D.41578 = smh->payload_space;
  D.41602 = D.41578 + 1;
  smh->payload_space = D.41602;

<bb 49>:
  D.41603 = switch_media_handle_test_media_flag (smh, 9);
  if (D.41603 == 0)
    goto <bb 50>;
  else
    goto <bb 53>;

<bb 50>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41607 = D.41606 != 0;
  D.41608 = use_cng != 0;
  D.41609 = D.41607 && D.41608;
  if (D.41609 != 0)
    goto <bb 51>;
  else
    goto <bb 53>;

<bb 51>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41612 = (int) D.41606;
  D.41578 = smh->payload_space;
  if (D.41612 == D.41578)
    goto <bb 52>;
  else
    goto <bb 53>;

<bb 52>:
  D.41578 = smh->payload_space;
  D.41602 = D.41578 + 1;
  smh->payload_space = D.41602;

<bb 53>:
  orig_session.25 = orig_session;
  if (orig_session.25 != 0B)
    goto <bb 54>;
  else
    goto <bb 57>;

<bb 54>:
  orig_session.25 = orig_session;
  D.41619 = imp->codec_type;
  D.41620 = D.41619 != 0;
  D.41621 = imp->iananame;
  D.41622 = switch_core_session_get_payload_code (orig_session.25, D.41620, D.41621, &orig_pt, 0B, &orig_fmtp);
  if (D.41622 == 0)
    goto <bb 55>;
  else
    goto <bb 57>;

<bb 55>:
  orig_pt.26 = orig_pt;
  smh->ianacodes[i] = orig_pt.26;
  orig_fmtp.27 = orig_fmtp;
  if (orig_fmtp.27 != 0B)
    goto <bb 56>;
  else
    goto <bb 58>;

<bb 56>:
  orig_fmtp.27 = orig_fmtp;
  D.41628 = switch_core_perform_session_strdup (session, orig_fmtp.27, "src/switch_core_media.c", &__func__, 6133);
  smh->fmtps[i] = D.41628;
  goto <bb 58>;

<bb 57>:
  D.41578 = smh->payload_space;
  D.41629 = (unsigned char) D.41578;
  smh->ianacodes[i] = D.41629;
  D.41602 = D.41578 + 1;
  smh->payload_space = D.41602;

<bb 58>:
  D.41619 = imp->codec_type;
  D.41620 = D.41619 != 0;
  D.41621 = imp->iananame;
  D.41590 = smh->ianacodes[i];
  D.41630 = (uint32_t) D.41590;
  D.41631 = imp->samples_per_second;
  D.41632 = imp->microseconds_per_packet;
  D.41633 = D.41632 / 1000;
  D.41634 = (uint32_t) D.41633;
  switch_core_media_add_payload_map (session, D.41620, D.41621, 0B, sdp_type, D.41630, D.41631, D.41634, 0);
  i = i + 1;

<bb 59>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 > i)
    goto <bb 44>;
  else
    goto <bb 60>;

<bb 60>:
  orig_session.25 = orig_session;
  if (orig_session.25 != 0B)
    goto <bb 61>;
  else
    goto <bb 62>;

<bb 61>:
  orig_session.25 = orig_session;
  switch_core_session_rwunlock (orig_session.25);

<bb 62>:
  if (fmtp_out_var != 0B)
    goto <bb 63>;
  else
    goto <bb 64>;

<bb 63>:
  fmtp_out = fmtp_out_var;

<bb 64>:
  D.41512 = session->channel;
  val = switch_channel_get_variable_dup (D.41512, "verbose_sdp", 1, -1);
  if (val == 0B)
    goto <bb 66>;
  else
    goto <bb 65>;

<bb 65>:
  D.41642 = switch_true (val);
  if (D.41642 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

<bb 66>:
  D.41512 = session->channel;
  switch_channel_set_flag_value (D.41512, 110, 1);

<bb 67>:
  D.41645 = force == 0;
  D.41646 = ip == 0B;
  D.41647 = D.41645 && D.41646;
  if (D.41647 != 0)
    goto <bb 68>;
  else
    goto <bb 73>;

<bb 68>:
  D.41650 = _zstr (sr);
  if (D.41650 != 0)
    goto <bb 69>;
  else
    goto <bb 73>;

<bb 69>:
  D.41512 = session->channel;
  D.41653 = switch_channel_test_flag (D.41512, 15);
  if (D.41653 != 0)
    goto <bb 71>;
  else
    goto <bb 70>;

<bb 70>:
  D.41512 = session->channel;
  D.41655 = switch_channel_test_flag (D.41512, 29);
  if (D.41655 != 0)
    goto <bb 71>;
  else
    goto <bb 73>;

<bb 71>:
  if (buf != 0B)
    goto <bb 72>;
  else
    goto <bb 407>;

<bb 72>:
  free (buf);
  buf = 0B;
  goto <bb 407>;

<bb 73>:
  if (ip == 0B)
    goto <bb 74>;
  else
    goto <bb 76>;

<bb 74>:
  ip = a_engine->adv_sdp_ip;
  if (ip == 0B)
    goto <bb 75>;
  else
    goto <bb 76>;

<bb 75>:
  ip = a_engine->proxy_sdp_ip;

<bb 76>:
  if (ip == 0B)
    goto <bb 77>;
  else
    goto <bb 79>;

<bb 77>:
  D.41512 = session->channel;
  D.41664 = switch_channel_get_name (D.41512);
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 6182, 0B, 2, "%s NO IP!\n", D.41664);
  if (buf != 0B)
    goto <bb 78>;
  else
    goto <bb 407>;

<bb 78>:
  free (buf);
  buf = 0B;
  goto <bb 407>;

<bb 79>:
  if (port == 0)
    goto <bb 80>;
  else
    goto <bb 82>;

<bb 80>:
  port = a_engine->adv_sdp_port;
  if (port == 0)
    goto <bb 81>;
  else
    goto <bb 82>;

<bb 81>:
  port = a_engine->proxy_sdp_port;

<bb 82>:
  if (port == 0)
    goto <bb 83>;
  else
    goto <bb 85>;

<bb 83>:
  D.41512 = session->channel;
  D.41673 = switch_channel_get_name (D.41512);
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 6194, 0B, 2, "%s NO PORT!\n", D.41673);
  if (buf != 0B)
    goto <bb 84>;
  else
    goto <bb 407>;

<bb 84>:
  free (buf);
  buf = 0B;
  goto <bb 407>;

<bb 85>:
  D.41676 = _zstr (sr);
  if (D.41676 != 0)
    goto <bb 86>;
  else
    goto <bb 89>;

<bb 86>:
  D.41512 = session->channel;
  var_val = switch_channel_get_variable_dup (D.41512, "media_audio_mode", 1, -1);
  if (var_val != 0B)
    goto <bb 87>;
  else
    goto <bb 88>;

<bb 87>:
  sr = var_val;
  goto <bb 89>;

<bb 88>:
  sr = "sendrecv";

<bb 89>:
  D.41682 = smh->owner_id;
  if (D.41682 == 0)
    goto <bb 90>;
  else
    goto <bb 91>;

<bb 90>:
  D.41685 = switch_epoch_time_now (0B);
  D.41686 = (unsigned int) D.41685;
  D.41687 = (unsigned int) port;
  D.41688 = D.41686 - D.41687;
  smh->owner_id = D.41688;

<bb 91>:
  D.41689 = smh->session_id;
  if (D.41689 == 0)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  D.41682 = smh->owner_id;
  smh->session_id = D.41682;

<bb 93>:
  D.41512 = session->channel;
  D.41692 = switch_channel_get_variable_dup (D.41512, "drop_dtmf", 0, -1);
  D.41693 = switch_true (D.41692);
  if (D.41693 != 0)
    goto <bb 94>;
  else
    goto <bb 95>;

<bb 94>:
  D.41512 = session->channel;
  switch_channel_set_flag_value (D.41512, 102, 1);

<bb 95>:
  D.41689 = smh->session_id;
  D.41696 = D.41689 + 1;
  smh->session_id = D.41696;
  D.41522 = smh->mparams;
  D.41699 = D.41522->ndlb;
  D.41700 = D.41699 & 16;
  if (D.41700 != 0)
    goto <bb 98>;
  else
    goto <bb 96>;

<bb 96>:
  D.41512 = session->channel;
  var_val = switch_channel_get_variable_dup (D.41512, "ndlb_sendrecv_in_session", 1, -1);
  if (var_val != 0B)
    goto <bb 97>;
  else
    goto <bb 101>;

<bb 97>:
  D.41703 = switch_true (var_val);
  if (D.41703 != 0)
    goto <bb 98>;
  else
    goto <bb 101>;

<bb 98>:
  D.41704 = _zstr (sr);
  if (D.41704 == 0)
    goto <bb 99>;
  else
    goto <bb 100>;

<bb 99>:
  switch_snprintf (&srbuf, 128, "a=%s\n", sr);

<bb 100>:
  sr = 0B;

<bb 101>:
  D.41708 = __builtin_strchr (ip, 58);
  if (D.41708 != 0B)
    goto <bb 102>;
  else
    goto <bb 103>;

<bb 102>:
  iftmp.28 = "IP6";
  goto <bb 104>;

<bb 103>:
  iftmp.28 = "IP4";

<bb 104>:
  family = iftmp.28;
  D.41682 = smh->owner_id;
  D.41689 = smh->session_id;
  switch_snprintf (buf, 65536, "v=0\no=%s %010u %010u IN %s %s\ns=%s\nc=IN %s %s\nt=0 0\n%s", username, D.41682, D.41689, family, ip, username, family, ip, &srbuf);
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  D.41712 = switch_channel_test_flag (D.41535, 108);
  if (D.41712 != 0)
    goto <bb 105>;
  else
    goto <bb 106>;

<bb 105>:
  gen_ice (session, 0, ip, port);
  D.41715 = strlen (buf);
  D.41716 = buf + D.41715;
  D.41717 = strlen (buf);
  D.41718 = 65536 - D.41717;
  D.41719 = smh->msid;
  switch_snprintf (D.41716, D.41718, "a=msid-semantic: WMS %s\n", D.41719);

<bb 106>:
  D.41720 = a_engine->codec_negotiated;
  if (D.41720 != 0)
    goto <bb 107>;
  else
    goto <bb 195>;

<bb 107>:
  D.41723 = strlen (buf);
  D.41724 = buf + D.41723;
  D.41725 = strlen (buf);
  D.41726 = 65536 - D.41725;
  D.41727 = (int) port;
  D.41732 = a_engine->no_crypto;
  if (D.41732 == 0)
    goto <bb 108>;
  else
    goto <bb 111>;

<bb 108>:
  D.41512 = session->channel;
  D.41734 = switch_channel_test_flag (D.41512, 109);
  if (D.41734 != 0)
    goto <bb 110>;
  else
    goto <bb 109>;

<bb 109>:
  D.41736 = a_engine->crypto_type;
  if (D.41736 != 9)
    goto <bb 110>;
  else
    goto <bb 111>;

<bb 110>:
  iftmp.29 = 1;
  goto <bb 112>;

<bb 111>:
  iftmp.29 = 0;

<bb 112>:
  D.41737 = get_media_profile_name (session, iftmp.29);
  switch_snprintf (D.41724, D.41726, "m=audio %d %s", D.41727, D.41737);
  D.41738 = strlen (buf);
  D.41739 = buf + D.41738;
  D.41740 = strlen (buf);
  D.41741 = 65536 - D.41740;
  D.41566 = a_engine->cur_payload_map;
  D.41742 = D.41566->pt;
  D.41743 = (int) D.41742;
  switch_snprintf (D.41739, D.41741, " %d", D.41743);
  D.41744 = switch_media_handle_test_media_flag (smh, 15);
  if (D.41744 != 0)
    goto <bb 113>;
  else
    goto <bb 120>;

<bb 113>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_lock (D.41747);
  pmap = a_engine->cur_payload_map;
  goto <bb 117>;

<bb 114>:
  D.41748 = pmap->pt;
  D.41566 = a_engine->cur_payload_map;
  D.41742 = D.41566->pt;
  if (D.41748 != D.41742)
    goto <bb 115>;
  else
    goto <bb 116>;

<bb 115>:
  D.41751 = strlen (buf);
  D.41752 = buf + D.41751;
  D.41753 = strlen (buf);
  D.41754 = 65536 - D.41753;
  D.41748 = pmap->pt;
  D.41755 = (int) D.41748;
  switch_snprintf (D.41752, D.41754, " %d", D.41755);

<bb 116>:
  pmap = pmap->next;

<bb 117>:
  if (pmap != 0B)
    goto <bb 118>;
  else
    goto <bb 119>;

<bb 118>:
  D.41757 = pmap->allocated;
  if (D.41757 != 0)
    goto <bb 114>;
  else
    goto <bb 119>;

<bb 119>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_unlock (D.41747);

<bb 120>:
  D.41522 = smh->mparams;
  D.41593 = D.41522->dtmf_type;
  if (D.41593 == 0)
    goto <bb 123>;
  else
    goto <bb 121>;

<bb 121>:
  D.41761 = switch_media_handle_test_media_flag (smh, 8);
  if (D.41761 != 0)
    goto <bb 123>;
  else
    goto <bb 122>;

<bb 122>:
  D.41512 = session->channel;
  D.41763 = switch_channel_test_flag (D.41512, 93);
  if (D.41763 != 0)
    goto <bb 123>;
  else
    goto <bb 125>;

<bb 123>:
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  if (D.41596 > 95)
    goto <bb 124>;
  else
    goto <bb 125>;

<bb 124>:
  D.41766 = strlen (buf);
  D.41767 = buf + D.41766;
  D.41768 = strlen (buf);
  D.41769 = 65536 - D.41768;
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  D.41599 = (int) D.41596;
  switch_snprintf (D.41767, D.41769, " %d", D.41599);

<bb 125>:
  D.41770 = switch_media_handle_test_media_flag (smh, 9);
  if (D.41770 == 0)
    goto <bb 126>;
  else
    goto <bb 128>;

<bb 126>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41607 = D.41606 != 0;
  D.41608 = use_cng != 0;
  D.41609 = D.41607 && D.41608;
  if (D.41609 != 0)
    goto <bb 127>;
  else
    goto <bb 128>;

<bb 127>:
  D.41775 = strlen (buf);
  D.41776 = buf + D.41775;
  D.41777 = strlen (buf);
  D.41778 = 65536 - D.41777;
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41612 = (int) D.41606;
  switch_snprintf (D.41776, D.41778, " %d", D.41612);

<bb 128>:
  D.41779 = strlen (buf);
  D.41780 = buf + D.41779;
  D.41781 = strlen (buf);
  D.41782 = 65536 - D.41781;
  switch_snprintf (D.41780, D.41782, "\n");
  D.41566 = a_engine->cur_payload_map;
  rate = D.41566->adv_rm_rate;
  D.41566 = a_engine->cur_payload_map;
  D.41783 = D.41566->adv_channels;
  if (D.41783 == 0)
    goto <bb 129>;
  else
    goto <bb 130>;

<bb 129>:
  D.41566 = a_engine->cur_payload_map;
  D.41566 = a_engine->cur_payload_map;
  D.41786 = D.41566->rm_encoding;
  D.41787 = get_channels (D.41786, 1);
  D.41566->adv_channels = D.41787;

<bb 130>:
  D.41566 = a_engine->cur_payload_map;
  D.41783 = D.41566->adv_channels;
  if (D.41783 > 1)
    goto <bb 131>;
  else
    goto <bb 132>;

<bb 131>:
  D.41790 = strlen (buf);
  D.41791 = buf + D.41790;
  D.41792 = strlen (buf);
  D.41793 = 65536 - D.41792;
  D.41566 = a_engine->cur_payload_map;
  D.41794 = D.41566->agreed_pt;
  D.41795 = (int) D.41794;
  D.41566 = a_engine->cur_payload_map;
  D.41786 = D.41566->rm_encoding;
  D.41566 = a_engine->cur_payload_map;
  D.41783 = D.41566->adv_channels;
  switch_snprintf (D.41791, D.41793, "a=rtpmap:%d %s/%d/%d\n", D.41795, D.41786, rate, D.41783);
  goto <bb 133>;

<bb 132>:
  D.41797 = strlen (buf);
  D.41798 = buf + D.41797;
  D.41799 = strlen (buf);
  D.41800 = 65536 - D.41799;
  D.41566 = a_engine->cur_payload_map;
  D.41794 = D.41566->agreed_pt;
  D.41795 = (int) D.41794;
  D.41566 = a_engine->cur_payload_map;
  D.41786 = D.41566->rm_encoding;
  switch_snprintf (D.41798, D.41800, "a=rtpmap:%d %s/%d\n", D.41795, D.41786, rate);

<bb 133>:
  if (fmtp_out != 0B)
    goto <bb 134>;
  else
    goto <bb 135>;

<bb 134>:
  D.41803 = strlen (buf);
  D.41804 = buf + D.41803;
  D.41805 = strlen (buf);
  D.41806 = 65536 - D.41805;
  D.41566 = a_engine->cur_payload_map;
  D.41794 = D.41566->agreed_pt;
  D.41795 = (int) D.41794;
  switch_snprintf (D.41804, D.41806, "a=fmtp:%d %s\n", D.41795, fmtp_out);

<bb 135>:
  D.41807 = switch_media_handle_test_media_flag (smh, 15);
  if (D.41807 != 0)
    goto <bb 136>;
  else
    goto <bb 143>;

<bb 136>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_lock (D.41747);
  pmap = a_engine->cur_payload_map;
  goto <bb 140>;

<bb 137>:
  D.41748 = pmap->pt;
  D.41566 = a_engine->cur_payload_map;
  D.41742 = D.41566->pt;
  if (D.41748 != D.41742)
    goto <bb 138>;
  else
    goto <bb 139>;

<bb 138>:
  D.41812 = strlen (buf);
  D.41813 = buf + D.41812;
  D.41814 = strlen (buf);
  D.41815 = 65536 - D.41814;
  D.41748 = pmap->pt;
  D.41755 = (int) D.41748;
  D.41816 = pmap->iananame;
  D.41817 = pmap->rate;
  switch_snprintf (D.41813, D.41815, "a=rtpmap:%d %s/%ld\n", D.41755, D.41816, D.41817);

<bb 139>:
  pmap = pmap->next;

<bb 140>:
  if (pmap != 0B)
    goto <bb 141>;
  else
    goto <bb 142>;

<bb 141>:
  D.41757 = pmap->allocated;
  if (D.41757 != 0)
    goto <bb 137>;
  else
    goto <bb 142>;

<bb 142>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_unlock (D.41747);

<bb 143>:
  D.41819 = a_engine->read_codec.implementation;
  D.41820 = D.41819 != 0B;
  D.41821 = ptime == 0;
  D.41822 = D.41820 && D.41821;
  if (D.41822 != 0)
    goto <bb 144>;
  else
    goto <bb 145>;

<bb 144>:
  D.41819 = a_engine->read_codec.implementation;
  D.41825 = D.41819->microseconds_per_packet;
  ptime = D.41825 / 1000;

<bb 145>:
  D.41522 = smh->mparams;
  D.41593 = D.41522->dtmf_type;
  if (D.41593 == 0)
    goto <bb 148>;
  else
    goto <bb 146>;

<bb 146>:
  D.41829 = switch_media_handle_test_media_flag (smh, 8);
  if (D.41829 != 0)
    goto <bb 148>;
  else
    goto <bb 147>;

<bb 147>:
  D.41512 = session->channel;
  D.41831 = switch_channel_test_flag (D.41512, 93);
  if (D.41831 != 0)
    goto <bb 148>;
  else
    goto <bb 152>;

<bb 148>:
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  if (D.41596 > 95)
    goto <bb 149>;
  else
    goto <bb 152>;

<bb 149>:
  D.41512 = session->channel;
  D.41834 = switch_channel_test_flag (D.41512, 106);
  if (D.41834 != 0)
    goto <bb 150>;
  else
    goto <bb 151>;

<bb 150>:
  D.41837 = strlen (buf);
  D.41838 = buf + D.41837;
  D.41839 = strlen (buf);
  D.41840 = 65536 - D.41839;
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  D.41599 = (int) D.41596;
  switch_snprintf (D.41838, D.41840, "a=rtpmap:%d telephone-event/8000\n", D.41599);
  goto <bb 152>;

<bb 151>:
  D.41842 = strlen (buf);
  D.41843 = buf + D.41842;
  D.41844 = strlen (buf);
  D.41845 = 65536 - D.41844;
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  D.41599 = (int) D.41596;
  D.41522 = smh->mparams;
  D.41596 = D.41522->te;
  D.41599 = (int) D.41596;
  switch_snprintf (D.41843, D.41845, "a=rtpmap:%d telephone-event/8000\na=fmtp:%d 0-16\n", D.41599, D.41599);

<bb 152>:
  D.41846 = switch_media_handle_test_media_flag (smh, 9);
  if (D.41846 != 0)
    goto <bb 153>;
  else
    goto <bb 154>;

<bb 153>:
  D.41849 = strlen (buf);
  D.41850 = buf + D.41849;
  D.41851 = strlen (buf);
  D.41852 = 65536 - D.41851;
  switch_snprintf (D.41850, D.41852, "a=silenceSupp:off - - - -\n");
  goto <bb 157>;

<bb 154>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41607 = D.41606 != 0;
  D.41608 = use_cng != 0;
  D.41609 = D.41607 && D.41608;
  if (D.41609 != 0)
    goto <bb 155>;
  else
    goto <bb 157>;

<bb 155>:
  D.41856 = strlen (buf);
  D.41857 = buf + D.41856;
  D.41858 = strlen (buf);
  D.41859 = 65536 - D.41858;
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41612 = (int) D.41606;
  switch_snprintf (D.41857, D.41859, "a=rtpmap:%d CN/8000\n", D.41612);
  D.41720 = a_engine->codec_negotiated;
  if (D.41720 == 0)
    goto <bb 156>;
  else
    goto <bb 157>;

<bb 156>:
  D.41522 = smh->mparams;
  D.41522->cng_pt = 0;

<bb 157>:
  if (append_audio != 0B)
    goto <bb 158>;
  else
    goto <bb 165>;

<bb 158>:
  D.41864 = strlen (buf);
  D.41865 = buf + D.41864;
  D.41866 = strlen (buf);
  D.41867 = 65536 - D.41866;
  D.41870 = *append_audio;
  if (D.41870 != 0)
    goto <bb 159>;
  else
    goto <bb 160>;

<bb 159>:
  D.41873 = strlen (append_audio);
  D.41874 = D.41873 + -1;
  iftmp.31 = append_audio + D.41874;
  goto <bb 161>;

<bb 160>:
  iftmp.31 = append_audio;

<bb 161>:
  D.41876 = *iftmp.31;
  if (D.41876 == 10)
    goto <bb 162>;
  else
    goto <bb 163>;

<bb 162>:
  iftmp.30 = "";
  goto <bb 164>;

<bb 163>:
  iftmp.30 = "\n";

<bb 164>:
  switch_snprintf (D.41865, D.41867, "%s%s", append_audio, iftmp.30);

<bb 165>:
  if (ptime != 0)
    goto <bb 166>;
  else
    goto <bb 167>;

<bb 166>:
  D.41882 = strlen (buf);
  D.41883 = buf + D.41882;
  D.41884 = strlen (buf);
  D.41885 = 65536 - D.41884;
  switch_snprintf (D.41883, D.41885, "a=ptime:%d\n", ptime);

<bb 167>:
  if (local_sdp_audio_zrtp_hash != 0B)
    goto <bb 168>;
  else
    goto <bb 169>;

<bb 168>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 6350, session, 7, "Adding audio a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
  D.41888 = strlen (buf);
  D.41889 = buf + D.41888;
  D.41890 = strlen (buf);
  D.41891 = 65536 - D.41890;
  switch_snprintf (D.41889, D.41891, "a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);

<bb 169>:
  D.41892 = _zstr (sr);
  if (D.41892 == 0)
    goto <bb 170>;
  else
    goto <bb 171>;

<bb 170>:
  D.41895 = strlen (buf);
  D.41896 = buf + D.41895;
  D.41897 = strlen (buf);
  D.41898 = 65536 - D.41897;
  switch_snprintf (D.41896, D.41898, "a=%s\n", sr);

<bb 171>:
  D.41899 = a_engine->local_dtls_fingerprint.type;
  D.41900 = _zstr (D.41899);
  if (D.41900 == 0)
    goto <bb 172>;
  else
    goto <bb 173>;

<bb 172>:
  D.41903 = strlen (buf);
  D.41904 = buf + D.41903;
  D.41905 = strlen (buf);
  D.41906 = 65536 - D.41905;
  D.41899 = a_engine->local_dtls_fingerprint.type;
  D.41907 = &a_engine->local_dtls_fingerprint.str;
  switch_snprintf (D.41904, D.41906, "a=fingerprint:%s %s\n", D.41899, D.41907);

<bb 173>:
  D.41522 = smh->mparams;
  D.41523 = D.41522->rtcp_audio_interval_msec;
  if (D.41523 != 0B)
    goto <bb 174>;
  else
    goto <bb 177>;

<bb 174>:
  D.41910 = a_engine->rtcp_mux;
  if (D.41910 > 0)
    goto <bb 175>;
  else
    goto <bb 176>;

<bb 175>:
  D.41913 = strlen (buf);
  D.41914 = buf + D.41913;
  D.41915 = strlen (buf);
  D.41916 = 65536 - D.41915;
  switch_snprintf (D.41914, D.41916, "a=rtcp-mux\n");
  D.41917 = strlen (buf);
  D.41918 = buf + D.41917;
  D.41919 = strlen (buf);
  D.41920 = 65536 - D.41919;
  D.41727 = (int) port;
  switch_snprintf (D.41918, D.41920, "a=rtcp:%d IN %s %s\n", D.41727, family, ip);
  goto <bb 177>;

<bb 176>:
  D.41922 = strlen (buf);
  D.41923 = buf + D.41922;
  D.41924 = strlen (buf);
  D.41925 = 65536 - D.41924;
  D.41727 = (int) port;
  D.41926 = D.41727 + 1;
  switch_snprintf (D.41923, D.41925, "a=rtcp:%d IN %s %s\n", D.41926, family, ip);

<bb 177>:
  D.41927 = a_engine->ice_out.cands[0][0].ready;
  if (D.41927 != 0)
    goto <bb 178>;
  else
    goto <bb 190>;

<bb 178>:
  tmp1 = "";
  tmp2 = "";
  c1 = 659136;
  c2 = 659134;
  c3 = 659126;
  c4 = 659124;
  tmp1[10] = 0;
  tmp2[10] = 0;
  switch_stun_random_string (&tmp1, 10, "0123456789");
  switch_stun_random_string (&tmp2, 10, "0123456789");
  ice_out = &a_engine->ice_out;
  D.41930 = strlen (buf);
  D.41931 = buf + D.41930;
  D.41932 = strlen (buf);
  D.41933 = 65536 - D.41932;
  D.41934 = a_engine->ssrc;
  D.41935 = smh->cname;
  switch_snprintf (D.41931, D.41933, "a=ssrc:%u cname:%s\n", D.41934, D.41935);
  D.41936 = strlen (buf);
  D.41937 = buf + D.41936;
  D.41938 = strlen (buf);
  D.41939 = 65536 - D.41938;
  D.41934 = a_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.41937, D.41939, "a=ssrc:%u msid:%s a0\n", D.41934, D.41719);
  D.41940 = strlen (buf);
  D.41941 = buf + D.41940;
  D.41942 = strlen (buf);
  D.41943 = 65536 - D.41942;
  D.41934 = a_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.41941, D.41943, "a=ssrc:%u mslabel:%s\n", D.41934, D.41719);
  D.41944 = strlen (buf);
  D.41945 = buf + D.41944;
  D.41946 = strlen (buf);
  D.41947 = 65536 - D.41946;
  D.41934 = a_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.41945, D.41947, "a=ssrc:%u label:%sa0\n", D.41934, D.41719);
  D.41948 = strlen (buf);
  D.41949 = buf + D.41948;
  D.41950 = strlen (buf);
  D.41951 = 65536 - D.41950;
  D.41952 = ice_out->ufrag;
  switch_snprintf (D.41949, D.41951, "a=ice-ufrag:%s\n", D.41952);
  D.41953 = strlen (buf);
  D.41954 = buf + D.41953;
  D.41955 = strlen (buf);
  D.41956 = 65536 - D.41955;
  D.41957 = ice_out->pwd;
  switch_snprintf (D.41954, D.41956, "a=ice-pwd:%s\n", D.41957);
  D.41958 = strlen (buf);
  D.41959 = buf + D.41958;
  D.41960 = strlen (buf);
  D.41961 = 65536 - D.41960;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  switch_snprintf (D.41959, D.41961, "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", &tmp1, D.41962, c1, D.41963, D.41965);
  D.41966 = a_engine->local_sdp_ip;
  D.41967 = _zstr (D.41966);
  if (D.41967 == 0)
    goto <bb 179>;
  else
    goto <bb 183>;

<bb 179>:
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41970 = _zstr (D.41963);
  if (D.41970 == 0)
    goto <bb 180>;
  else
    goto <bb 183>;

<bb 180>:
  D.41966 = a_engine->local_sdp_ip;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.39598 = __builtin_strcmp (D.41966, D.41963);
  if (D.39598 != 0)
    goto <bb 181>;
  else
    goto <bb 183>;

<bb 181>:
  D.41975 = a_engine->local_sdp_port;
  D.41964 = ice_out->cands[0][0].con_port;
  if (D.41975 != D.41964)
    goto <bb 182>;
  else
    goto <bb 183>;

<bb 182>:
  D.41978 = strlen (buf);
  D.41979 = buf + D.41978;
  D.41980 = strlen (buf);
  D.41981 = 65536 - D.41980;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.41966 = a_engine->local_sdp_ip;
  D.41975 = a_engine->local_sdp_port;
  D.41982 = (int) D.41975;
  switch_snprintf (D.41979, D.41981, "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", &tmp2, D.41962, c3, D.41963, D.41965, D.41966, D.41982);

<bb 183>:
  D.41910 = a_engine->rtcp_mux;
  D.41985 = D.41910 <= 0;
  D.41986 = is_outbound != 0;
  D.41987 = D.41985 || D.41986;
  if (D.41987 != 0)
    goto <bb 185>;
  else
    goto <bb 184>;

<bb 184>:
  D.41512 = session->channel;
  D.41989 = switch_channel_test_flag (D.41512, 84);
  if (D.41989 != 0)
    goto <bb 185>;
  else
    goto <bb 190>;

<bb 185>:
  D.41990 = strlen (buf);
  D.41991 = buf + D.41990;
  D.41992 = strlen (buf);
  D.41993 = 65536 - D.41992;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.41910 = a_engine->rtcp_mux;
  D.41994 = D.41910 <= 0;
  D.41995 = D.41965 + D.41994;
  switch_snprintf (D.41991, D.41993, "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", &tmp1, D.41962, c2, D.41963, D.41995);
  D.41966 = a_engine->local_sdp_ip;
  D.41996 = _zstr (D.41966);
  if (D.41996 == 0)
    goto <bb 186>;
  else
    goto <bb 190>;

<bb 186>:
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41999 = _zstr (D.41963);
  if (D.41999 == 0)
    goto <bb 187>;
  else
    goto <bb 190>;

<bb 187>:
  D.41966 = a_engine->local_sdp_ip;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.39607 = __builtin_strcmp (D.41966, D.41963);
  if (D.39607 != 0)
    goto <bb 188>;
  else
    goto <bb 190>;

<bb 188>:
  D.41975 = a_engine->local_sdp_port;
  D.41964 = ice_out->cands[0][0].con_port;
  if (D.41975 != D.41964)
    goto <bb 189>;
  else
    goto <bb 190>;

<bb 189>:
  D.42006 = strlen (buf);
  D.42007 = buf + D.42006;
  D.42008 = strlen (buf);
  D.42009 = 65536 - D.42008;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.41910 = a_engine->rtcp_mux;
  D.41994 = D.41910 <= 0;
  D.41995 = D.41965 + D.41994;
  D.41966 = a_engine->local_sdp_ip;
  D.41975 = a_engine->local_sdp_port;
  D.41982 = (int) D.41975;
  D.41910 = a_engine->rtcp_mux;
  D.41994 = D.41910 <= 0;
  D.42010 = D.41982 + D.41994;
  switch_snprintf (D.42007, D.42009, "a=candidate:%s 2 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", &tmp2, D.41962, c4, D.41963, D.41995, D.41966, D.42010);

<bb 190>:
  D.41736 = a_engine->crypto_type;
  if (D.41736 != 9)
    goto <bb 191>;
  else
    goto <bb 233>;

<bb 191>:
  D.41512 = session->channel;
  D.42013 = switch_channel_test_flag (D.41512, 109);
  if (D.42013 == 0)
    goto <bb 192>;
  else
    goto <bb 233>;

<bb 192>:
  D.41736 = a_engine->crypto_type;
  D.42016 = a_engine->ssec[D.41736].local_crypto_key;
  D.42017 = _zstr (D.42016);
  if (D.42017 == 0)
    goto <bb 193>;
  else
    goto <bb 233>;

<bb 193>:
  D.41512 = session->channel;
  D.42020 = switch_channel_test_flag (D.41512, 92);
  if (D.42020 != 0)
    goto <bb 194>;
  else
    goto <bb 233>;

<bb 194>:
  D.42023 = strlen (buf);
  D.42024 = buf + D.42023;
  D.42025 = strlen (buf);
  D.42026 = 65536 - D.42025;
  D.41736 = a_engine->crypto_type;
  D.42016 = a_engine->ssec[D.41736].local_crypto_key;
  switch_snprintf (D.42024, D.42026, "a=crypto:%s\n", D.42016);
  goto <bb 233>;

<bb 195>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 != 0)
    goto <bb 196>;
  else
    goto <bb 233>;

<bb 196>:
  cur_ptime = 0;
  this_ptime = 0;
  cng_type = 0;
  D.42030 = switch_media_handle_test_media_flag (smh, 9);
  if (D.42030 == 0)
    goto <bb 197>;
  else
    goto <bb 200>;

<bb 197>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  D.41607 = D.41606 != 0;
  D.41608 = use_cng != 0;
  D.41609 = D.41607 && D.41608;
  if (D.41609 != 0)
    goto <bb 198>;
  else
    goto <bb 200>;

<bb 198>:
  D.41522 = smh->mparams;
  D.41606 = D.41522->cng_pt;
  cng_type = (int) D.41606;
  D.41720 = a_engine->codec_negotiated;
  if (D.41720 == 0)
    goto <bb 199>;
  else
    goto <bb 200>;

<bb 199>:
  D.41522 = smh->mparams;
  D.41522->cng_pt = 0;

<bb 200>:
  D.41512 = session->channel;
  mult = switch_channel_get_variable_dup (D.41512, "sdp_m_per_ptime", 1, -1);
  D.41512 = session->channel;
  D.42039 = switch_channel_test_flag (D.41512, 106);
  if (D.42039 != 0)
    goto <bb 203>;
  else
    goto <bb 201>;

<bb 201>:
  if (mult != 0B)
    goto <bb 202>;
  else
    goto <bb 214>;

<bb 202>:
  D.42042 = switch_false (mult);
  if (D.42042 != 0)
    goto <bb 203>;
  else
    goto <bb 214>;

<bb 203>:
  bp = buf;
  D.41512 = session->channel;
  D.42046 = switch_channel_test_flag (D.41512, 106);
  if (D.42046 == 0)
    goto <bb 204>;
  else
    goto <bb 206>;

<bb 204>:
  D.41512 = session->channel;
  D.42048 = switch_channel_test_flag (D.41512, 109);
  if (D.42048 == 0)
    goto <bb 205>;
  else
    goto <bb 206>;

<bb 205>:
  iftmp.32 = 1;
  goto <bb 207>;

<bb 206>:
  iftmp.32 = 0;

<bb 207>:
  both = iftmp.32;
  D.41732 = a_engine->no_crypto;
  if (D.41732 == 0)
    goto <bb 208>;
  else
    goto <bb 209>;

<bb 208>:
  D.41512 = session->channel;
  D.42054 = switch_channel_test_flag (D.41512, 92);
  if (D.42054 != 0)
    goto <bb 210>;
  else
    goto <bb 209>;

<bb 209>:
  D.41512 = session->channel;
  D.42055 = switch_channel_test_flag (D.41512, 109);
  if (D.42055 != 0)
    goto <bb 210>;
  else
    goto <bb 212>;

<bb 210>:
  map.33 = map;
  generate_m (session, buf, 65536, port, family, ip, 0, append_audio, sr, use_cng, cng_type, map.33, 1, sdp_type);
  D.42057 = strlen (buf);
  bp = buf + D.42057;
  D.42058 = smh->crypto_mode;
  if (D.42058 == 1)
    goto <bb 211>;
  else
    goto <bb 212>;

<bb 211>:
  both = 0;

<bb 212>:
  if (both != 0)
    goto <bb 213>;
  else
    goto <bb 233>;

<bb 213>:
  D.42063 = strlen (buf);
  D.42064 = 65536 - D.42063;
  map.33 = map;
  generate_m (session, bp, D.42064, port, family, ip, 0, append_audio, sr, use_cng, cng_type, map.33, 0, sdp_type);
  goto <bb 233>;

<bb 214>:
  i = 0;
  goto <bb 232>;

<bb 215>:
  imp = smh->codecs[i];
  D.42065 = imp->codec_type;
  if (D.42065 != 0)
    goto <bb 216>;
  else
    goto <bb 217>;

<bb 216>:
  // predicted unlikely by continue predictor.
  goto <bb 231>;

<bb 217>:
  D.42068 = imp->microseconds_per_packet;
  this_ptime = D.42068 / 1000;
  D.42071 = imp->iananame;
  D.42072 = strcasecmp (D.42071, "ilbc");
  if (D.42072 == 0)
    goto <bb 219>;
  else
    goto <bb 218>;

<bb 218>:
  D.42071 = imp->iananame;
  D.42074 = strcasecmp (D.42071, "isac");
  if (D.42074 == 0)
    goto <bb 219>;
  else
    goto <bb 220>;

<bb 219>:
  this_ptime = 20;

<bb 220>:
  if (cur_ptime != this_ptime)
    goto <bb 221>;
  else
    goto <bb 231>;

<bb 221>:
  bp = buf;
  both = 1;
  cur_ptime = this_ptime;
  D.41732 = a_engine->no_crypto;
  if (D.41732 == 0)
    goto <bb 222>;
  else
    goto <bb 223>;

<bb 222>:
  D.41512 = session->channel;
  D.42081 = switch_channel_test_flag (D.41512, 92);
  if (D.42081 != 0)
    goto <bb 224>;
  else
    goto <bb 223>;

<bb 223>:
  D.41512 = session->channel;
  D.42082 = switch_channel_test_flag (D.41512, 109);
  if (D.42082 != 0)
    goto <bb 224>;
  else
    goto <bb 226>;

<bb 224>:
  D.42083 = strlen (buf);
  D.42084 = 65536 - D.42083;
  map.33 = map;
  generate_m (session, bp, D.42084, port, family, ip, cur_ptime, append_audio, sr, use_cng, cng_type, map.33, 1, sdp_type);
  D.42085 = strlen (buf);
  bp = buf + D.42085;
  D.42058 = smh->crypto_mode;
  if (D.42058 == 1)
    goto <bb 225>;
  else
    goto <bb 226>;

<bb 225>:
  both = 0;

<bb 226>:
  D.41512 = session->channel;
  D.42090 = switch_channel_test_flag (D.41512, 106);
  if (D.42090 != 0)
    goto <bb 228>;
  else
    goto <bb 227>;

<bb 227>:
  D.41512 = session->channel;
  D.42092 = switch_channel_test_flag (D.41512, 109);
  if (D.42092 != 0)
    goto <bb 228>;
  else
    goto <bb 229>;

<bb 228>:
  both = 0;

<bb 229>:
  if (both != 0)
    goto <bb 230>;
  else
    goto <bb 231>;

<bb 230>:
  D.42095 = strlen (buf);
  D.42096 = 65536 - D.42095;
  map.33 = map;
  generate_m (session, bp, D.42096, port, family, ip, cur_ptime, append_audio, sr, use_cng, cng_type, map.33, 0, sdp_type);

<bb 231>:
  i = i + 1;

<bb 232>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 > i)
    goto <bb 215>;
  else
    goto <bb 233>;

<bb 233>:
  D.41512 = session->channel;
  D.42097 = switch_channel_test_flag (D.41512, 98);
  if (D.42097 != 0)
    goto <bb 234>;
  else
    goto <bb 401>;

<bb 234>:
  D.41512 = session->channel;
  D.42100 = switch_channel_direction (D.41512);
  if (D.42100 == 0)
    goto <bb 235>;
  else
    goto <bb 237>;

<bb 235>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  D.42103 = switch_channel_test_flag (D.41535, 109);
  if (D.42103 != 0)
    goto <bb 236>;
  else
    goto <bb 237>;

<bb 236>:
  v_engine->no_crypto = 1;

<bb 237>:
  D.42106 = v_engine->local_sdp_port;
  if (D.42106 == 0)
    goto <bb 238>;
  else
    goto <bb 239>;

<bb 238>:
  switch_core_media_choose_port (session, 1, 0);

<bb 239>:
  D.41512 = session->channel;
  D.42109 = switch_channel_test_flag (D.41512, 106);
  if (D.42109 != 0)
    goto <bb 240>;
  else
    goto <bb 241>;

<bb 240>:
  switch_media_handle_set_media_flag (smh, 16);

<bb 241>:
  D.42112 = v_engine->adv_sdp_port;
  v_port = (uint32_t) D.42112;
  if (v_port != 0)
    goto <bb 242>;
  else
    goto <bb 401>;

<bb 242>:
  loops = 0;
  goto <bb 400>;

<bb 243>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  D.42115 = switch_channel_test_flag (D.41535, 108);
  if (D.42115 != 0)
    goto <bb 244>;
  else
    goto <bb 245>;

<bb 244>:
  D.42118 = (short unsigned int) v_port;
  gen_ice (session, 1, ip, D.42118);

<bb 245>:
  D.42119 = strlen (buf);
  D.42120 = buf + D.42119;
  D.42121 = strlen (buf);
  D.42122 = 65536 - D.42121;
  if (loops == 0)
    goto <bb 246>;
  else
    goto <bb 248>;

<bb 246>:
  D.41512 = session->channel;
  D.42129 = switch_channel_test_flag (D.41512, 92);
  if (D.42129 != 0)
    goto <bb 247>;
  else
    goto <bb 248>;

<bb 247>:
  D.41512 = session->channel;
  D.42131 = switch_channel_direction (D.41512);
  if (D.42131 == 1)
    goto <bb 250>;
  else
    goto <bb 248>;

<bb 248>:
  D.41736 = a_engine->crypto_type;
  if (D.41736 != 9)
    goto <bb 250>;
  else
    goto <bb 249>;

<bb 249>:
  D.41512 = session->channel;
  D.42133 = switch_channel_test_flag (D.41512, 109);
  if (D.42133 != 0)
    goto <bb 250>;
  else
    goto <bb 251>;

<bb 250>:
  iftmp.34 = 1;
  goto <bb 252>;

<bb 251>:
  iftmp.34 = 0;

<bb 252>:
  D.42134 = get_media_profile_name (session, iftmp.34);
  switch_snprintf (D.42120, D.42122, "m=video %d %s", v_port, D.42134);
  D.42135 = v_engine->codec_negotiated;
  if (D.42135 != 0)
    goto <bb 253>;
  else
    goto <bb 261>;

<bb 253>:
  switch_core_media_set_video_codec (session, 0);
  D.42138 = strlen (buf);
  D.42139 = buf + D.42138;
  D.42140 = strlen (buf);
  D.42141 = 65536 - D.42140;
  D.42142 = v_engine->cur_payload_map;
  D.42143 = D.42142->agreed_pt;
  D.42144 = (int) D.42143;
  switch_snprintf (D.42139, D.42141, " %d", D.42144);
  D.42145 = switch_media_handle_test_media_flag (smh, 16);
  if (D.42145 != 0)
    goto <bb 254>;
  else
    goto <bb 276>;

<bb 254>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_lock (D.41747);
  pmap = v_engine->cur_payload_map;
  goto <bb 258>;

<bb 255>:
  D.42148 = pmap->pt;
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  if (D.42148 != D.42149)
    goto <bb 256>;
  else
    goto <bb 257>;

<bb 256>:
  D.42152 = strlen (buf);
  D.42153 = buf + D.42152;
  D.42154 = strlen (buf);
  D.42155 = 65536 - D.42154;
  D.42148 = pmap->pt;
  D.42156 = (int) D.42148;
  switch_snprintf (D.42153, D.42155, " %d", D.42156);

<bb 257>:
  pmap = pmap->next;

<bb 258>:
  if (pmap != 0B)
    goto <bb 259>;
  else
    goto <bb 260>;

<bb 259>:
  D.42158 = pmap->allocated;
  if (D.42158 != 0)
    goto <bb 255>;
  else
    goto <bb 260>;

<bb 260>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_unlock (D.41747);
  goto <bb 276>;

<bb 261>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 != 0)
    goto <bb 262>;
  else
    goto <bb 276>;

<bb 262>:
  already_did = {};
  i = 0;
  goto <bb 275>;

<bb 263>:
  imp = smh->codecs[i];
  D.42162 = imp->codec_type;
  if (D.42162 != 1)
    goto <bb 264>;
  else
    goto <bb 265>;

<bb 264>:
  // predicted unlikely by continue predictor.
  goto <bb 274>;

<bb 265>:
  D.41512 = session->channel;
  D.42165 = switch_channel_direction (D.41512);
  if (D.42165 == 0)
    goto <bb 266>;
  else
    goto <bb 268>;

<bb 266>:
  D.41512 = session->channel;
  D.42168 = switch_channel_test_flag (D.41512, 114);
  if (D.42168 != 0)
    goto <bb 267>;
  else
    goto <bb 268>;

<bb 267>:
  // predicted unlikely by continue predictor.
  goto <bb 274>;

<bb 268>:
  D.42171 = smh->ianacodes[i];
  D.42172 = (signed char) D.42171;
  if (D.42172 >= 0)
    goto <bb 269>;
  else
    goto <bb 272>;

<bb 269>:
  D.42171 = smh->ianacodes[i];
  D.42175 = (int) D.42171;
  D.42176 = already_did[D.42175];
  if (D.42176 != 0)
    goto <bb 270>;
  else
    goto <bb 271>;

<bb 270>:
  // predicted unlikely by continue predictor.
  goto <bb 274>;

<bb 271>:
  D.42171 = smh->ianacodes[i];
  D.42175 = (int) D.42171;
  already_did[D.42175] = 1;

<bb 272>:
  D.42179 = strlen (buf);
  D.42180 = buf + D.42179;
  D.42181 = strlen (buf);
  D.42182 = 65536 - D.42181;
  D.42171 = smh->ianacodes[i];
  D.42175 = (int) D.42171;
  switch_snprintf (D.42180, D.42182, " %d", D.42175);
  if (ptime == 0)
    goto <bb 273>;
  else
    goto <bb 274>;

<bb 273>:
  D.42185 = imp->microseconds_per_packet;
  ptime = D.42185 / 1000;

<bb 274>:
  i = i + 1;

<bb 275>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 > i)
    goto <bb 263>;
  else
    goto <bb 276>;

<bb 276>:
  D.42186 = strlen (buf);
  D.42187 = buf + D.42186;
  D.42188 = strlen (buf);
  D.42189 = 65536 - D.42188;
  switch_snprintf (D.42187, D.42189, "\n");
  D.42135 = v_engine->codec_negotiated;
  if (D.42135 != 0)
    goto <bb 277>;
  else
    goto <bb 308>;

<bb 277>:
  D.42142 = v_engine->cur_payload_map;
  D.42192 = D.42142->rm_encoding;
  D.42193 = strcasecmp (D.42192, "VP8");
  if (D.42193 == 0)
    goto <bb 278>;
  else
    goto <bb 279>;

<bb 278>:
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  vp8 = (int) D.42149;

<bb 279>:
  D.42142 = v_engine->cur_payload_map;
  D.42192 = D.42142->rm_encoding;
  D.42196 = strcasecmp (D.42192, "red");
  if (D.42196 == 0)
    goto <bb 280>;
  else
    goto <bb 281>;

<bb 280>:
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  red = (int) D.42149;

<bb 281>:
  D.42142 = v_engine->cur_payload_map;
  rate = D.42142->rm_rate;
  D.42199 = strlen (buf);
  D.42200 = buf + D.42199;
  D.42201 = strlen (buf);
  D.42202 = 65536 - D.42201;
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  D.42203 = (int) D.42149;
  D.42142 = v_engine->cur_payload_map;
  D.42192 = D.42142->rm_encoding;
  D.42142 = v_engine->cur_payload_map;
  D.42204 = D.42142->rm_rate;
  switch_snprintf (D.42200, D.42202, "a=rtpmap:%d %s/%ld\n", D.42203, D.42192, D.42204);
  D.41512 = session->channel;
  D.42205 = switch_channel_test_flag (D.41512, 84);
  if (D.42205 != 0)
    goto <bb 282>;
  else
    goto <bb 283>;

<bb 282>:
  D.42142 = v_engine->cur_payload_map;
  pass_fmtp = D.42142->rm_fmtp;
  goto <bb 289>;

<bb 283>:
  pass_fmtp = 0B;
  D.41512 = session->channel;
  D.42209 = switch_channel_get_partner_uuid (D.41512);
  if (D.42209 != 0B)
    goto <bb 284>;
  else
    goto <bb 286>;

<bb 284>:
  D.41512 = session->channel;
  of = switch_channel_get_variable_partner (D.41512, "rtp_video_fmtp");
  if (of != 0B)
    goto <bb 285>;
  else
    goto <bb 286>;

<bb 285>:
  pass_fmtp = of;

<bb 286>:
  if (ov_fmtp != 0B)
    goto <bb 287>;
  else
    goto <bb 288>;

<bb 287>:
  pass_fmtp = ov_fmtp;
  goto <bb 289>;

<bb 288>:
  D.41512 = session->channel;
  pass_fmtp = switch_channel_get_variable_dup (D.41512, "rtp_video_fmtp", 1, -1);

<bb 289>:
  if (pass_fmtp != 0B)
    goto <bb 290>;
  else
    goto <bb 291>;

<bb 290>:
  D.42219 = strlen (buf);
  D.42220 = buf + D.42219;
  D.42221 = strlen (buf);
  D.42222 = 65536 - D.42221;
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  D.42203 = (int) D.42149;
  switch_snprintf (D.42220, D.42222, "a=fmtp:%d %s\n", D.42203, pass_fmtp);

<bb 291>:
  D.42223 = switch_media_handle_test_media_flag (smh, 16);
  if (D.42223 != 0)
    goto <bb 292>;
  else
    goto <bb 300>;

<bb 292>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_lock (D.41747);
  pmap = v_engine->cur_payload_map;
  goto <bb 297>;

<bb 293>:
  D.42226 = pmap->pt;
  D.42142 = v_engine->cur_payload_map;
  D.42149 = D.42142->pt;
  if (D.42226 != D.42149)
    goto <bb 294>;
  else
    goto <bb 296>;

<bb 294>:
  D.42229 = pmap->negotiated;
  if (D.42229 != 0)
    goto <bb 295>;
  else
    goto <bb 296>;

<bb 295>:
  D.42232 = strlen (buf);
  D.42233 = buf + D.42232;
  D.42234 = strlen (buf);
  D.42235 = 65536 - D.42234;
  D.42226 = pmap->pt;
  D.42236 = (int) D.42226;
  D.42237 = pmap->iananame;
  D.42238 = pmap->rate;
  switch_snprintf (D.42233, D.42235, "a=rtpmap:%d %s/%ld\n", D.42236, D.42237, D.42238);

<bb 296>:
  pmap = pmap->next;

<bb 297>:
  if (pmap != 0B)
    goto <bb 298>;
  else
    goto <bb 299>;

<bb 298>:
  D.42240 = pmap->allocated;
  if (D.42240 != 0)
    goto <bb 293>;
  else
    goto <bb 299>;

<bb 299>:
  D.41747 = smh->sdp_mutex;
  switch_mutex_unlock (D.41747);

<bb 300>:
  if (append_video != 0B)
    goto <bb 301>;
  else
    goto <bb 343>;

<bb 301>:
  D.42243 = strlen (buf);
  D.42244 = buf + D.42243;
  D.42245 = strlen (buf);
  D.42246 = 65536 - D.42245;
  D.42249 = *append_video;
  if (D.42249 != 0)
    goto <bb 302>;
  else
    goto <bb 303>;

<bb 302>:
  D.42252 = strlen (append_video);
  D.42253 = D.42252 + -1;
  iftmp.36 = append_video + D.42253;
  goto <bb 304>;

<bb 303>:
  iftmp.36 = append_video;

<bb 304>:
  D.42255 = *iftmp.36;
  if (D.42255 == 10)
    goto <bb 305>;
  else
    goto <bb 306>;

<bb 305>:
  iftmp.35 = "";
  goto <bb 307>;

<bb 306>:
  iftmp.35 = "\n";

<bb 307>:
  switch_snprintf (D.42244, D.42246, "%s%s", append_video, iftmp.35);
  goto <bb 343>;

<bb 308>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 != 0)
    goto <bb 309>;
  else
    goto <bb 343>;

<bb 309>:
  already_did = {};
  i = 0;
  goto <bb 342>;

<bb 310>:
  imp = smh->codecs[i];
  fmtp = 0B;
  D.42262 = smh->ianacodes[i];
  ianacode = (uint32_t) D.42262;
  D.42263 = imp->codec_type;
  if (D.42263 != 1)
    goto <bb 311>;
  else
    goto <bb 312>;

<bb 311>:
  // predicted unlikely by continue predictor.
  goto <bb 341>;

<bb 312>:
  D.41512 = session->channel;
  D.42266 = switch_channel_direction (D.41512);
  if (D.42266 == 0)
    goto <bb 313>;
  else
    goto <bb 315>;

<bb 313>:
  D.41512 = session->channel;
  D.42269 = switch_channel_test_flag (D.41512, 114);
  if (D.42269 != 0)
    goto <bb 314>;
  else
    goto <bb 315>;

<bb 314>:
  // predicted unlikely by continue predictor.
  goto <bb 341>;

<bb 315>:
  if (ianacode <= 127)
    goto <bb 316>;
  else
    goto <bb 319>;

<bb 316>:
  D.42274 = already_did[ianacode];
  if (D.42274 != 0)
    goto <bb 317>;
  else
    goto <bb 318>;

<bb 317>:
  // predicted unlikely by continue predictor.
  goto <bb 341>;

<bb 318>:
  already_did[ianacode] = 1;

<bb 319>:
  if (rate == 0)
    goto <bb 320>;
  else
    goto <bb 321>;

<bb 320>:
  rate = imp->samples_per_second;

<bb 321>:
  D.42279 = imp->iananame;
  D.42280 = imp->number_of_channels;
  D.42281 = (int) D.42280;
  channels = get_channels (D.42279, D.42281);
  D.42279 = imp->iananame;
  D.42282 = strcasecmp (D.42279, "VP8");
  if (D.42282 == 0)
    goto <bb 322>;
  else
    goto <bb 323>;

<bb 322>:
  vp8 = (int) ianacode;

<bb 323>:
  D.42279 = imp->iananame;
  D.42285 = strcasecmp (D.42279, "red");
  if (D.42285 == 0)
    goto <bb 324>;
  else
    goto <bb 325>;

<bb 324>:
  red = (int) ianacode;

<bb 325>:
  if (channels > 1)
    goto <bb 326>;
  else
    goto <bb 327>;

<bb 326>:
  D.42290 = strlen (buf);
  D.42291 = buf + D.42290;
  D.42292 = strlen (buf);
  D.42293 = 65536 - D.42292;
  D.42279 = imp->iananame;
  D.42294 = imp->samples_per_second;
  switch_snprintf (D.42291, D.42293, "a=rtpmap:%d %s/%d/%d\n", ianacode, D.42279, D.42294, channels);
  goto <bb 328>;

<bb 327>:
  D.42296 = strlen (buf);
  D.42297 = buf + D.42296;
  D.42298 = strlen (buf);
  D.42299 = 65536 - D.42298;
  D.42279 = imp->iananame;
  D.42294 = imp->samples_per_second;
  switch_snprintf (D.42297, D.42299, "a=rtpmap:%d %s/%d\n", ianacode, D.42279, D.42294);

<bb 328>:
  D.42300 = _zstr (ov_fmtp);
  if (D.42300 == 0)
    goto <bb 329>;
  else
    goto <bb 330>;

<bb 329>:
  fmtp = ov_fmtp;
  goto <bb 338>;

<bb 330>:
  map.33 = map;
  if (map.33 != 0B)
    goto <bb 331>;
  else
    goto <bb 332>;

<bb 331>:
  map.33 = map;
  D.42279 = imp->iananame;
  fmtp = switch_event_get_header_idx (map.33, D.42279, -1);

<bb 332>:
  D.42306 = smh->fmtps[i];
  if (D.42306 != 0B)
    goto <bb 333>;
  else
    goto <bb 334>;

<bb 333>:
  fmtp = smh->fmtps[i];

<bb 334>:
  D.42309 = _zstr (fmtp);
  if (D.42309 != 0)
    goto <bb 335>;
  else
    goto <bb 336>;

<bb 335>:
  fmtp = imp->fmtp;

<bb 336>:
  D.42312 = _zstr (fmtp);
  if (D.42312 != 0)
    goto <bb 337>;
  else
    goto <bb 338>;

<bb 337>:
  fmtp = pass_fmtp;

<bb 338>:
  D.42315 = _zstr (fmtp);
  if (D.42315 == 0)
    goto <bb 339>;
  else
    goto <bb 341>;

<bb 339>:
  D.42318 = strcasecmp (fmtp, "_blank_");
  if (D.42318 != 0)
    goto <bb 340>;
  else
    goto <bb 341>;

<bb 340>:
  D.42321 = strlen (buf);
  D.42322 = buf + D.42321;
  D.42323 = strlen (buf);
  D.42324 = 65536 - D.42323;
  switch_snprintf (D.42322, D.42324, "a=fmtp:%d %s\n", ianacode, fmtp);

<bb 341>:
  i = i + 1;

<bb 342>:
  D.41522 = smh->mparams;
  D.41587 = D.41522->num_codecs;
  if (D.41587 > i)
    goto <bb 310>;
  else
    goto <bb 343>;

<bb 343>:
  if (is_outbound != 0)
    goto <bb 345>;
  else
    goto <bb 344>;

<bb 344>:
  D.41512 = session->channel;
  D.42328 = switch_channel_test_flag (D.41512, 84);
  if (D.42328 != 0)
    goto <bb 345>;
  else
    goto <bb 347>;

<bb 345>:
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  D.42329 = switch_channel_test_flag (D.41535, 109);
  if (D.42329 != 0)
    goto <bb 346>;
  else
    goto <bb 347>;

<bb 346>:
  generate_local_fingerprint (smh, 1);

<bb 347>:
  D.42332 = v_engine->local_dtls_fingerprint.type;
  D.42333 = _zstr (D.42332);
  if (D.42333 == 0)
    goto <bb 348>;
  else
    goto <bb 349>;

<bb 348>:
  D.42336 = strlen (buf);
  D.42337 = buf + D.42336;
  D.42338 = strlen (buf);
  D.42339 = 65536 - D.42338;
  D.42332 = v_engine->local_dtls_fingerprint.type;
  D.42340 = &v_engine->local_dtls_fingerprint.str;
  switch_snprintf (D.42337, D.42339, "a=fingerprint:%s %s\n", D.42332, D.42340);

<bb 349>:
  D.41522 = smh->mparams;
  D.41527 = D.41522->rtcp_video_interval_msec;
  if (D.41527 != 0B)
    goto <bb 350>;
  else
    goto <bb 353>;

<bb 350>:
  D.42343 = v_engine->rtcp_mux;
  if (D.42343 > 0)
    goto <bb 351>;
  else
    goto <bb 352>;

<bb 351>:
  D.42346 = strlen (buf);
  D.42347 = buf + D.42346;
  D.42348 = strlen (buf);
  D.42349 = 65536 - D.42348;
  switch_snprintf (D.42347, D.42349, "a=rtcp-mux\n");
  D.42350 = strlen (buf);
  D.42351 = buf + D.42350;
  D.42352 = strlen (buf);
  D.42353 = 65536 - D.42352;
  switch_snprintf (D.42351, D.42353, "a=rtcp:%d IN %s %s\n", v_port, family, ip);
  goto <bb 353>;

<bb 352>:
  D.42355 = strlen (buf);
  D.42356 = buf + D.42355;
  D.42357 = strlen (buf);
  D.42358 = 65536 - D.42357;
  D.42359 = v_port + 1;
  switch_snprintf (D.42356, D.42358, "a=rtcp:%d IN %s %s\n", D.42359, family, ip);

<bb 353>:
  D.42360 = BIT_FIELD_REF <*v_engine, 16, 91280>;
  D.42361 = D.42360 & 65535;
  if (D.42361 != 0)
    goto <bb 354>;
  else
    goto <bb 361>;

<bb 354>:
  D.42364 = strlen (buf);
  D.42365 = buf + D.42364;
  D.42366 = strlen (buf);
  D.42367 = 65536 - D.42366;
  D.42369 = v_engine->fir;
  if (D.42369 != 0)
    goto <bb 355>;
  else
    goto <bb 356>;

<bb 355>:
  iftmp.37 = "fir ";
  goto <bb 357>;

<bb 356>:
  iftmp.37 = "";

<bb 357>:
  D.42374 = v_engine->pli;
  if (D.42374 != 0)
    goto <bb 358>;
  else
    goto <bb 359>;

<bb 358>:
  iftmp.38 = "pli";
  goto <bb 360>;

<bb 359>:
  iftmp.38 = "";

<bb 360>:
  switch_snprintf (D.42365, D.42367, "a=rtcp-fb:* %s%s\n", iftmp.37, iftmp.38);

<bb 361>:
  D.42378 = v_engine->ice_out.cands[0][0].ready;
  if (D.42378 != 0)
    goto <bb 362>;
  else
    goto <bb 383>;

<bb 362>:
  tmp1 = "";
  tmp2 = "";
  c1 = 659136;
  c2 = 659134;
  c3 = 659126;
  c4 = 659124;
  bw = 256;
  tmp1[10] = 0;
  tmp2[10] = 0;
  switch_stun_random_string (&tmp1, 10, "0123456789");
  switch_stun_random_string (&tmp2, 10, "0123456789");
  ice_out = &v_engine->ice_out;
  D.41534 = smh->session;
  D.41535 = D.41534->channel;
  vbw = switch_channel_get_variable_dup (D.41535, "rtp_video_max_bandwidth", 1, -1);
  if (vbw != 0B)
    goto <bb 363>;
  else
    goto <bb 364>;

<bb 363>:
  v = atoi (vbw);
  bw = v;

<bb 364>:
  if (bw > 0)
    goto <bb 365>;
  else
    goto <bb 366>;

<bb 365>:
  D.42385 = strlen (buf);
  D.42386 = buf + D.42385;
  D.42387 = strlen (buf);
  D.42388 = 65536 - D.42387;
  switch_snprintf (D.42386, D.42388, "b=AS:%d\n", bw);

<bb 366>:
  if (vp8 != 0)
    goto <bb 367>;
  else
    goto <bb 369>;

<bb 367>:
  D.41512 = session->channel;
  D.42391 = switch_channel_test_flag (D.41512, 106);
  if (D.42391 != 0)
    goto <bb 368>;
  else
    goto <bb 369>;

<bb 368>:
  D.42394 = strlen (buf);
  D.42395 = buf + D.42394;
  D.42396 = strlen (buf);
  D.42397 = 65536 - D.42396;
  switch_snprintf (D.42395, D.42397, "a=rtcp-fb:%d ccm fir\n", vp8);

<bb 369>:
  if (red != 0)
    goto <bb 370>;
  else
    goto <bb 371>;

<bb 370>:
  D.42400 = strlen (buf);
  D.42401 = buf + D.42400;
  D.42402 = strlen (buf);
  D.42403 = 65536 - D.42402;
  switch_snprintf (D.42401, D.42403, "a=rtcp-fb:%d nack\n", vp8);

<bb 371>:
  D.42404 = strlen (buf);
  D.42405 = buf + D.42404;
  D.42406 = strlen (buf);
  D.42407 = 65536 - D.42406;
  D.42408 = v_engine->ssrc;
  D.41935 = smh->cname;
  switch_snprintf (D.42405, D.42407, "a=ssrc:%u cname:%s\n", D.42408, D.41935);
  D.42409 = strlen (buf);
  D.42410 = buf + D.42409;
  D.42411 = strlen (buf);
  D.42412 = 65536 - D.42411;
  D.42408 = v_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.42410, D.42412, "a=ssrc:%u msid:%s v0\n", D.42408, D.41719);
  D.42413 = strlen (buf);
  D.42414 = buf + D.42413;
  D.42415 = strlen (buf);
  D.42416 = 65536 - D.42415;
  D.42408 = v_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.42414, D.42416, "a=ssrc:%u mslabel:%s\n", D.42408, D.41719);
  D.42417 = strlen (buf);
  D.42418 = buf + D.42417;
  D.42419 = strlen (buf);
  D.42420 = 65536 - D.42419;
  D.42408 = v_engine->ssrc;
  D.41719 = smh->msid;
  switch_snprintf (D.42418, D.42420, "a=ssrc:%u label:%sv0\n", D.42408, D.41719);
  D.42421 = strlen (buf);
  D.42422 = buf + D.42421;
  D.42423 = strlen (buf);
  D.42424 = 65536 - D.42423;
  D.41952 = ice_out->ufrag;
  switch_snprintf (D.42422, D.42424, "a=ice-ufrag:%s\n", D.41952);
  D.42425 = strlen (buf);
  D.42426 = buf + D.42425;
  D.42427 = strlen (buf);
  D.42428 = 65536 - D.42427;
  D.41957 = ice_out->pwd;
  switch_snprintf (D.42426, D.42428, "a=ice-pwd:%s\n", D.41957);
  D.42429 = strlen (buf);
  D.42430 = buf + D.42429;
  D.42431 = strlen (buf);
  D.42432 = 65536 - D.42431;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  switch_snprintf (D.42430, D.42432, "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", &tmp1, D.41962, c1, D.41963, D.41965);
  D.42433 = v_engine->local_sdp_ip;
  D.42434 = _zstr (D.42433);
  if (D.42434 == 0)
    goto <bb 372>;
  else
    goto <bb 376>;

<bb 372>:
  D.41963 = ice_out->cands[0][0].con_addr;
  D.42437 = _zstr (D.41963);
  if (D.42437 == 0)
    goto <bb 373>;
  else
    goto <bb 376>;

<bb 373>:
  D.42433 = v_engine->local_sdp_ip;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.39666 = __builtin_strcmp (D.42433, D.41963);
  if (D.39666 != 0)
    goto <bb 374>;
  else
    goto <bb 376>;

<bb 374>:
  D.42106 = v_engine->local_sdp_port;
  D.41964 = ice_out->cands[0][0].con_port;
  if (D.42106 != D.41964)
    goto <bb 375>;
  else
    goto <bb 376>;

<bb 375>:
  D.42444 = strlen (buf);
  D.42445 = buf + D.42444;
  D.42446 = strlen (buf);
  D.42447 = 65536 - D.42446;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.42433 = v_engine->local_sdp_ip;
  D.42106 = v_engine->local_sdp_port;
  D.42448 = (int) D.42106;
  switch_snprintf (D.42445, D.42447, "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", &tmp2, D.41962, c3, D.41963, D.41965, D.42433, D.42448);

<bb 376>:
  D.42343 = v_engine->rtcp_mux;
  D.42451 = D.42343 <= 0;
  D.41986 = is_outbound != 0;
  D.42452 = D.42451 || D.41986;
  if (D.42452 != 0)
    goto <bb 378>;
  else
    goto <bb 377>;

<bb 377>:
  D.41512 = session->channel;
  D.42454 = switch_channel_test_flag (D.41512, 84);
  if (D.42454 != 0)
    goto <bb 378>;
  else
    goto <bb 383>;

<bb 378>:
  D.42455 = strlen (buf);
  D.42456 = buf + D.42455;
  D.42457 = strlen (buf);
  D.42458 = 65536 - D.42457;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.42343 = v_engine->rtcp_mux;
  D.42459 = D.42343 <= 0;
  D.42460 = D.41965 + D.42459;
  switch_snprintf (D.42456, D.42458, "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", &tmp1, D.41962, c2, D.41963, D.42460);
  D.42433 = v_engine->local_sdp_ip;
  D.42461 = _zstr (D.42433);
  if (D.42461 == 0)
    goto <bb 379>;
  else
    goto <bb 383>;

<bb 379>:
  D.42464 = ice_out->cands[0][1].con_addr;
  D.42465 = _zstr (D.42464);
  if (D.42465 == 0)
    goto <bb 380>;
  else
    goto <bb 383>;

<bb 380>:
  D.42433 = v_engine->local_sdp_ip;
  D.42464 = ice_out->cands[0][1].con_addr;
  D.39675 = __builtin_strcmp (D.42433, D.42464);
  if (D.39675 != 0)
    goto <bb 381>;
  else
    goto <bb 383>;

<bb 381>:
  D.42106 = v_engine->local_sdp_port;
  D.42470 = ice_out->cands[0][1].con_port;
  if (D.42106 != D.42470)
    goto <bb 382>;
  else
    goto <bb 383>;

<bb 382>:
  D.42473 = strlen (buf);
  D.42474 = buf + D.42473;
  D.42475 = strlen (buf);
  D.42476 = 65536 - D.42475;
  D.41962 = ice_out->cands[0][0].transport;
  D.41963 = ice_out->cands[0][0].con_addr;
  D.41964 = ice_out->cands[0][0].con_port;
  D.41965 = (int) D.41964;
  D.42343 = v_engine->rtcp_mux;
  D.42459 = D.42343 <= 0;
  D.42460 = D.41965 + D.42459;
  D.42433 = v_engine->local_sdp_ip;
  D.42106 = v_engine->local_sdp_port;
  D.42448 = (int) D.42106;
  D.42343 = v_engine->rtcp_mux;
  D.42459 = D.42343 <= 0;
  D.42477 = D.42448 + D.42459;
  switch_snprintf (D.42474, D.42476, "a=candidate:%s 2 %s %u %s %d typ srflx generation 0\n", &tmp2, D.41962, c4, D.41963, D.42460, D.42433, D.42477);

<bb 383>:
  if (loops == 0)
    goto <bb 384>;
  else
    goto <bb 393>;

<bb 384>:
  D.41512 = session->channel;
  D.42480 = switch_channel_test_flag (D.41512, 92);
  if (D.42480 != 0)
    goto <bb 385>;
  else
    goto <bb 393>;

<bb 385>:
  D.41512 = session->channel;
  D.42483 = switch_channel_test_flag (D.41512, 109);
  if (D.42483 == 0)
    goto <bb 386>;
  else
    goto <bb 393>;

<bb 386>:
  i = 0;
  goto <bb 392>;

<bb 387>:
  D.42486 = smh->crypto_suite_order[i];
  j = SUITES[D.42486].type;
  D.41736 = a_engine->crypto_type;
  if (D.41736 == j)
    goto <bb 389>;
  else
    goto <bb 388>;

<bb 388>:
  D.41736 = a_engine->crypto_type;
  if (D.41736 == 9)
    goto <bb 389>;
  else
    goto <bb 391>;

<bb 389>:
  D.42490 = a_engine->ssec[j].local_crypto_key;
  D.42491 = _zstr (D.42490);
  if (D.42491 == 0)
    goto <bb 390>;
  else
    goto <bb 391>;

<bb 390>:
  D.42494 = strlen (buf);
  D.42495 = buf + D.42494;
  D.42496 = strlen (buf);
  D.42497 = 65536 - D.42496;
  D.42498 = v_engine->ssec[j].local_crypto_key;
  switch_snprintf (D.42495, D.42497, "a=crypto:%s\n", D.42498);

<bb 391>:
  i = i + 1;

<bb 392>:
  D.42486 = smh->crypto_suite_order[i];
  if (D.42486 != 9)
    goto <bb 387>;
  else
    goto <bb 393>;

<bb 393>:
  if (local_sdp_video_zrtp_hash != 0B)
    goto <bb 394>;
  else
    goto <bb 395>;

<bb 394>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 6892, session, 7, "Adding video a=zrtp-hash:%s\n", local_sdp_video_zrtp_hash);
  D.42501 = strlen (buf);
  D.42502 = buf + D.42501;
  D.42503 = strlen (buf);
  D.42504 = 65536 - D.42503;
  switch_snprintf (D.42502, D.42504, "a=zrtp-hash:%s\n", local_sdp_video_zrtp_hash);

<bb 395>:
  D.41512 = session->channel;
  D.42505 = switch_channel_test_flag (D.41512, 109);
  if (D.42505 != 0)
    goto <bb 401>;
  else
    goto <bb 396>;

<bb 396>:
  D.41512 = session->channel;
  D.42507 = switch_channel_test_flag (D.41512, 92);
  if (D.42507 == 0)
    goto <bb 401>;
  else
    goto <bb 397>;

<bb 397>:
  D.42058 = smh->crypto_mode;
  if (D.42058 == 1)
    goto <bb 401>;
  else
    goto <bb 398>;

<bb 398>:
  D.42058 = smh->crypto_mode;
  if (D.42058 == 2)
    goto <bb 401>;
  else
    goto <bb 399>;

<bb 399>:
  loops = loops + 1;

<bb 400>:
  if (loops <= 1)
    goto <bb 243>;
  else
    goto <bb 401>;

<bb 401>:
  map.33 = map;
  if (map.33 != 0B)
    goto <bb 402>;
  else
    goto <bb 403>;

<bb 402>:
  switch_event_destroy (&map);

<bb 403>:
  ptmap.39 = ptmap;
  if (ptmap.39 != 0B)
    goto <bb 404>;
  else
    goto <bb 405>;

<bb 404>:
  switch_event_destroy (&ptmap);

<bb 405>:
  switch_core_media_set_local_sdp (session, buf, 1);
  if (buf != 0B)
    goto <bb 406>;
  else
    goto <bb 407>;

<bb 406>:
  free (buf);
  buf = 0B;

<bb 407>:
  return;

}



;; Function dtls_ok (dtls_ok)

Scope blocks:

{ Scope block #0 

}
Merging blocks 2 and 3
dtls_ok (struct switch_core_session_t * session)
{
  uint32_t D.42521;
  struct switch_channel_t * D.42520;
  int D.42519;

<bb 2>:
  D.42520 = session->channel;
  D.42521 = switch_channel_test_flag (D.42520, 111);
  D.42519 = (int) D.42521;
  return D.42519;

}



;; Function switch_core_session_parse_crypto_prefs (switch_core_session_parse_crypto_prefs)

Scope blocks:

{ Scope block #0 
  const char * var; (unused)
  const char * val; (unused)
  char * suites; (unused)
  struct switch_media_handle_t * smh; (unused)
  char * fields[10]; (unused)
  int argc; (unused)
  int i; (unused)
  int j; (unused)
  int k; (unused)
  static const char __func__[39] = "switch_core_session_parse_crypto_prefs"; (unused)

  { Scope block #0 
    int ok; (unused)

  }

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       45 (fallthru)
<bb 3>:
goto <bb 45>;


Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       45 (fallthru)
<bb 5>:
goto <bb 45>;


Removing basic block 41
;; basic block 41, loop depth 0, count 0
;; prev block 40, next block 42
;; pred:      
;; succ:       45 (fallthru)
<bb 41>:
goto <bb 45>;


switch_core_session_parse_crypto_prefs (struct switch_core_session_t * session)
{
  int ok;
  static const char __func__[39] = "switch_core_session_parse_crypto_prefs";
  int k;
  int j;
  int i;
  int argc;
  char * fields[10];
  struct switch_media_handle_t * smh;
  char * suites;
  const char * val;
  const char * var;
  switch_rtp_crypto_key_type_t D.42582;
  switch_rtp_crypto_key_type_t D.42579;
  int D.42576;
  char * D.42575;
  char * D.42574;
  unsigned int D.42573;
  int D.42571;
  switch_rtp_crypto_mode_t D.42569;
  int D.42565;
  int D.42562;
  int D.42561;
  int D.42559;
  int D.42552;
  uint32_t D.42550;
  switch_call_direction_t D.42548;
  int D.42543;
  int D.42540;
  int D.42535;
  switch_call_direction_t D.42529;
  uint32_t D.42526;
  struct switch_channel_t * D.42525;

<bb 2>:
  var = 0B;
  val = 0B;
  suites = 0B;
  argc = 0;
  i = 0;
  j = 0;
  k = 0;
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 42>;
  else
    goto <bb 3>;

<bb 3>:
  D.42525 = session->channel;
  D.42526 = switch_channel_test_flag (D.42525, 106);
  if (D.42526 != 0)
    goto <bb 42>;
  else
    goto <bb 4>;

<bb 4>:
  D.42525 = session->channel;
  D.42529 = switch_channel_direction (D.42525);
  if (D.42529 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  var = "rtp_secure_media_inbound";
  goto <bb 7>;

<bb 6>:
  var = "rtp_secure_media_outbound";

<bb 7>:
  D.42525 = session->channel;
  val = switch_channel_get_variable_dup (D.42525, var, 1, -1);
  if (val == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  var = "rtp_secure_media";
  D.42525 = session->channel;
  val = switch_channel_get_variable_dup (D.42525, var, 1, -1);

<bb 9>:
  D.42535 = _zstr (val);
  if (D.42535 == 0)
    goto <bb 10>;
  else
    goto <bb 12>;

<bb 10>:
  suites = __builtin_strchr (val, 58);
  if (suites != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  *suites = 0;
  suites = suites + 1;

<bb 12>:
  D.42540 = _zstr (suites);
  if (D.42540 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.42525 = session->channel;
  suites = switch_channel_get_variable_dup (D.42525, "rtp_secure_media_suites", 1, -1);

<bb 14>:
  D.42543 = _zstr (val);
  if (D.42543 != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

<bb 15>:
  D.42525 = session->channel;
  D.42548 = switch_channel_direction (D.42525);
  if (D.42548 == 0)
    goto <bb 16>;
  else
    goto <bb 18>;

<bb 16>:
  D.42525 = session->channel;
  D.42550 = switch_channel_test_flag (D.42525, 84);
  if (D.42550 == 0)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  val = "optional";
  goto <bb 19>;

<bb 18>:
  val = "forbidden";

<bb 19>:
  D.42552 = strcasecmp (val, "optional");
  if (D.42552 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  smh->crypto_mode = 0;
  goto <bb 27>;

<bb 21>:
  D.42559 = switch_true (val);
  if (D.42559 != 0)
    goto <bb 23>;
  else
    goto <bb 22>;

<bb 22>:
  D.42561 = strcasecmp (val, "mandatory");
  if (D.42561 == 0)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  smh->crypto_mode = 1;
  goto <bb 27>;

<bb 24>:
  smh->crypto_mode = 2;
  D.42562 = switch_false (val);
  if (D.42562 == 0)
    goto <bb 25>;
  else
    goto <bb 27>;

<bb 25>:
  D.42565 = strcasecmp (val, "forbidden");
  if (D.42565 != 0)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1123, session, 4, "INVALID VALUE FOR %s defaulting to \'forbidden\'\n", var);

<bb 27>:
  D.42569 = smh->crypto_mode;
  if (D.42569 != 2)
    goto <bb 28>;
  else
    goto <bb 39>;

<bb 28>:
  D.42571 = _zstr (suites);
  if (D.42571 == 0)
    goto <bb 29>;
  else
    goto <bb 39>;

<bb 29>:
  D.42573 = switch_separate_string (suites, 58, &fields, 10);
  argc = (int) D.42573;
  i = 0;
  goto <bb 38>;

<bb 30>:
  ok = 0;
  j = 0;
  goto <bb 34>;

<bb 31>:
  D.42574 = fields[i];
  D.42575 = SUITES[j].name;
  D.42576 = strcasecmp (D.42574, D.42575);
  if (D.42576 == 0)
    goto <bb 32>;
  else
    goto <bb 33>;

<bb 32>:
  D.42579 = SUITES[j].type;
  smh->crypto_suite_order[k] = D.42579;
  k = k + 1;
  ok = ok + 1;
  goto <bb 35>;

<bb 33>:
  j = j + 1;

<bb 34>:
  if (j <= 8)
    goto <bb 31>;
  else
    goto <bb 35>;

<bb 35>:
  if (ok == 0)
    goto <bb 36>;
  else
    goto <bb 37>;

<bb 36>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1142, session, 4, "INVALID SUITE SUPPLIED\n");

<bb 37>:
  i = i + 1;

<bb 38>:
  if (i < argc)
    goto <bb 30>;
  else
    goto <bb 42>;

<bb 39>:
  i = 0;
  goto <bb 41>;

<bb 40>:
  D.42582 = SUITES[i].type;
  smh->crypto_suite_order[k] = D.42582;
  k = k + 1;
  i = i + 1;

<bb 41>:
  if (i <= 8)
    goto <bb 40>;
  else
    goto <bb 42>;

<bb 42>:
  return;

}



;; Function generate_m (generate_m)

Scope blocks:

{ Scope block #0 
  int i; (unused)
  int rate; (unused)
  int already_did[128]; (unused)
  int ptime; (unused)
  int noptime; (unused)
  const char * local_sdp_audio_zrtp_hash; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  static const char __PRETTY_FUNCTION__[11] = "generate_m"; (unused)
  static const char __func__[11] = "generate_m"; (unused)

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)
    int this_ptime; (unused)

  }

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)
    char * fmtp; (unused)
    int this_ptime; (unused)

    { Scope block #0 
      char key[128]; (unused)
      char * check; (unused)

    }

    { Scope block #0 
      int channels; (unused)

    }

  }

  { Scope block #0 
    char tmp1[11]; (unused)
    char tmp2[11]; (unused)
    uint32_t c1; (unused)
    uint32_t c2; (unused)
    struct ice_t * ice_out; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

  }

  { Scope block #0 
    int i; (unused)

    { Scope block #0 
      switch_rtp_crypto_key_type_t j; (unused)

    }

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       124 (fallthru)
<bb 5>:
goto <bb 124>;


Removing basic block 21
;; basic block 21, loop depth 0, count 0
;; prev block 20, next block 22
;; pred:      
;; succ:       24 (fallthru)
<bb 21>:
goto <bb 24>;


Removing basic block 47
;; basic block 47, loop depth 0, count 0
;; prev block 46, next block 48
;; pred:      
;; succ:       50 (fallthru)
<bb 47>:
goto <bb 50>;


generate_m (struct switch_core_session_t * session, char * buf, size_t buflen, switch_port_t port, const char * family, const char * ip, int cur_ptime, const char * append_audio, const char * sr, int use_cng, int cng_type, struct switch_event_t * map, int secure, switch_sdp_type_t sdp_type)
{
  switch_rtp_crypto_key_type_t j;
  int i;
  size_t __s2_len;
  size_t __s1_len;
  size_t __s2_len;
  size_t __s1_len;
  struct ice_t * ice_out;
  uint32_t c2;
  uint32_t c1;
  char tmp2[11];
  char tmp1[11];
  int channels;
  char * check;
  char key[128];
  int this_ptime;
  char * fmtp;
  const struct switch_codec_implementation_t * imp;
  int this_ptime;
  const struct switch_codec_implementation_t * imp;
  static const char __func__[11] = "generate_m";
  static const char __PRETTY_FUNCTION__[11] = "generate_m";
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  const char * local_sdp_audio_zrtp_hash;
  int noptime;
  int ptime;
  int already_did[128];
  int rate;
  int i;
  size_t D.42921;
  size_t D.42920;
  char * D.42919;
  size_t D.42918;
  int D.42915;
  size_t D.42914;
  size_t D.42913;
  char * D.42912;
  size_t D.42911;
  size_t D.42908;
  size_t D.42907;
  char * D.42906;
  size_t D.42905;
  _Bool D.42902;
  _Bool D.42901;
  _Bool D.42900;
  const char D.42894;
  unsigned int D.42892;
  size_t D.42891;
  const char D.42888;
  const char * iftmp.42;
  char * iftmp.41;
  size_t D.42885;
  size_t D.42884;
  char * D.42883;
  size_t D.42882;
  size_t D.42879;
  size_t D.42878;
  char * D.42877;
  size_t D.42876;
  int32_t D.42873;
  size_t D.42870;
  size_t D.42869;
  char * D.42868;
  size_t D.42867;
  int D.42864;
  char * D.42863;
  switch_rtp_crypto_key_type_t D.42859;
  uint32_t D.42856;
  int D.42853;
  size_t D.42852;
  size_t D.42851;
  char * D.42850;
  size_t D.42849;
  switch_port_t D.42846;
  int D.39488;
  int D.42841;
  char * D.42840;
  int D.42837;
  int D.42836;
  int D.42835;
  size_t D.42834;
  size_t D.42833;
  char * D.42832;
  size_t D.42831;
  switch_call_direction_t D.42830;
  int D.42826;
  size_t D.42825;
  size_t D.42824;
  char * D.42823;
  size_t D.42822;
  switch_port_t D.42819;
  int D.39479;
  int D.42814;
  int D.42811;
  char * D.42810;
  int D.42809;
  switch_port_t D.42808;
  char * D.42807;
  char * D.42806;
  size_t D.42805;
  size_t D.42804;
  char * D.42803;
  size_t D.42802;
  char * D.42801;
  size_t D.42800;
  size_t D.42799;
  char * D.42798;
  size_t D.42797;
  char * D.42796;
  size_t D.42795;
  size_t D.42794;
  char * D.42793;
  size_t D.42792;
  size_t D.42791;
  size_t D.42790;
  char * D.42789;
  size_t D.42788;
  size_t D.42787;
  size_t D.42786;
  char * D.42785;
  size_t D.42784;
  char * D.42783;
  size_t D.42782;
  size_t D.42781;
  char * D.42780;
  size_t D.42779;
  char * D.42778;
  uint32_t D.42777;
  size_t D.42776;
  size_t D.42775;
  char * D.42774;
  size_t D.42773;
  uint8_t D.42770;
  int D.42769;
  size_t D.42768;
  size_t D.42767;
  char * D.42766;
  size_t D.42765;
  size_t D.42763;
  size_t D.42762;
  char * D.42761;
  size_t D.42760;
  size_t D.42759;
  size_t D.42758;
  char * D.42757;
  size_t D.42756;
  int8_t D.42753;
  char * D.42750;
  char[192] * D.42749;
  size_t D.42748;
  size_t D.42747;
  char * D.42746;
  size_t D.42745;
  int D.42740;
  char * D.42739;
  size_t D.42738;
  size_t D.42737;
  char * D.42736;
  size_t D.42735;
  size_t D.42733;
  size_t D.42732;
  char * D.42731;
  size_t D.42730;
  uint32_t D.42727;
  uint32_t D.42724;
  int32_t D.42722;
  size_t D.42718;
  size_t D.42717;
  char * D.42716;
  size_t D.42715;
  size_t D.42712;
  size_t D.42711;
  char * D.42710;
  size_t D.42709;
  size_t D.42707;
  size_t D.42706;
  char * D.42705;
  size_t D.42704;
  int D.42701;
  const uint8_t D.42700;
  uint32_t D.42699;
  char * D.42693;
  const int D.42689;
  const uint32_t D.42686;
  int D.42672;
  int D.42670;
  char * const D.42669;
  const switch_codec_type_t D.42664;
  const int D.42663;
  size_t D.42662;
  size_t D.42661;
  char * D.42660;
  size_t D.42659;
  size_t D.42658;
  size_t D.42657;
  char * D.42656;
  size_t D.42655;
  _Bool D.42652;
  _Bool D.42651;
  _Bool D.42650;
  int32_t D.42647;
  int D.42646;
  size_t D.42645;
  size_t D.42644;
  char * D.42643;
  size_t D.42642;
  switch_payload_t D.42639;
  switch_core_media_dtmf_t D.42636;
  int D.42635;
  struct switch_core_media_params_t * D.42634;
  size_t D.42633;
  size_t D.42632;
  char * D.42631;
  size_t D.42630;
  int D.42627;
  int D.42626;
  signed char D.42623;
  switch_payload_t D.42622;
  const switch_codec_type_t D.42610;
  int D.42609;
  int D.42607;
  char * const D.42606;
  const int D.42603;
  const char * D.42602;
  switch_rtp_crypto_key_type_t D.42601;
  switch_call_direction_t D.42600;
  struct switch_channel_t * D.42599;
  int iftmp.40;
  int D.42592;
  size_t D.42591;
  size_t D.42590;
  char * D.42589;
  size_t D.42588;

<bb 2>:
  i = 0;
  already_did = {};
  ptime = 0;
  noptime = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 5614, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 121>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  D.42588 = strlen (buf);
  D.42589 = buf + D.42588;
  D.42590 = strlen (buf);
  D.42591 = buflen - D.42590;
  D.42592 = (int) port;
  if (secure != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.42599 = session->channel;
  D.42600 = switch_channel_direction (D.42599);
  if (D.42600 == 1)
    goto <bb 8>;
  else
    goto <bb 7>;

<bb 7>:
  D.42601 = a_engine->crypto_type;
  if (D.42601 != 9)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  iftmp.40 = 1;
  goto <bb 10>;

<bb 9>:
  iftmp.40 = 0;

<bb 10>:
  D.42602 = get_media_profile_name (session, iftmp.40);
  switch_snprintf (D.42589, D.42591, "m=audio %d %s", D.42592, D.42602);
  i = 0;
  goto <bb 28>;

<bb 11>:
  imp = smh->codecs[i];
  D.42603 = imp->microseconds_per_packet;
  this_ptime = D.42603 / 1000;
  D.42606 = imp->iananame;
  D.42607 = strcasecmp (D.42606, "ilbc");
  if (D.42607 == 0)
    goto <bb 13>;
  else
    goto <bb 12>;

<bb 12>:
  D.42606 = imp->iananame;
  D.42609 = strcasecmp (D.42606, "isac");
  if (D.42609 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  this_ptime = 20;

<bb 14>:
  D.42610 = imp->codec_type;
  if (D.42610 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  // predicted unlikely by continue predictor.
  goto <bb 27>;

<bb 16>:
  if (noptime == 0)
    goto <bb 17>;
  else
    goto <bb 22>;

<bb 17>:
  if (cur_ptime == 0)
    goto <bb 18>;
  else
    goto <bb 20>;

<bb 18>:
  if (ptime == 0)
    goto <bb 19>;
  else
    goto <bb 22>;

<bb 19>:
  ptime = this_ptime;
  goto <bb 22>;

<bb 20>:
  if (this_ptime != cur_ptime)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  // predicted unlikely by continue predictor.
  goto <bb 27>;

<bb 22>:
  D.42622 = smh->ianacodes[i];
  D.42623 = (signed char) D.42622;
  if (D.42623 >= 0)
    goto <bb 23>;
  else
    goto <bb 26>;

<bb 23>:
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  D.42627 = already_did[D.42626];
  if (D.42627 != 0)
    goto <bb 24>;
  else
    goto <bb 25>;

<bb 24>:
  // predicted unlikely by continue predictor.
  goto <bb 27>;

<bb 25>:
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  already_did[D.42626] = 1;

<bb 26>:
  D.42630 = strlen (buf);
  D.42631 = buf + D.42630;
  D.42632 = strlen (buf);
  D.42633 = buflen - D.42632;
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  switch_snprintf (D.42631, D.42633, " %d", D.42626);

<bb 27>:
  i = i + 1;

<bb 28>:
  D.42634 = smh->mparams;
  D.42635 = D.42634->num_codecs;
  if (D.42635 > i)
    goto <bb 11>;
  else
    goto <bb 29>;

<bb 29>:
  D.42634 = smh->mparams;
  D.42636 = D.42634->dtmf_type;
  if (D.42636 == 0)
    goto <bb 30>;
  else
    goto <bb 32>;

<bb 30>:
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  if (D.42639 > 95)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  D.42642 = strlen (buf);
  D.42643 = buf + D.42642;
  D.42644 = strlen (buf);
  D.42645 = buflen - D.42644;
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  D.42646 = (int) D.42639;
  switch_snprintf (D.42643, D.42645, " %d", D.42646);

<bb 32>:
  D.42647 = switch_media_handle_test_media_flag (smh, 9);
  if (D.42647 == 0)
    goto <bb 33>;
  else
    goto <bb 35>;

<bb 33>:
  D.42650 = cng_type != 0;
  D.42651 = use_cng != 0;
  D.42652 = D.42650 && D.42651;
  if (D.42652 != 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  D.42655 = strlen (buf);
  D.42656 = buf + D.42655;
  D.42657 = strlen (buf);
  D.42658 = buflen - D.42657;
  switch_snprintf (D.42656, D.42658, " %d", cng_type);

<bb 35>:
  D.42659 = strlen (buf);
  D.42660 = buf + D.42659;
  D.42661 = strlen (buf);
  D.42662 = buflen - D.42661;
  switch_snprintf (D.42660, D.42662, "\n");
  memset (&already_did, 0, 512);
  i = 0;
  goto <bb 65>;

<bb 36>:
  imp = smh->codecs[i];
  fmtp = imp->fmtp;
  D.42663 = imp->microseconds_per_packet;
  this_ptime = D.42663 / 1000;
  D.42664 = imp->codec_type;
  if (D.42664 != 0)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  // predicted unlikely by continue predictor.
  goto <bb 64>;

<bb 38>:
  D.42669 = imp->iananame;
  D.42670 = strcasecmp (D.42669, "ilbc");
  if (D.42670 == 0)
    goto <bb 40>;
  else
    goto <bb 39>;

<bb 39>:
  D.42669 = imp->iananame;
  D.42672 = strcasecmp (D.42669, "isac");
  if (D.42672 == 0)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  this_ptime = 20;

<bb 41>:
  if (noptime == 0)
    goto <bb 42>;
  else
    goto <bb 47>;

<bb 42>:
  if (cur_ptime == 0)
    goto <bb 43>;
  else
    goto <bb 45>;

<bb 43>:
  if (ptime == 0)
    goto <bb 44>;
  else
    goto <bb 47>;

<bb 44>:
  ptime = this_ptime;
  goto <bb 47>;

<bb 45>:
  if (this_ptime != cur_ptime)
    goto <bb 46>;
  else
    goto <bb 47>;

<bb 46>:
  // predicted unlikely by continue predictor.
  goto <bb 64>;

<bb 47>:
  D.42622 = smh->ianacodes[i];
  D.42623 = (signed char) D.42622;
  if (D.42623 >= 0)
    goto <bb 48>;
  else
    goto <bb 51>;

<bb 48>:
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  D.42627 = already_did[D.42626];
  if (D.42627 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

<bb 49>:
  // predicted unlikely by continue predictor.
  goto <bb 64>;

<bb 50>:
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  already_did[D.42626] = 1;

<bb 51>:
  D.42686 = imp->samples_per_second;
  rate = (int) D.42686;
  if (map != 0B)
    goto <bb 52>;
  else
    goto <bb 55>;

<bb 52>:
  key = "";
  check = 0B;
  D.42669 = imp->iananame;
  D.42689 = imp->bits_per_second;
  switch_snprintf (&key, 128, "%s:%u", D.42669, D.42689);
  check = switch_event_get_header_idx (map, &key, -1);
  if (check != 0B)
    goto <bb 54>;
  else
    goto <bb 53>;

<bb 53>:
  D.42669 = imp->iananame;
  check = switch_event_get_header_idx (map, D.42669, -1);
  if (check != 0B)
    goto <bb 54>;
  else
    goto <bb 55>;

<bb 54>:
  fmtp = check;

<bb 55>:
  D.42693 = smh->fmtps[i];
  if (D.42693 != 0B)
    goto <bb 56>;
  else
    goto <bb 57>;

<bb 56>:
  fmtp = smh->fmtps[i];

<bb 57>:
  D.42622 = smh->ianacodes[i];
  if (D.42622 > 95)
    goto <bb 59>;
  else
    goto <bb 58>;

<bb 58>:
  D.42599 = session->channel;
  D.42699 = switch_channel_test_flag (D.42599, 110);
  if (D.42699 != 0)
    goto <bb 59>;
  else
    goto <bb 62>;

<bb 59>:
  D.42669 = imp->iananame;
  D.42700 = imp->number_of_channels;
  D.42701 = (int) D.42700;
  channels = get_channels (D.42669, D.42701);
  if (channels > 1)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  D.42704 = strlen (buf);
  D.42705 = buf + D.42704;
  D.42706 = strlen (buf);
  D.42707 = buflen - D.42706;
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  D.42669 = imp->iananame;
  switch_snprintf (D.42705, D.42707, "a=rtpmap:%d %s/%d/%d\n", D.42626, D.42669, rate, channels);
  goto <bb 62>;

<bb 61>:
  D.42709 = strlen (buf);
  D.42710 = buf + D.42709;
  D.42711 = strlen (buf);
  D.42712 = buflen - D.42711;
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  D.42669 = imp->iananame;
  switch_snprintf (D.42710, D.42712, "a=rtpmap:%d %s/%d\n", D.42626, D.42669, rate);

<bb 62>:
  if (fmtp != 0B)
    goto <bb 63>;
  else
    goto <bb 64>;

<bb 63>:
  D.42715 = strlen (buf);
  D.42716 = buf + D.42715;
  D.42717 = strlen (buf);
  D.42718 = buflen - D.42717;
  D.42622 = smh->ianacodes[i];
  D.42626 = (int) D.42622;
  switch_snprintf (D.42716, D.42718, "a=fmtp:%d %s\n", D.42626, fmtp);

<bb 64>:
  i = i + 1;

<bb 65>:
  D.42634 = smh->mparams;
  D.42635 = D.42634->num_codecs;
  if (D.42635 > i)
    goto <bb 36>;
  else
    goto <bb 66>;

<bb 66>:
  D.42634 = smh->mparams;
  D.42636 = D.42634->dtmf_type;
  if (D.42636 == 0)
    goto <bb 69>;
  else
    goto <bb 67>;

<bb 67>:
  D.42722 = switch_media_handle_test_media_flag (smh, 8);
  if (D.42722 != 0)
    goto <bb 69>;
  else
    goto <bb 68>;

<bb 68>:
  D.42599 = session->channel;
  D.42724 = switch_channel_test_flag (D.42599, 93);
  if (D.42724 != 0)
    goto <bb 69>;
  else
    goto <bb 73>;

<bb 69>:
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  if (D.42639 > 95)
    goto <bb 70>;
  else
    goto <bb 73>;

<bb 70>:
  D.42599 = session->channel;
  D.42727 = switch_channel_test_flag (D.42599, 106);
  if (D.42727 != 0)
    goto <bb 71>;
  else
    goto <bb 72>;

<bb 71>:
  D.42730 = strlen (buf);
  D.42731 = buf + D.42730;
  D.42732 = strlen (buf);
  D.42733 = buflen - D.42732;
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  D.42646 = (int) D.42639;
  switch_snprintf (D.42731, D.42733, "a=rtpmap:%d telephone-event/8000\n", D.42646);
  goto <bb 73>;

<bb 72>:
  D.42735 = strlen (buf);
  D.42736 = buf + D.42735;
  D.42737 = strlen (buf);
  D.42738 = buflen - D.42737;
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  D.42646 = (int) D.42639;
  D.42634 = smh->mparams;
  D.42639 = D.42634->te;
  D.42646 = (int) D.42639;
  switch_snprintf (D.42736, D.42738, "a=rtpmap:%d telephone-event/8000\na=fmtp:%d 0-16\n", D.42646, D.42646);

<bb 73>:
  D.42739 = a_engine->local_dtls_fingerprint.type;
  D.42740 = _zstr (D.42739);
  if (D.42740 == 0)
    goto <bb 74>;
  else
    goto <bb 76>;

<bb 74>:
  if (secure != 0)
    goto <bb 75>;
  else
    goto <bb 76>;

<bb 75>:
  D.42745 = strlen (buf);
  D.42746 = buf + D.42745;
  D.42747 = strlen (buf);
  D.42748 = buflen - D.42747;
  D.42739 = a_engine->local_dtls_fingerprint.type;
  D.42749 = &a_engine->local_dtls_fingerprint.str;
  switch_snprintf (D.42746, D.42748, "a=fingerprint:%s %s\n", D.42739, D.42749);

<bb 76>:
  D.42634 = smh->mparams;
  D.42750 = D.42634->rtcp_audio_interval_msec;
  if (D.42750 != 0B)
    goto <bb 77>;
  else
    goto <bb 80>;

<bb 77>:
  D.42753 = a_engine->rtcp_mux;
  if (D.42753 > 0)
    goto <bb 78>;
  else
    goto <bb 79>;

<bb 78>:
  D.42756 = strlen (buf);
  D.42757 = buf + D.42756;
  D.42758 = strlen (buf);
  D.42759 = buflen - D.42758;
  switch_snprintf (D.42757, D.42759, "a=rtcp-mux\n");
  D.42760 = strlen (buf);
  D.42761 = buf + D.42760;
  D.42762 = strlen (buf);
  D.42763 = buflen - D.42762;
  D.42592 = (int) port;
  switch_snprintf (D.42761, D.42763, "a=rtcp:%d IN %s %s\n", D.42592, family, ip);
  goto <bb 80>;

<bb 79>:
  D.42765 = strlen (buf);
  D.42766 = buf + D.42765;
  D.42767 = strlen (buf);
  D.42768 = buflen - D.42767;
  D.42592 = (int) port;
  D.42769 = D.42592 + 1;
  switch_snprintf (D.42766, D.42768, "a=rtcp:%d IN %s %s\n", D.42769, family, ip);

<bb 80>:
  D.42770 = a_engine->ice_out.cands[0][0].ready;
  if (D.42770 != 0)
    goto <bb 81>;
  else
    goto <bb 93>;

<bb 81>:
  tmp1 = "";
  tmp2 = "";
  c1 = 659136;
  c2 = 659134;
  tmp1[10] = 0;
  tmp2[10] = 0;
  switch_stun_random_string (&tmp1, 10, "0123456789");
  switch_stun_random_string (&tmp2, 10, "0123456789");
  gen_ice (session, 0, 0B, 0);
  ice_out = &a_engine->ice_out;
  D.42773 = strlen (buf);
  D.42774 = buf + D.42773;
  D.42775 = strlen (buf);
  D.42776 = buflen - D.42775;
  D.42777 = a_engine->ssrc;
  D.42778 = smh->cname;
  switch_snprintf (D.42774, D.42776, "a=ssrc:%u cname:%s\n", D.42777, D.42778);
  D.42779 = strlen (buf);
  D.42780 = buf + D.42779;
  D.42781 = strlen (buf);
  D.42782 = buflen - D.42781;
  D.42777 = a_engine->ssrc;
  D.42783 = smh->msid;
  switch_snprintf (D.42780, D.42782, "a=ssrc:%u msid:%s a0\n", D.42777, D.42783);
  D.42784 = strlen (buf);
  D.42785 = buf + D.42784;
  D.42786 = strlen (buf);
  D.42787 = buflen - D.42786;
  D.42777 = a_engine->ssrc;
  D.42783 = smh->msid;
  switch_snprintf (D.42785, D.42787, "a=ssrc:%u mslabel:%s\n", D.42777, D.42783);
  D.42788 = strlen (buf);
  D.42789 = buf + D.42788;
  D.42790 = strlen (buf);
  D.42791 = buflen - D.42790;
  D.42777 = a_engine->ssrc;
  D.42783 = smh->msid;
  switch_snprintf (D.42789, D.42791, "a=ssrc:%u label:%sa0\n", D.42777, D.42783);
  D.42792 = strlen (buf);
  D.42793 = buf + D.42792;
  D.42794 = strlen (buf);
  D.42795 = buflen - D.42794;
  D.42796 = ice_out->ufrag;
  switch_snprintf (D.42793, D.42795, "a=ice-ufrag:%s\n", D.42796);
  D.42797 = strlen (buf);
  D.42798 = buf + D.42797;
  D.42799 = strlen (buf);
  D.42800 = buflen - D.42799;
  D.42801 = ice_out->pwd;
  switch_snprintf (D.42798, D.42800, "a=ice-pwd:%s\n", D.42801);
  D.42802 = strlen (buf);
  D.42803 = buf + D.42802;
  D.42804 = strlen (buf);
  D.42805 = buflen - D.42804;
  D.42806 = ice_out->cands[0][0].transport;
  D.42807 = ice_out->cands[0][0].con_addr;
  D.42808 = ice_out->cands[0][0].con_port;
  D.42809 = (int) D.42808;
  switch_snprintf (D.42803, D.42805, "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", &tmp1, D.42806, c1, D.42807, D.42809);
  D.42810 = a_engine->local_sdp_ip;
  D.42811 = _zstr (D.42810);
  if (D.42811 == 0)
    goto <bb 82>;
  else
    goto <bb 86>;

<bb 82>:
  D.42807 = ice_out->cands[0][0].con_addr;
  D.42814 = _zstr (D.42807);
  if (D.42814 == 0)
    goto <bb 83>;
  else
    goto <bb 86>;

<bb 83>:
  D.42810 = a_engine->local_sdp_ip;
  D.42807 = ice_out->cands[0][0].con_addr;
  D.39479 = __builtin_strcmp (D.42810, D.42807);
  if (D.39479 != 0)
    goto <bb 84>;
  else
    goto <bb 86>;

<bb 84>:
  D.42819 = a_engine->local_sdp_port;
  D.42808 = ice_out->cands[0][0].con_port;
  if (D.42819 != D.42808)
    goto <bb 85>;
  else
    goto <bb 86>;

<bb 85>:
  D.42822 = strlen (buf);
  D.42823 = buf + D.42822;
  D.42824 = strlen (buf);
  D.42825 = buflen - D.42824;
  D.42806 = ice_out->cands[0][0].transport;
  D.42807 = ice_out->cands[0][0].con_addr;
  D.42808 = ice_out->cands[0][0].con_port;
  D.42809 = (int) D.42808;
  D.42810 = a_engine->local_sdp_ip;
  D.42819 = a_engine->local_sdp_port;
  D.42826 = (int) D.42819;
  switch_snprintf (D.42823, D.42825, "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", &tmp2, D.42806, c2, D.42807, D.42809, D.42810, D.42826);

<bb 86>:
  D.42753 = a_engine->rtcp_mux;
  if (D.42753 <= 0)
    goto <bb 88>;
  else
    goto <bb 87>;

<bb 87>:
  D.42599 = session->channel;
  D.42830 = switch_channel_direction (D.42599);
  if (D.42830 == 1)
    goto <bb 88>;
  else
    goto <bb 93>;

<bb 88>:
  D.42831 = strlen (buf);
  D.42832 = buf + D.42831;
  D.42833 = strlen (buf);
  D.42834 = buflen - D.42833;
  D.42806 = ice_out->cands[0][0].transport;
  D.42807 = ice_out->cands[0][0].con_addr;
  D.42808 = ice_out->cands[0][0].con_port;
  D.42809 = (int) D.42808;
  D.42753 = a_engine->rtcp_mux;
  D.42835 = D.42753 <= 0;
  D.42836 = D.42809 + D.42835;
  switch_snprintf (D.42832, D.42834, "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", &tmp1, D.42806, c1, D.42807, D.42836);
  D.42810 = a_engine->local_sdp_ip;
  D.42837 = _zstr (D.42810);
  if (D.42837 == 0)
    goto <bb 89>;
  else
    goto <bb 93>;

<bb 89>:
  D.42840 = ice_out->cands[0][1].con_addr;
  D.42841 = _zstr (D.42840);
  if (D.42841 == 0)
    goto <bb 90>;
  else
    goto <bb 93>;

<bb 90>:
  D.42810 = a_engine->local_sdp_ip;
  D.42840 = ice_out->cands[0][1].con_addr;
  D.39488 = __builtin_strcmp (D.42810, D.42840);
  if (D.39488 != 0)
    goto <bb 91>;
  else
    goto <bb 93>;

<bb 91>:
  D.42819 = a_engine->local_sdp_port;
  D.42846 = ice_out->cands[0][1].con_port;
  if (D.42819 != D.42846)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  D.42849 = strlen (buf);
  D.42850 = buf + D.42849;
  D.42851 = strlen (buf);
  D.42852 = buflen - D.42851;
  D.42806 = ice_out->cands[0][0].transport;
  D.42807 = ice_out->cands[0][0].con_addr;
  D.42808 = ice_out->cands[0][0].con_port;
  D.42809 = (int) D.42808;
  D.42753 = a_engine->rtcp_mux;
  D.42835 = D.42753 <= 0;
  D.42836 = D.42809 + D.42835;
  D.42810 = a_engine->local_sdp_ip;
  D.42819 = a_engine->local_sdp_port;
  D.42826 = (int) D.42819;
  D.42753 = a_engine->rtcp_mux;
  D.42835 = D.42753 <= 0;
  D.42853 = D.42826 + D.42835;
  switch_snprintf (D.42850, D.42852, "a=candidate:%s 2 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", &tmp2, D.42806, c2, D.42807, D.42836, D.42810, D.42853);

<bb 93>:
  if (secure != 0)
    goto <bb 94>;
  else
    goto <bb 102>;

<bb 94>:
  D.42599 = session->channel;
  D.42856 = switch_channel_test_flag (D.42599, 109);
  if (D.42856 == 0)
    goto <bb 95>;
  else
    goto <bb 102>;

<bb 95>:
  i = 0;
  goto <bb 101>;

<bb 96>:
  D.42859 = smh->crypto_suite_order[i];
  j = SUITES[D.42859].type;
  D.42601 = a_engine->crypto_type;
  if (D.42601 == j)
    goto <bb 98>;
  else
    goto <bb 97>;

<bb 97>:
  D.42601 = a_engine->crypto_type;
  if (D.42601 == 9)
    goto <bb 98>;
  else
    goto <bb 100>;

<bb 98>:
  D.42863 = a_engine->ssec[j].local_crypto_key;
  D.42864 = _zstr (D.42863);
  if (D.42864 == 0)
    goto <bb 99>;
  else
    goto <bb 100>;

<bb 99>:
  D.42867 = strlen (buf);
  D.42868 = buf + D.42867;
  D.42869 = strlen (buf);
  D.42870 = buflen - D.42869;
  D.42863 = a_engine->ssec[j].local_crypto_key;
  switch_snprintf (D.42868, D.42870, "a=crypto:%s\n", D.42863);

<bb 100>:
  i = i + 1;

<bb 101>:
  D.42859 = smh->crypto_suite_order[i];
  if (D.42859 != 9)
    goto <bb 96>;
  else
    goto <bb 102>;

<bb 102>:
  if (cng_type == 0)
    goto <bb 103>;
  else
    goto <bb 105>;

<bb 103>:
  D.42873 = switch_media_handle_test_media_flag (smh, 9);
  if (D.42873 != 0)
    goto <bb 104>;
  else
    goto <bb 105>;

<bb 104>:
  D.42876 = strlen (buf);
  D.42877 = buf + D.42876;
  D.42878 = strlen (buf);
  D.42879 = buflen - D.42878;
  switch_snprintf (D.42877, D.42879, "a=silenceSupp:off - - - -\n");

<bb 105>:
  if (append_audio != 0B)
    goto <bb 106>;
  else
    goto <bb 113>;

<bb 106>:
  D.42882 = strlen (buf);
  D.42883 = buf + D.42882;
  D.42884 = strlen (buf);
  D.42885 = buflen - D.42884;
  D.42888 = *append_audio;
  if (D.42888 != 0)
    goto <bb 107>;
  else
    goto <bb 108>;

<bb 107>:
  D.42891 = strlen (append_audio);
  D.42892 = D.42891 + -1;
  iftmp.42 = append_audio + D.42892;
  goto <bb 109>;

<bb 108>:
  iftmp.42 = append_audio;

<bb 109>:
  D.42894 = *iftmp.42;
  if (D.42894 == 10)
    goto <bb 110>;
  else
    goto <bb 111>;

<bb 110>:
  iftmp.41 = "";
  goto <bb 112>;

<bb 111>:
  iftmp.41 = "\n";

<bb 112>:
  switch_snprintf (D.42883, D.42885, "%s%s", append_audio, iftmp.41);

<bb 113>:
  if (cur_ptime == 0)
    goto <bb 114>;
  else
    goto <bb 115>;

<bb 114>:
  cur_ptime = ptime;

<bb 115>:
  D.42900 = noptime == 0;
  D.42901 = cur_ptime != 0;
  D.42902 = D.42900 && D.42901;
  if (D.42902 != 0)
    goto <bb 116>;
  else
    goto <bb 117>;

<bb 116>:
  D.42905 = strlen (buf);
  D.42906 = buf + D.42905;
  D.42907 = strlen (buf);
  D.42908 = buflen - D.42907;
  switch_snprintf (D.42906, D.42908, "a=ptime:%d\n", cur_ptime);

<bb 117>:
  local_sdp_audio_zrtp_hash = switch_core_media_get_zrtp_hash (session, 0, 1);
  if (local_sdp_audio_zrtp_hash != 0B)
    goto <bb 118>;
  else
    goto <bb 119>;

<bb 118>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5882, session, 7, "Adding audio a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
  D.42911 = strlen (buf);
  D.42912 = buf + D.42911;
  D.42913 = strlen (buf);
  D.42914 = buflen - D.42913;
  switch_snprintf (D.42912, D.42914, "a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);

<bb 119>:
  D.42915 = _zstr (sr);
  if (D.42915 == 0)
    goto <bb 120>;
  else
    goto <bb 121>;

<bb 120>:
  D.42918 = strlen (buf);
  D.42919 = buf + D.42918;
  D.42920 = strlen (buf);
  D.42921 = buflen - D.42920;
  switch_snprintf (D.42919, D.42921, "a=%s\n", sr);

<bb 121>:
  return;

}



;; Function gen_ice (gen_ice)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  char tmp[33]; (unused)
  static const char __PRETTY_FUNCTION__[8] = "gen_ice"; (unused)
  static const char __func__[8] = "gen_ice"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       25 (fallthru)
<bb 5>:
goto <bb 25>;


gen_ice (struct switch_core_session_t * session, switch_media_type_t type, const char * ip, switch_port_t port)
{
  static const char __func__[8] = "gen_ice";
  static const char __PRETTY_FUNCTION__[8] = "gen_ice";
  char tmp[33];
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  char * D.42961;
  int D.42958;
  uint32_t D.42957;
  int D.42956;
  int D.42955;
  int D.42952;
  char * D.42951;
  char * D.42948;
  char * D.42947;
  char * D.42944;
  char * D.42943;
  char * D.42940;
  char * D.42939;
  char * D.42936;
  char * D.42935;
  char * D.42932;
  int8_t D.42929;
  unsigned int D.42928;
  struct switch_rtp_engine_t[2] * D.42927;

<bb 2>:
  tmp = "";
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4608, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 24>;
  else
    goto <bb 5>;

<bb 5>:
  D.42927 = &smh->engines;
  D.42928 = type * 11416;
  engine = D.42927 + D.42928;
  D.42929 = engine->rtcp_mux;
  if (D.42929 == 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  engine->rtcp_mux = 1;

<bb 7>:
  D.42932 = smh->msid;
  if (D.42932 == 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  switch_stun_random_string (&tmp, 32, 0B);
  tmp[32] = 0;
  D.42935 = switch_core_perform_session_strdup (session, &tmp, "src/switch_core_media.c", &__func__, 4625);
  smh->msid = D.42935;

<bb 9>:
  D.42936 = smh->cname;
  if (D.42936 == 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  switch_stun_random_string (&tmp, 16, 0B);
  tmp[16] = 0;
  D.42939 = switch_core_perform_session_strdup (session, &tmp, "src/switch_core_media.c", &__func__, 4631);
  smh->cname = D.42939;

<bb 11>:
  D.42940 = engine->ice_out.ufrag;
  if (D.42940 == 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  switch_stun_random_string (&tmp, 16, 0B);
  tmp[16] = 0;
  D.42943 = switch_core_perform_session_strdup (session, &tmp, "src/switch_core_media.c", &__func__, 4637);
  engine->ice_out.ufrag = D.42943;

<bb 13>:
  D.42944 = engine->ice_out.pwd;
  if (D.42944 == 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  switch_stun_random_string (&tmp, 16, 0B);
  D.42947 = switch_core_perform_session_strdup (session, &tmp, "src/switch_core_media.c", &__func__, 4642);
  engine->ice_out.pwd = D.42947;

<bb 15>:
  D.42948 = engine->ice_out.cands[0][0].foundation;
  if (D.42948 == 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  switch_stun_random_string (&tmp, 10, "0123456789");
  tmp[10] = 0;
  D.42951 = switch_core_perform_session_strdup (session, &tmp, "src/switch_core_media.c", &__func__, 4648);
  engine->ice_out.cands[0][0].foundation = D.42951;

<bb 17>:
  engine->ice_out.cands[0][0].transport = "udp";
  D.42952 = engine->ice_out.cands[0][0].component_id;
  if (D.42952 == 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  engine->ice_out.cands[0][0].component_id = 1;
  D.42952 = engine->ice_out.cands[0][0].component_id;
  D.42955 = 329569 - D.42952;
  D.42956 = D.42955 * 2;
  D.42957 = (uint32_t) D.42956;
  engine->ice_out.cands[0][0].priority = D.42957;

<bb 19>:
  D.42958 = _zstr (ip);
  if (D.42958 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.42961 = switch_core_perform_session_strdup (session, ip, "src/switch_core_media.c", &__func__, 4659);
  engine->ice_out.cands[0][0].con_addr = D.42961;

<bb 21>:
  if (port != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  engine->ice_out.cands[0][0].con_port = port;

<bb 23>:
  engine->ice_out.cands[0][0].generation = "0";
  engine->ice_out.cands[0][0].ready = 1;

<bb 24>:
  return;

}



;; Function get_media_profile_name (get_media_profile_name)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[23] = "get_media_profile_name"; (unused)

}
get_media_profile_name (struct switch_core_session_t * session, int secure)
{
  static const char __PRETTY_FUNCTION__[23] = "get_media_profile_name";
  const char * D.42974;
  uint32_t D.42971;
  uint32_t D.42968;
  struct switch_channel_t * D.42967;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 5582, &__PRETTY_FUNCTION__);

<bb 4>:
  D.42967 = session->channel;
  D.42968 = switch_channel_test_flag (D.42967, 106);
  if (D.42968 != 0)
    goto <bb 5>;
  else
    goto <bb 8>;

<bb 5>:
  D.42967 = session->channel;
  D.42971 = switch_channel_test_flag (D.42967, 107);
  if (D.42971 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.42974 = "UDP/TLS/RTP/SAVPF";
  goto <bb 11>;

<bb 7>:
  D.42974 = "RTP/SAVPF";
  goto <bb 11>;

<bb 8>:
  if (secure != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.42974 = "RTP/SAVP";
  goto <bb 11>;

<bb 10>:
  D.42974 = "RTP/AVP";

<bb 11>:
  return D.42974;

}



;; Function get_channels (get_channels)

Scope blocks:

{ Scope block #0 

}
get_channels (const char * name, int dft)
{
  int iftmp.43;
  int D.42985;
  int D.42982;
  int D.42979;
  char * D.42978;

<bb 2>:
  D.42978 = switch_core_get_variable ("NDLB_broken_opus_sdp");
  D.42979 = switch_true (D.42978);
  if (D.42979 == 0)
    goto <bb 3>;
  else
    goto <bb 5>;

<bb 3>:
  D.42982 = strcasecmp (name, "opus");
  if (D.42982 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  D.42985 = 2;
  goto <bb 9>;

<bb 5>:
  if (dft != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  iftmp.43 = dft;
  goto <bb 8>;

<bb 7>:
  iftmp.43 = 1;

<bb 8>:
  D.42985 = iftmp.43;

<bb 9>:
  return D.42985;

}



;; Function generate_local_fingerprint (generate_local_fingerprint)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)

}
generate_local_fingerprint (struct switch_media_handle_t * smh, switch_media_type_t type)
{
  struct switch_rtp_engine_t * engine;
  struct dtls_fingerprint_t * D.43000;
  char * D.42996;
  uint32_t D.42993;
  unsigned int D.42992;
  struct switch_rtp_engine_t[2] * D.42991;

<bb 2>:
  D.42991 = &smh->engines;
  D.42992 = type * 11416;
  engine = D.42991 + D.42992;
  D.42993 = engine->local_dtls_fingerprint.len;
  if (D.42993 == 0)
    goto <bb 3>;
  else
    goto <bb 7>;

<bb 3>:
  D.42996 = engine->remote_dtls_fingerprint.type;
  if (D.42996 != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  D.42996 = engine->remote_dtls_fingerprint.type;
  engine->local_dtls_fingerprint.type = D.42996;
  goto <bb 6>;

<bb 5>:
  engine->local_dtls_fingerprint.type = "sha-256";

<bb 6>:
  D.43000 = &engine->local_dtls_fingerprint;
  switch_core_cert_gen_fingerprint ("dtls-srtp", D.43000);

<bb 7>:
  return;

}



;; Function switch_core_media_set_local_sdp (switch_core_media_set_local_sdp)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_set_local_sdp"; (unused)
  static const char __func__[32] = "switch_core_media_set_local_sdp"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       13 (fallthru)
<bb 5>:
goto <bb 13>;


switch_core_media_set_local_sdp (struct switch_core_session_t * session, const char * sdp_str, switch_bool_t dup)
{
  static const char __func__[32] = "switch_core_media_set_local_sdp";
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_set_local_sdp";
  struct switch_media_handle_t * smh;
  char * D.43014;
  struct switch_channel_t * D.43013;
  char * iftmp.44;
  struct switch_core_media_params_t * D.43008;
  struct switch_mutex_t * D.43005;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 5978, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 12>;
  else
    goto <bb 5>;

<bb 5>:
  D.43005 = smh->sdp_mutex;
  if (D.43005 != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.43005 = smh->sdp_mutex;
  switch_mutex_lock (D.43005);

<bb 7>:
  D.43008 = smh->mparams;
  if (dup != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  iftmp.44 = switch_core_perform_session_strdup (session, sdp_str, "src/switch_core_media.c", &__func__, 5985);
  goto <bb 10>;

<bb 9>:
  iftmp.44 = sdp_str;

<bb 10>:
  D.43008->local_sdp_str = iftmp.44;
  D.43013 = session->channel;
  D.43008 = smh->mparams;
  D.43014 = D.43008->local_sdp_str;
  switch_channel_set_variable_var_check (D.43013, "rtp_local_sdp_str", D.43014, 1);
  D.43005 = smh->sdp_mutex;
  if (D.43005 != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.43005 = smh->sdp_mutex;
  switch_mutex_unlock (D.43005);

<bb 12>:
  return;

}



;; Function switch_core_media_sdp_map (switch_core_media_sdp_map)

Scope blocks:

{ Scope block #0 
  struct sdp_media_t * m; (unused)
  struct sdp_parser_t * parser; (unused)
  struct sdp_session_t * sdp; (unused)
  static const char __func__[26] = "switch_core_media_sdp_map"; (unused)

  { Scope block #0 
    struct sdp_rtpmap_t * map; (unused)

    { Scope block #0 
      char buf[25]; (unused)
      char key[128]; (unused)
      char * br; (unused)

    }

  }

}
switch_core_media_sdp_map (const char * r_sdp, struct switch_event_t * * fmtp, struct switch_event_t * * pt)
{
  char * br;
  char key[128];
  char buf[25];
  struct sdp_rtpmap_t * map;
  static const char __func__[26] = "switch_core_media_sdp_map";
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  struct sdp_media_t * m;
  struct switch_event_t * D.43044;
  struct switch_event_t * D.43041;
  int D.43037;
  <unnamed-unsigned:7> D.43036;
  const char * D.43031;
  const char * D.43028;
  sdp_proto_e D.43025;
  switch_status_t D.43022;
  int D.43019;
  size_t D.43018;

<bb 2>:
  parser = 0B;
  D.43018 = strlen (r_sdp);
  D.43019 = (int) D.43018;
  parser = sdp_parse (0B, r_sdp, D.43019, 0);
  if (parser == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.43022 = 1;
  goto <bb 23>;

<bb 4>:
  sdp = sdp_session (parser);
  if (sdp == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  sdp_parser_free (parser);
  D.43022 = 1;
  goto <bb 23>;

<bb 6>:
  switch_event_create_subclass_detailed ("src/switch_core_media.c", &__func__, 5930, fmtp, 62, 0B);
  switch_event_create_subclass_detailed ("src/switch_core_media.c", &__func__, 5931, pt, 62, 0B);
  m = sdp->sdp_media;
  goto <bb 21>;

<bb 7>:
  D.43025 = m->m_proto;
  if (D.43025 == 256)
    goto <bb 8>;
  else
    goto <bb 20>;

<bb 8>:
  map = m->m_rtpmaps;
  goto <bb 19>;

<bb 9>:
  D.43028 = map->rm_encoding;
  if (D.43028 != 0B)
    goto <bb 10>;
  else
    goto <bb 18>;

<bb 10>:
  buf = "";
  key = "";
  br = 0B;
  D.43031 = map->rm_fmtp;
  if (D.43031 != 0B)
    goto <bb 11>;
  else
    goto <bb 13>;

<bb 11>:
  D.43031 = map->rm_fmtp;
  br = strstr (D.43031, "bitrate=");
  if (br != 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  br = br + 8;

<bb 13>:
  D.43036 = map->rm_pt;
  D.43037 = (int) D.43036;
  switch_snprintf (&buf, 25, "%d", D.43037);
  if (br != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.43028 = map->rm_encoding;
  switch_snprintf (&key, 128, "%s:%s", D.43028, br);
  goto <bb 16>;

<bb 15>:
  D.43028 = map->rm_encoding;
  switch_snprintf (&key, 128, "%s", D.43028);

<bb 16>:
  D.43041 = *pt;
  switch_event_add_header_string (D.43041, 1, &key, &buf);
  D.43031 = map->rm_fmtp;
  if (D.43031 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.43044 = *fmtp;
  D.43031 = map->rm_fmtp;
  switch_event_add_header_string (D.43044, 1, &key, D.43031);

<bb 18>:
  map = map->rm_next;

<bb 19>:
  if (map != 0B)
    goto <bb 9>;
  else
    goto <bb 20>;

<bb 20>:
  m = m->m_next;

<bb 21>:
  if (m != 0B)
    goto <bb 7>;
  else
    goto <bb 22>;

<bb 22>:
  sdp_parser_free (parser);
  D.43022 = 0;

<bb 23>:
  return D.43022;

}



;; Function switch_core_media_check_dtmf_type (switch_core_media_check_dtmf_type)

Scope blocks:

{ Scope block #0 
  const char * val; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_check_dtmf_type"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       13 (fallthru)
<bb 5>:
goto <bb 13>;


switch_core_media_check_dtmf_type (struct switch_core_session_t * session)
{
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_check_dtmf_type";
  struct switch_media_handle_t * smh;
  const char * val;
  int D.43062;
  int D.43058;
  struct switch_core_media_params_t * D.43056;
  int D.43053;
  struct switch_channel_t * D.43050;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 5897, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 12>;
  else
    goto <bb 5>;

<bb 5>:
  D.43050 = session->channel;
  val = switch_channel_get_variable_dup (D.43050, "dtmf_type", 1, -1);
  if (val != 0B)
    goto <bb 6>;
  else
    goto <bb 12>;

<bb 6>:
  D.43053 = strcasecmp (val, "rfc2833");
  if (D.43053 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.43056 = smh->mparams;
  D.43056->dtmf_type = 0;
  goto <bb 12>;

<bb 8>:
  D.43058 = strcasecmp (val, "info");
  if (D.43058 == 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.43056 = smh->mparams;
  D.43056->dtmf_type = 1;
  goto <bb 12>;

<bb 10>:
  D.43062 = strcasecmp (val, "none");
  if (D.43062 == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.43056 = smh->mparams;
  D.43056->dtmf_type = 2;

<bb 12>:
  return;

}



;; Function switch_core_media_activate_rtp (switch_core_media_activate_rtp)

Scope blocks:

{ Scope block #0 
  const char * err; (unused)
  const char * val; (unused)
  switch_rtp_flag_t flags[39]; (unused)
  switch_status_t status; (unused)
  char tmp[50]; (unused)
  char * timer_name; (unused)
  const char * var; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_activate_rtp"; (unused)
  void end = <<< error >>>; (unused)
  void video = <<< error >>>; (unused)
  static const char __func__[31] = "switch_core_media_activate_rtp"; (unused)
  void video_up = <<< error >>>; (unused)

  { Scope block #0 
    char * remote_host; (unused)
    switch_port_t remote_port; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

  }

  { Scope block #0 
    const char * rport; (unused)
    switch_port_t remote_rtcp_port; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

      { Scope block #0 
        const unsigned char * __s1; (unused)
        register int __result; (unused)

      }

    }

  }

  { Scope block #0 
    uint8_t vad_in; (unused)
    uint8_t vad_out; (unused)
    uint8_t inb; (unused)
    const char * ssrc; (unused)

    { Scope block #0 
      uint32_t ssrc_ul; (unused)

    }

    { Scope block #0 
      const char * rport; (unused)
      switch_port_t remote_rtcp_port; (unused)

      { Scope block #0 
        int interval; (unused)

      }

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

      }

    }

    { Scope block #0 
      dtls_type_t xtype; (unused)
      dtls_type_t dtype; (unused)

    }

    { Scope block #0 
      int jb_msec; (unused)
      int maxlen; (unused)
      int max_drift; (unused)
      char * p; (unused)
      char * q; (unused)

      { Scope block #0 
        int qlen; (unused)
        int maxqlen; (unused)

      }

    }

    { Scope block #0 
      int v; (unused)

    }

    { Scope block #0 
      int v; (unused)

    }

    { Scope block #0 
      int delayi; (unused)

    }

    { Scope block #0 
      char * remote_host; (unused)
      switch_port_t remote_port; (unused)

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

      }

    }

    { Scope block #0 
      const char * rport; (unused)
      switch_port_t remote_rtcp_port; (unused)

    }

    { Scope block #0 
      const char * ssrc; (unused)

      { Scope block #0 
        uint32_t ssrc_ul; (unused)

      }

      { Scope block #0 
        const char * rport; (unused)
        switch_port_t remote_port; (unused)

        { Scope block #0 
          int interval; (unused)

        }

        { Scope block #0 
          size_t __s1_len; (unused)
          size_t __s2_len; (unused)

        }

      }

      { Scope block #0 
        dtls_type_t xtype; (unused)
        dtls_type_t dtype; (unused)

      }

    }

  }

}
Removing basic block 81
;; basic block 81, loop depth 0, count 0
;; prev block 80, next block 82
;; pred:      
;; succ:       220 (fallthru)
<bb 81>:
goto <bb 220> (video);


Removing basic block 90
;; basic block 90, loop depth 0, count 0
;; prev block 89, next block 91
;; pred:      
;; succ:       93 (fallthru)
<bb 90>:
goto <bb 93>;


Removing basic block 186
;; basic block 186, loop depth 0, count 0
;; prev block 185, next block 187
;; pred:      
;; succ:       188 (fallthru)
<bb 186>:
goto <bb 188>;


Removing basic block 247
;; basic block 247, loop depth 0, count 0
;; prev block 246, next block 248
;; pred:      
;; succ:       335 (fallthru)
<bb 247>:
goto <bb 335> (video_up);


Removing basic block 256
;; basic block 256, loop depth 0, count 0
;; prev block 255, next block 257
;; pred:      
;; succ:       259 (fallthru)
<bb 256>:
goto <bb 259>;


Removing basic block 325
;; basic block 325, loop depth 0, count 0
;; prev block 324, next block 326
;; pred:      
;; succ:       330 (fallthru)
<bb 325>:
goto <bb 330>;


Removing basic block 330
;; basic block 330, loop depth 0, count 0
;; prev block 329, next block 331
;; pred:      
;; succ:       335 (fallthru)
<bb 330>:
goto <bb 335> (video_up);


switch_core_media_activate_rtp (struct switch_core_session_t * session)
{
  dtls_type_t dtype;
  dtls_type_t xtype;
  size_t __s2_len;
  size_t __s1_len;
  int interval;
  switch_port_t remote_port;
  const char * rport;
  uint32_t ssrc_ul;
  const char * ssrc;
  switch_port_t remote_rtcp_port;
  const char * rport;
  size_t __s2_len;
  size_t __s1_len;
  switch_port_t remote_port;
  char * remote_host;
  int delayi;
  int v;
  int v;
  int maxqlen;
  int qlen;
  char * q;
  char * p;
  int max_drift;
  int maxlen;
  int jb_msec;
  dtls_type_t dtype;
  dtls_type_t xtype;
  size_t __s2_len;
  size_t __s1_len;
  int interval;
  switch_port_t remote_rtcp_port;
  const char * rport;
  uint32_t ssrc_ul;
  const char * ssrc;
  uint8_t inb;
  uint8_t vad_out;
  uint8_t vad_in;
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  switch_port_t remote_rtcp_port;
  const char * rport;
  size_t __s2_len;
  size_t __s1_len;
  switch_port_t remote_port;
  char * remote_host;
  static const char __func__[31] = "switch_core_media_activate_rtp";
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_activate_rtp";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  const char * var;
  char * timer_name;
  char tmp[50];
  switch_status_t status;
  switch_rtp_flag_t flags[39];
  const char * val;
  const char * err;
  _Bool D.43791;
  _Bool D.43790;
  const char * iftmp.68;
  const char * iftmp.67;
  uint32_t D.43777;
  uint32_t D.43776;
  unsigned int D.43775;
  switch_rtp_bug_flag_t D.43774;
  switch_rtp_bug_flag_t D.43773;
  switch_rtp_bug_flag_t * D.43772;
  unsigned int D.43765;
  struct dtls_fingerprint_t * D.43764;
  struct dtls_fingerprint_t * D.43763;
  char * D.43760;
  switch_call_direction_t D.43754;
  dtls_type_t iftmp.66;
  int D.43750;
  int D.43747;
  int D.43744;
  char[192] * D.43743;
  switch_call_direction_t D.43739;
  switch_core_media_ice_type_t iftmp.65;
  switch_port_t D.43736;
  switch_port_t D.43735;
  char * D.43733;
  char * D.43732;
  int D.39417;
  uint8_t D.43726;
  int D.43725;
  int D.43724;
  unsigned int D.43721;
  unsigned int interval.64;
  switch_bool_t D.43718;
  int8_t D.43717;
  int D.43716;
  int D.43713;
  int D.43712;
  struct ice_t * D.43706;
  switch_call_direction_t D.43702;
  switch_core_media_ice_type_t iftmp.63;
  char * D.43700;
  char * D.43699;
  char * D.43698;
  char * D.43697;
  uint8_t D.43694;
  int D.43693;
  uint32_t D.43690;
  uint32_t D.43689;
  struct payload_map_t * * D.43685;
  uint8_t D.43682;
  uint8_t D.43679;
  uint8_t D.43676;
  uint8_t D.43672;
  const char * iftmp.62;
  char * D.43670;
  uint32_t D.43666;
  char * iftmp.61;
  struct switch_rtp_t * D.43664;
  struct switch_memory_pool_t * D.43663;
  switch_rtp_flag_t D.43662;
  switch_rtp_flag_t D.43661;
  uint32_t D.43658;
  uint32_t D.43655;
  int D.43654;
  uint32_t D.43650;
  int32_t D.43647;
  uint8_t D.43636;
  int D.43635;
  int D.43634;
  char * D.43633;
  int D.43632;
  uint32_t D.43628;
  int32_t D.43625;
  uint32_t D.43620;
  int D.43619;
  uint32_t D.43615;
  int32_t D.43612;
  switch_status_t D.43606;
  int D.43605;
  uint32_t D.43598;
  int D.43595;
  switch_payload_t D.43594;
  int D.43593;
  switch_port_t D.43592;
  char * D.43591;
  uint8_t D.43588;
  uint32_t D.43585;
  int D.43584;
  int D.43583;
  char * D.43582;
  char * D.43581;
  char * D.43578;
  int D.39400;
  _Bool D.43576;
  _Bool D.43575;
  _Bool D.43574;
  uint32_t D.43570;
  switch_port_t D.43565;
  char * D.43562;
  struct payload_map_t * D.43561;
  uint32_t D.43558;
  switch_call_direction_t D.43555;
  uint32_t D.43552;
  int D.43551;
  int32_t D.43548;
  char * D.43545;
  uint32_t D.43542;
  unsigned int delayi.60;
  int D.43536;
  int D.43534;
  int32_t D.43531;
  int D.43527;
  switch_payload_t D.43524;
  int D.43523;
  switch_payload_t D.43520;
  uint32_t D.43519;
  uint32_t D.43518;
  uint32_t D.43515;
  uint32_t D.43512;
  uint32_t D.43511;
  uint32_t D.43510;
  uint32_t D.43509;
  uint32_t D.43506;
  uint32_t v.59;
  uint32_t v.58;
  int D.43492;
  const char * D.43491;
  switch_status_t D.43488;
  uint32_t max_drift.57;
  uint32_t D.43486;
  uint32_t maxqlen.56;
  uint32_t qlen.55;
  unsigned int D.43474;
  int D.43473;
  int D.43472;
  const int D.43471;
  const struct switch_codec_implementation_t * D.43470;
  unsigned int D.43467;
  unsigned int jb_msec.54;
  int D.43465;
  unsigned int D.43453;
  struct dtls_fingerprint_t * D.43452;
  struct dtls_fingerprint_t * D.43451;
  char * D.43448;
  dtls_type_t iftmp.53;
  uint32_t D.43439;
  switch_call_direction_t D.43435;
  struct switch_channel_t * D.43434;
  dtls_type_t iftmp.52;
  int D.43430;
  struct switch_core_session_t * D.43429;
  int D.43426;
  int D.43423;
  char[192] * D.43422;
  switch_call_direction_t D.43418;
  switch_core_media_ice_type_t iftmp.51;
  switch_port_t D.43415;
  switch_port_t D.43414;
  char * D.43412;
  char * D.43411;
  int D.39377;
  uint8_t D.43405;
  int D.43404;
  unsigned int D.43401;
  unsigned int interval.50;
  switch_bool_t D.43398;
  int8_t D.43397;
  int D.43396;
  int D.43393;
  int D.43392;
  _Bool D.43389;
  _Bool D.43388;
  _Bool D.43387;
  struct ice_t * D.43383;
  switch_call_direction_t D.43379;
  switch_core_media_ice_type_t iftmp.49;
  char * D.43377;
  char * D.43376;
  char * D.43375;
  char * D.43374;
  uint8_t D.43371;
  int D.43370;
  char * iftmp.48;
  char * iftmp.47;
  char * D.43361;
  struct switch_channel_t * D.43360;
  struct switch_codec_t * D.43359;
  _Bool D.43358;
  _Bool D.43357;
  _Bool D.43356;
  _Bool D.43354;
  _Bool D.43353;
  _Bool D.43352;
  unsigned int D.43349;
  switch_rtp_bug_flag_t D.43348;
  switch_rtp_bug_flag_t * D.43347;
  unsigned int D.43344;
  switch_rtp_bug_flag_t D.43343;
  unsigned int D.43340;
  switch_rtp_bug_flag_t D.43339;
  uint32_t D.43338;
  int D.43335;
  int D.43330;
  int D.43325;
  int D.43320;
  uint32_t D.43315;
  uint32_t D.43314;
  struct switch_memory_pool_t * D.43310;
  struct switch_mutex_t *[2] * D.43309;
  switch_call_direction_t D.43308;
  uint8_t D.43307;
  switch_core_media_vflag_t D.43306;
  uint8_t D.43303;
  struct payload_map_t * * D.43302;
  uint8_t D.43299;
  struct switch_rtp_t * D.43298;
  struct switch_memory_pool_t * D.43297;
  uint32_t D.43296;
  uint32_t D.43295;
  uint32_t D.43294;
  switch_channel_state_t D.43293;
  int D.43291;
  uint8_t D.43283;
  char * D.43282;
  int D.43281;
  uint32_t D.43277;
  int32_t D.43274;
  switch_rtp_flag_t D.43271;
  switch_rtp_flag_t D.43270;
  uint32_t D.43267;
  _Bool D.43264;
  _Bool D.43263;
  _Bool D.43262;
  uint32_t D.43259;
  int D.43258;
  int32_t D.43254;
  int D.43248;
  const unsigned char D.43247;
  char * D.43246;
  int D.43245;
  const unsigned char D.43244;
  const unsigned char * D.43243;
  _Bool D.43240;
  _Bool D.43239;
  int D.43238;
  const unsigned char D.43237;
  char * D.43236;
  int D.43235;
  const unsigned char D.43234;
  const unsigned char * D.43233;
  _Bool D.43230;
  _Bool D.43229;
  int D.43228;
  const unsigned char D.43227;
  char * D.43226;
  int D.43225;
  const unsigned char D.43224;
  const unsigned char * D.43223;
  _Bool D.43220;
  _Bool D.43219;
  _Bool D.43218;
  int D.43217;
  const unsigned char D.43216;
  char[8] * D.43215;
  int D.43214;
  const unsigned char D.43213;
  int D.39359;
  int iftmp.46;
  int D.39360;
  uint32_t D.43207;
  const char * err.45;
  switch_status_t D.43202;
  int D.43201;
  uint32_t D.43194;
  char * D.43191;
  int D.43190;
  int D.43189;
  int D.43188;
  switch_payload_t D.43187;
  int D.43186;
  switch_port_t D.43185;
  char * D.43184;
  char * D.43183;
  uint32_t D.43180;
  int D.43179;
  int D.43178;
  char * D.43177;
  char * D.43176;
  switch_port_t D.43174;
  char * D.43172;
  struct payload_map_t * D.43171;
  int D.39348;
  _Bool D.43169;
  _Bool D.43168;
  _Bool D.43167;
  uint32_t D.43163;
  int D.43158;
  switch_rtp_flag_t D.43153;
  switch_rtp_flag_t D.43152;
  int D.43149;
  char * D.43148;
  switch_rtp_flag_t D.43147;
  switch_rtp_flag_t D.43146;
  switch_payload_t D.43143;
  int32_t D.43139;
  switch_rtp_flag_t D.43138;
  switch_rtp_flag_t D.43137;
  int D.43136;
  int32_t D.43132;
  switch_rtp_flag_t D.43129;
  switch_rtp_flag_t D.43128;
  int D.43127;
  int32_t D.43124;
  int D.43121;
  int32_t D.43118;
  switch_rtp_flag_t D.43115;
  switch_rtp_flag_t D.43114;
  int D.43113;
  uint32_t D.43109;
  int32_t D.43106;
  switch_rtp_flag_t D.43103;
  switch_rtp_flag_t D.43102;
  uint32_t D.43100;
  struct switch_core_media_params_t * D.43099;
  uint8_t D.43097;
  struct switch_rtp_t * D.43096;
  uint32_t D.43093;
  uint8_t D.43090;
  uint32_t D.43087;
  uint32_t D.43084;
  switch_rtp_crypto_key_type_t D.43081;
  uint8_t D.43078;
  struct switch_rtp_t * D.43077;
  switch_channel_state_t D.43076;
  int D.43074;
  struct switch_channel_t * D.43073;
  switch_status_t D.43070;

<bb 2>:
  err = 0B;
  val = 0B;
  flags = {};
  status = 0;
  timer_name = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4731, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.43070 = 1;
  goto <bb 332>;

<bb 6>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.43073 = session->channel;
  D.43074 = switch_channel_check_signal (D.43073, 1);
  if (D.43074 != 0)
    goto <bb 8>;
  else
    goto <bb 7>;

<bb 7>:
  D.43073 = session->channel;
  D.43076 = switch_channel_get_state (D.43073);
  if (D.43076 > 9)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.43070 = 1;
  goto <bb 332>;

<bb 9>:
  D.43077 = a_engine->rtp_session;
  D.43078 = switch_rtp_ready (D.43077);
  if (D.43078 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.43077 = a_engine->rtp_session;
  switch_rtp_reset_media_timer (D.43077);

<bb 11>:
  D.43081 = a_engine->crypto_type;
  if (D.43081 != 9)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 92, 1);

<bb 13>:
  D.43073 = session->channel;
  D.43084 = switch_channel_test_flag (D.43073, 15);
  if (D.43084 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  status = 0;
  goto <bb 331> (end);

<bb 15>:
  D.43073 = session->channel;
  D.43087 = switch_channel_test_flag (D.43073, 103);
  if (D.43087 == 0)
    goto <bb 16>;
  else
    goto <bb 20>;

<bb 16>:
  D.43077 = a_engine->rtp_session;
  D.43090 = switch_rtp_ready (D.43077);
  if (D.43090 != 0)
    goto <bb 17>;
  else
    goto <bb 20>;

<bb 17>:
  D.43073 = session->channel;
  D.43093 = switch_channel_test_flag (D.43073, 98);
  if (D.43093 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.43096 = v_engine->rtp_session;
  D.43097 = switch_rtp_ready (D.43096);
  if (D.43097 == 0)
    goto <bb 217> (video);
  else
    goto <bb 19>;

<bb 19>:
  status = 0;
  goto <bb 331> (end);

<bb 20>:
  D.43099 = smh->mparams;
  D.43100 = D.43099->codec_flags;
  status = switch_core_media_set_codec (session, 0, D.43100);
  if (status != 0)
    goto <bb 331> (end);
  else
    goto <bb 21>;

<bb 21>:
  switch_core_media_set_video_codec (session, 0);
  memset (&flags, 0, 156);
  D.43102 = flags[13];
  D.43103 = D.43102 + 1;
  flags[13] = D.43103;
  D.43106 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43106 == 0)
    goto <bb 22>;
  else
    goto <bb 26>;

<bb 22>:
  D.43073 = session->channel;
  D.43109 = switch_channel_test_flag (D.43073, 106);
  if (D.43109 == 0)
    goto <bb 23>;
  else
    goto <bb 26>;

<bb 23>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 25>;
  else
    goto <bb 24>;

<bb 24>:
  D.43113 = switch_true (val);
  if (D.43113 == 0)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  D.43114 = flags[7];
  D.43115 = D.43114 + 1;
  flags[7] = D.43115;

<bb 26>:
  D.43118 = switch_media_handle_test_media_flag (smh, 11);
  if (D.43118 != 0)
    goto <bb 29>;
  else
    goto <bb 27>;

<bb 27>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "pass_rfc2833", 1, -1);
  if (val != 0B)
    goto <bb 28>;
  else
    goto <bb 30>;

<bb 28>:
  D.43121 = switch_true (val);
  if (D.43121 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 100, 1);

<bb 30>:
  D.43124 = switch_media_handle_test_media_flag (smh, 12);
  if (D.43124 != 0)
    goto <bb 33>;
  else
    goto <bb 31>;

<bb 31>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_autoflush", 1, -1);
  if (val != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

<bb 32>:
  D.43127 = switch_true (val);
  if (D.43127 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.43128 = flags[22];
  D.43129 = D.43128 + 1;
  flags[22] = D.43129;

<bb 34>:
  D.43132 = switch_media_handle_test_media_flag (smh, 13);
  if (D.43132 == 0)
    goto <bb 35>;
  else
    goto <bb 38>;

<bb 35>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_rewrite_timestamps", 1, -1);
  if (val == 0B)
    goto <bb 37>;
  else
    goto <bb 36>;

<bb 36>:
  D.43136 = switch_true (val);
  if (D.43136 == 0)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  D.43137 = flags[8];
  D.43138 = D.43137 + 1;
  flags[8] = D.43138;

<bb 38>:
  D.43139 = switch_media_handle_test_media_flag (smh, 9);
  if (D.43139 != 0)
    goto <bb 39>;
  else
    goto <bb 40>;

<bb 39>:
  D.43099 = smh->mparams;
  D.43099->cng_pt = 0;
  goto <bb 42>;

<bb 40>:
  D.43099 = smh->mparams;
  D.43143 = D.43099->cng_pt;
  if (D.43143 != 0)
    goto <bb 41>;
  else
    goto <bb 42>;

<bb 41>:
  D.43146 = flags[16];
  D.43147 = D.43146 + 1;
  flags[16] = D.43147;

<bb 42>:
  D.43148 = a_engine->read_impl.iananame;
  D.43149 = strcasecmp (D.43148, "L16");
  if (D.43149 == 0)
    goto <bb 43>;
  else
    goto <bb 44>;

<bb 43>:
  D.43152 = flags[14];
  D.43153 = D.43152 + 1;
  flags[14] = D.43153;

<bb 44>:
  D.43152 = flags[14];
  if (D.43152 != 0)
    goto <bb 45>;
  else
    goto <bb 48>;

<bb 45>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_disable_byteswap", 1, -1);
  if (val != 0B)
    goto <bb 46>;
  else
    goto <bb 48>;

<bb 46>:
  D.43158 = switch_true (val);
  if (D.43158 != 0)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  flags[14] = 0;

<bb 48>:
  D.43077 = a_engine->rtp_session;
  if (D.43077 != 0B)
    goto <bb 49>;
  else
    goto <bb 55>;

<bb 49>:
  D.43073 = session->channel;
  D.43163 = switch_channel_test_flag (D.43073, 103);
  if (D.43163 != 0)
    goto <bb 50>;
  else
    goto <bb 55>;

<bb 50>:
  D.43077 = a_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.43077);
  D.43077 = a_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.43077);
  D.43167 = remote_host != 0B;
  D.43168 = remote_port != 0;
  D.43169 = D.43167 && D.43168;
  if (D.43169 != 0)
    goto <bb 51>;
  else
    goto <bb 54>;

<bb 51>:
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.39348 = __builtin_strcmp (remote_host, D.43172);
  if (D.39348 == 0)
    goto <bb 52>;
  else
    goto <bb 54>;

<bb 52>:
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  if (D.43174 == remote_port)
    goto <bb 53>;
  else
    goto <bb 54>;

<bb 53>:
  D.43073 = session->channel;
  D.43176 = switch_channel_get_name (D.43073);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4825, session, 7, "Audio params are unchanged for %s.\n", D.43176);
  goto <bb 217> (video);

<bb 54>:
  D.43073 = session->channel;
  D.43177 = switch_channel_get_name (D.43073);
  D.43178 = (int) remote_port;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4830, session, 7, "Audio params changed for %s from %s:%d to %s:%d\n", D.43177, remote_host, D.43178, D.43172, D.43179);
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  switch_snprintf (&tmp, 50, "%d", D.43179);
  D.43073 = session->channel;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.43073, "remote_media_ip", D.43172, 1);
  D.43073 = session->channel;
  switch_channel_set_variable_var_check (D.43073, "remote_media_port", &tmp, 1);

<bb 55>:
  D.43073 = session->channel;
  D.43180 = switch_channel_test_flag (D.43073, 29);
  if (D.43180 == 0)
    goto <bb 56>;
  else
    goto <bb 57>;

<bb 56>:
  D.43073 = session->channel;
  D.43183 = switch_channel_get_name (D.43073);
  D.43184 = a_engine->local_sdp_ip;
  D.43185 = a_engine->local_sdp_port;
  D.43186 = (int) D.43185;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  D.43171 = a_engine->cur_payload_map;
  D.43187 = D.43171->agreed_pt;
  D.43188 = (int) D.43187;
  D.43189 = a_engine->read_impl.microseconds_per_packet;
  D.43190 = D.43189 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4841, session, 7, "AUDIO RTP [%s] %s port %d -> %s port %d codec: %u ms: %d\n", D.43183, D.43184, D.43186, D.43172, D.43179, D.43188, D.43190);

<bb 57>:
  D.43185 = a_engine->local_sdp_port;
  D.43186 = (int) D.43185;
  switch_snprintf (&tmp, 50, "%d", D.43186);
  D.43073 = session->channel;
  D.43184 = a_engine->local_sdp_ip;
  switch_channel_set_variable_var_check (D.43073, "local_media_ip", D.43184, 1);
  D.43073 = session->channel;
  switch_channel_set_variable_var_check (D.43073, "local_media_port", &tmp, 1);
  D.43073 = session->channel;
  D.43191 = a_engine->adv_sdp_ip;
  switch_channel_set_variable_var_check (D.43073, "advertised_media_ip", D.43191, 1);
  D.43077 = a_engine->rtp_session;
  if (D.43077 != 0B)
    goto <bb 58>;
  else
    goto <bb 81>;

<bb 58>:
  D.43073 = session->channel;
  D.43194 = switch_channel_test_flag (D.43073, 103);
  if (D.43194 != 0)
    goto <bb 59>;
  else
    goto <bb 81>;

<bb 59>:
  rport = 0B;
  remote_rtcp_port = a_engine->remote_rtcp_port;
  if (remote_rtcp_port == 0)
    goto <bb 60>;
  else
    goto <bb 62>;

<bb 60>:
  D.43073 = session->channel;
  rport = switch_channel_get_variable_dup (D.43073, "rtp_remote_audio_rtcp_port", 1, -1);
  if (rport != 0B)
    goto <bb 61>;
  else
    goto <bb 62>;

<bb 61>:
  D.43201 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.43201;

<bb 62>:
  D.43077 = a_engine->rtp_session;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43202 = switch_rtp_set_remote_address (D.43077, D.43172, D.43174, remote_rtcp_port, 1, &err);
  if (D.43202 != 0)
    goto <bb 63>;
  else
    goto <bb 64>;

<bb 63>:
  err.45 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4868, session, 3, "AUDIO RTP REPORTS ERROR: [%s]\n", err.45);
  goto <bb 79>;

<bb 64>:
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4870, session, 7, "AUDIO RTP CHANGING DEST TO: [%s:%d]\n", D.43172, D.43179);
  D.43073 = session->channel;
  D.43207 = switch_channel_test_flag (D.43073, 96);
  if (D.43207 != 0)
    goto <bb 65>;
  else
    goto <bb 74>;

<bb 65>:
  __s2_len = 7;
  if (__s2_len <= 3)
    goto <bb 66>;
  else
    goto <bb 71>;

<bb 66>:
  D.43171 = a_engine->cur_payload_map;
  __s1 = D.43171->remote_sdp_ip;
  D.43213 = *__s1;
  D.43214 = (int) D.43213;
  D.43215 = "0.0.0.0";
  D.43216 = MEM[(const unsigned char *)D.43215];
  D.43217 = (int) D.43216;
  __result = D.43214 - D.43217;
  D.43218 = __s2_len != 0;
  D.43219 = __result == 0;
  D.43220 = D.43218 && D.43219;
  if (D.43220 != 0)
    goto <bb 67>;
  else
    goto <bb 70>;

<bb 67>:
  D.43223 = __s1 + 1;
  D.43224 = *D.43223;
  D.43225 = (int) D.43224;
  D.43226 = &"0.0.0.0"[1];
  D.43227 = MEM[(const unsigned char *)D.43226];
  D.43228 = (int) D.43227;
  __result = D.43225 - D.43228;
  D.43229 = __s2_len > 1;
  D.43219 = __result == 0;
  D.43230 = D.43229 && D.43219;
  if (D.43230 != 0)
    goto <bb 68>;
  else
    goto <bb 70>;

<bb 68>:
  D.43233 = __s1 + 2;
  D.43234 = *D.43233;
  D.43235 = (int) D.43234;
  D.43236 = &"0.0.0.0"[2];
  D.43237 = MEM[(const unsigned char *)D.43236];
  D.43238 = (int) D.43237;
  __result = D.43235 - D.43238;
  D.43239 = __s2_len > 2;
  D.43219 = __result == 0;
  D.43240 = D.43239 && D.43219;
  if (D.43240 != 0)
    goto <bb 69>;
  else
    goto <bb 70>;

<bb 69>:
  D.43243 = __s1 + 3;
  D.43244 = *D.43243;
  D.43245 = (int) D.43244;
  D.43246 = &"0.0.0.0"[3];
  D.43247 = MEM[(const unsigned char *)D.43246];
  D.43248 = (int) D.43247;
  __result = D.43245 - D.43248;

<bb 70>:
  D.39359 = __result;
  iftmp.46 = D.39359;
  goto <bb 72>;

<bb 71>:
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  iftmp.46 = __builtin_strcmp (D.43172, "0.0.0.0");

<bb 72>:
  D.39360 = iftmp.46;
  if (D.39360 != 0)
    goto <bb 73>;
  else
    goto <bb 74>;

<bb 73>:
  switch_core_media_toggle_hold (session, 0);

<bb 74>:
  D.43254 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43254 == 0)
    goto <bb 75>;
  else
    goto <bb 79>;

<bb 75>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 77>;
  else
    goto <bb 76>;

<bb 76>:
  D.43258 = switch_true (val);
  if (D.43258 == 0)
    goto <bb 77>;
  else
    goto <bb 79>;

<bb 77>:
  D.43073 = session->channel;
  D.43259 = switch_channel_test_flag (D.43073, 106);
  if (D.43259 == 0)
    goto <bb 78>;
  else
    goto <bb 79>;

<bb 78>:
  D.43077 = a_engine->rtp_session;
  switch_rtp_set_flag (D.43077, 7);

<bb 79>:
  D.43262 = session != 0B;
  D.43263 = a_engine != 0B;
  D.43264 = D.43262 && D.43263;
  if (D.43264 != 0)
    goto <bb 80>;
  else
    goto <bb 217> (video);

<bb 80>:
  check_dtls_reinvite (session, a_engine);
  goto <bb 217> (video);

<bb 81>:
  D.43073 = session->channel;
  D.43267 = switch_channel_test_flag (D.43073, 29);
  if (D.43267 != 0)
    goto <bb 82>;
  else
    goto <bb 89>;

<bb 82>:
  switch_core_media_proxy_remote_addr (session, 0B);
  memset (&flags, 0, 156);
  D.43102 = flags[13];
  D.43103 = D.43102 + 1;
  flags[13] = D.43103;
  D.43270 = flags[19];
  D.43271 = D.43270 + 1;
  flags[19] = D.43271;
  D.43274 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43274 == 0)
    goto <bb 83>;
  else
    goto <bb 87>;

<bb 83>:
  D.43073 = session->channel;
  D.43277 = switch_channel_test_flag (D.43073, 106);
  if (D.43277 == 0)
    goto <bb 84>;
  else
    goto <bb 87>;

<bb 84>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 86>;
  else
    goto <bb 85>;

<bb 85>:
  D.43281 = switch_true (val);
  if (D.43281 == 0)
    goto <bb 86>;
  else
    goto <bb 87>;

<bb 86>:
  D.43114 = flags[7];
  D.43115 = D.43114 + 1;
  flags[7] = D.43115;

<bb 87>:
  timer_name = 0B;
  D.43073 = session->channel;
  D.43282 = switch_channel_get_name (D.43073);
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  D.43171 = a_engine->cur_payload_map;
  D.43187 = D.43171->agreed_pt;
  D.43188 = (int) D.43187;
  D.43189 = a_engine->read_impl.microseconds_per_packet;
  D.43190 = D.43189 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4906, session, 7, "PROXY AUDIO RTP [%s] %s:%d->%s:%d codec: %u ms: %d\n", D.43282, D.43172, D.43179, D.43172, D.43179, D.43188, D.43190);
  D.43077 = a_engine->rtp_session;
  D.43283 = switch_rtp_ready (D.43077);
  if (D.43283 != 0)
    goto <bb 88>;
  else
    goto <bb 91>;

<bb 88>:
  D.43077 = a_engine->rtp_session;
  D.43171 = a_engine->cur_payload_map;
  D.43187 = D.43171->agreed_pt;
  switch_rtp_set_default_payload (D.43077, D.43187);
  goto <bb 91>;

<bb 89>:
  D.43099 = smh->mparams;
  timer_name = D.43099->timer_name;
  D.43073 = session->channel;
  var = switch_channel_get_variable_dup (D.43073, "rtp_timer_name", 1, -1);
  if (var != 0B)
    goto <bb 90>;
  else
    goto <bb 91>;

<bb 90>:
  timer_name = var;

<bb 91>:
  D.43073 = session->channel;
  D.43291 = switch_channel_check_signal (D.43073, 1);
  if (D.43291 != 0)
    goto <bb 93>;
  else
    goto <bb 92>;

<bb 92>:
  D.43073 = session->channel;
  D.43293 = switch_channel_get_state (D.43073);
  if (D.43293 <= 9)
    goto <bb 93>;
  else
    goto <bb 95>;

<bb 93>:
  D.43184 = a_engine->local_sdp_ip;
  D.43185 = a_engine->local_sdp_port;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43171 = a_engine->cur_payload_map;
  D.43187 = D.43171->agreed_pt;
  D.43294 = a_engine->read_impl.samples_per_packet;
  D.43171 = a_engine->cur_payload_map;
  D.43295 = D.43171->codec_ms;
  D.43296 = D.43295 * 1000;
  D.43297 = switch_core_session_get_pool (session);
  D.43298 = switch_rtp_new (D.43184, D.43185, D.43172, D.43174, D.43187, D.43294, D.43296, &flags, timer_name, &err, D.43297);
  a_engine->rtp_session = D.43298;
  D.43077 = a_engine->rtp_session;
  D.43299 = switch_rtp_ready (D.43077);
  if (D.43299 != 0)
    goto <bb 94>;
  else
    goto <bb 95>;

<bb 94>:
  D.43077 = a_engine->rtp_session;
  D.43302 = &a_engine->payload_map;
  switch_rtp_set_payload_map (D.43077, D.43302);

<bb 95>:
  D.43077 = a_engine->rtp_session;
  D.43303 = switch_rtp_ready (D.43077);
  if (D.43303 != 0)
    goto <bb 96>;
  else
    goto <bb 324>;

<bb 96>:
  D.43099 = smh->mparams;
  D.43306 = D.43099->vflags;
  D.43307 = (uint8_t) D.43306;
  vad_in = D.43307 & 1;
  D.43099 = smh->mparams;
  D.43306 = D.43099->vflags;
  D.43307 = (uint8_t) D.43306;
  vad_out = D.43307 & 2;
  D.43073 = session->channel;
  D.43308 = switch_channel_direction (D.43073);
  inb = D.43308 == 0;
  D.43309 = &a_engine->read_mutex;
  D.43310 = switch_core_session_get_pool (session);
  switch_mutex_init (D.43309, 1, D.43310);
  D.43073 = session->channel;
  ssrc = switch_channel_get_variable_dup (D.43073, "rtp_use_ssrc", 1, -1);
  if (ssrc != 0B)
    goto <bb 97>;
  else
    goto <bb 98>;

<bb 97>:
  ssrc_ul = strtoul (ssrc, 0B, 10);
  D.43077 = a_engine->rtp_session;
  switch_rtp_set_ssrc (D.43077, ssrc_ul);
  a_engine->ssrc = ssrc_ul;
  goto <bb 99>;

<bb 98>:
  D.43077 = a_engine->rtp_session;
  D.43314 = a_engine->ssrc;
  switch_rtp_set_ssrc (D.43077, D.43314);

<bb 99>:
  D.43315 = a_engine->remote_ssrc;
  if (D.43315 != 0)
    goto <bb 100>;
  else
    goto <bb 101>;

<bb 100>:
  D.43077 = a_engine->rtp_session;
  D.43315 = a_engine->remote_ssrc;
  switch_rtp_set_remote_ssrc (D.43077, D.43315);

<bb 101>:
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 36, 1);
  D.43073 = session->channel;
  D.43171 = a_engine->cur_payload_map;
  D.43187 = D.43171->agreed_pt;
  D.43188 = (int) D.43187;
  switch_channel_set_variable_printf (D.43073, "rtp_use_pt", "%d", D.43188);
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_enable_vad_in", 1, -1);
  if (val != 0B)
    goto <bb 102>;
  else
    goto <bb 104>;

<bb 102>:
  D.43320 = switch_true (val);
  if (D.43320 != 0)
    goto <bb 103>;
  else
    goto <bb 104>;

<bb 103>:
  vad_in = 1;

<bb 104>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_enable_vad_out", 1, -1);
  if (val != 0B)
    goto <bb 105>;
  else
    goto <bb 107>;

<bb 105>:
  D.43325 = switch_true (val);
  if (D.43325 != 0)
    goto <bb 106>;
  else
    goto <bb 107>;

<bb 106>:
  vad_out = 1;

<bb 107>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_disable_vad_in", 1, -1);
  if (val != 0B)
    goto <bb 108>;
  else
    goto <bb 110>;

<bb 108>:
  D.43330 = switch_true (val);
  if (D.43330 != 0)
    goto <bb 109>;
  else
    goto <bb 110>;

<bb 109>:
  vad_in = 0;

<bb 110>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_disable_vad_out", 1, -1);
  if (val != 0B)
    goto <bb 111>;
  else
    goto <bb 113>;

<bb 111>:
  D.43335 = switch_true (val);
  if (D.43335 != 0)
    goto <bb 112>;
  else
    goto <bb 113>;

<bb 112>:
  vad_out = 0;

<bb 113>:
  D.43077 = a_engine->rtp_session;
  D.43338 = switch_rtp_get_ssrc (D.43077);
  a_engine->ssrc = D.43338;
  D.43073 = session->channel;
  D.43314 = a_engine->ssrc;
  switch_channel_set_variable_printf (D.43073, "rtp_use_ssrc", "%u", D.43314);
  D.43099 = smh->mparams;
  D.43339 = D.43099->auto_rtp_bugs;
  D.43340 = D.43339 & 4;
  if (D.43340 != 0)
    goto <bb 114>;
  else
    goto <bb 115>;

<bb 114>:
  D.43343 = a_engine->rtp_bugs;
  D.43344 = D.43343 | 4;
  a_engine->rtp_bugs = D.43344;

<bb 115>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_manual_rtp_bugs", 1, -1);
  if (val != 0B)
    goto <bb 116>;
  else
    goto <bb 117>;

<bb 116>:
  D.43347 = &a_engine->rtp_bugs;
  switch_core_media_parse_rtp_bugs (D.43347, val);

<bb 117>:
  D.43077 = a_engine->rtp_session;
  D.43343 = a_engine->rtp_bugs;
  D.43099 = smh->mparams;
  D.43348 = D.43099->manual_rtp_bugs;
  D.43349 = D.43343 | D.43348;
  switch_rtp_intentional_bugs (D.43077, D.43349);
  D.43352 = vad_in != 0;
  D.43353 = inb != 0;
  D.43354 = D.43352 && D.43353;
  if (D.43354 != 0)
    goto <bb 119>;
  else
    goto <bb 118>;

<bb 118>:
  D.43356 = vad_out != 0;
  D.43357 = inb == 0;
  D.43358 = D.43356 && D.43357;
  if (D.43358 != 0)
    goto <bb 119>;
  else
    goto <bb 126>;

<bb 119>:
  D.43077 = a_engine->rtp_session;
  D.43359 = &a_engine->read_codec;
  switch_rtp_enable_vad (D.43077, session, D.43359, 7);
  D.43360 = switch_core_session_get_channel (session);
  D.43361 = switch_channel_get_name (D.43360);
  if (vad_in != 0)
    goto <bb 120>;
  else
    goto <bb 121>;

<bb 120>:
  iftmp.47 = "in";
  goto <bb 122>;

<bb 121>:
  iftmp.47 = "";

<bb 122>:
  if (vad_out != 0)
    goto <bb 123>;
  else
    goto <bb 124>;

<bb 123>:
  iftmp.48 = "out";
  goto <bb 125>;

<bb 124>:
  iftmp.48 = "";

<bb 125>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5001, session, 7, "AUDIO RTP Engage VAD for %s ( %s %s )\n", D.43361, iftmp.47, iftmp.48);

<bb 126>:
  D.43370 = a_engine->ice_in.chosen[0];
  D.43371 = a_engine->ice_in.cands[D.43370][0].ready;
  if (D.43371 != 0)
    goto <bb 127>;
  else
    goto <bb 131>;

<bb 127>:
  gen_ice (session, 0, 0B, 0);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5010, session, 6, "Activating Audio ICE\n");
  D.43077 = a_engine->rtp_session;
  D.43374 = a_engine->ice_in.ufrag;
  D.43375 = a_engine->ice_out.ufrag;
  D.43376 = a_engine->ice_out.pwd;
  D.43377 = a_engine->ice_in.pwd;
  D.43379 = switch_ice_direction (session);
  if (D.43379 == 1)
    goto <bb 128>;
  else
    goto <bb 129>;

<bb 128>:
  iftmp.49 = 2;
  goto <bb 130>;

<bb 129>:
  iftmp.49 = 6;

<bb 130>:
  D.43383 = &a_engine->ice_in;
  switch_rtp_activate_ice (D.43077, D.43374, D.43375, D.43376, D.43377, 0, iftmp.49, D.43383);

<bb 131>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtcp_audio_interval_msec", 1, -1);
  if (val != 0B)
    goto <bb 133>;
  else
    goto <bb 132>;

<bb 132>:
  D.43099 = smh->mparams;
  val = D.43099->rtcp_audio_interval_msec;
  if (val != 0B)
    goto <bb 133>;
  else
    goto <bb 149>;

<bb 133>:
  D.43073 = session->channel;
  rport = switch_channel_get_variable_dup (D.43073, "rtp_remote_audio_rtcp_port", 1, -1);
  remote_rtcp_port = a_engine->remote_rtcp_port;
  D.43387 = remote_rtcp_port == 0;
  D.43388 = rport != 0B;
  D.43389 = D.43387 && D.43388;
  if (D.43389 != 0)
    goto <bb 134>;
  else
    goto <bb 135>;

<bb 134>:
  D.43392 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.43392;

<bb 135>:
  D.43393 = strcasecmp (val, "passthru");
  if (D.43393 == 0)
    goto <bb 136>;
  else
    goto <bb 137>;

<bb 136>:
  D.43396 = (int) remote_rtcp_port;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5043, session, 6, "Activating RTCP PASSTHRU PORT %d\n", D.43396);
  D.43077 = a_engine->rtp_session;
  D.43397 = a_engine->rtcp_mux;
  D.43398 = D.43397 > 0;
  switch_rtp_activate_rtcp (D.43077, -1, remote_rtcp_port, D.43398);
  goto <bb 140>;

<bb 137>:
  interval = atoi (val);
  interval.50 = (unsigned int) interval;
  D.43401 = interval.50 + 4294967196;
  if (D.43401 > 499900)
    goto <bb 138>;
  else
    goto <bb 139>;

<bb 138>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5048, session, 3, "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);
  interval = 10000;

<bb 139>:
  D.43396 = (int) remote_rtcp_port;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5053, session, 6, "Activating RTCP PORT %d\n", D.43396);
  D.43077 = a_engine->rtp_session;
  D.43397 = a_engine->rtcp_mux;
  D.43398 = D.43397 > 0;
  switch_rtp_activate_rtcp (D.43077, interval, remote_rtcp_port, D.43398);

<bb 140>:
  D.43404 = a_engine->ice_in.chosen[1];
  D.43405 = a_engine->ice_in.cands[D.43404][1].ready;
  if (D.43405 != 0)
    goto <bb 141>;
  else
    goto <bb 149>;

<bb 141>:
  D.43397 = a_engine->rtcp_mux;
  if (D.43397 > 0)
    goto <bb 142>;
  else
    goto <bb 145>;

<bb 142>:
  D.43404 = a_engine->ice_in.chosen[1];
  D.43411 = a_engine->ice_in.cands[D.43404][1].con_addr;
  D.43370 = a_engine->ice_in.chosen[0];
  D.43412 = a_engine->ice_in.cands[D.43370][0].con_addr;
  D.39377 = __builtin_strcmp (D.43411, D.43412);
  if (D.39377 == 0)
    goto <bb 143>;
  else
    goto <bb 145>;

<bb 143>:
  D.43404 = a_engine->ice_in.chosen[1];
  D.43414 = a_engine->ice_in.cands[D.43404][1].con_port;
  D.43370 = a_engine->ice_in.chosen[0];
  D.43415 = a_engine->ice_in.cands[D.43370][0].con_port;
  if (D.43414 == D.43415)
    goto <bb 144>;
  else
    goto <bb 145>;

<bb 144>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5061, session, 6, "Skipping RTCP ICE (Same as RTP)\n");
  goto <bb 149>;

<bb 145>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5063, session, 6, "Activating RTCP ICE\n");
  D.43077 = a_engine->rtp_session;
  D.43374 = a_engine->ice_in.ufrag;
  D.43375 = a_engine->ice_out.ufrag;
  D.43376 = a_engine->ice_out.pwd;
  D.43377 = a_engine->ice_in.pwd;
  D.43418 = switch_ice_direction (session);
  if (D.43418 == 1)
    goto <bb 146>;
  else
    goto <bb 147>;

<bb 146>:
  iftmp.51 = 2;
  goto <bb 148>;

<bb 147>:
  iftmp.51 = 6;

<bb 148>:
  D.43383 = &a_engine->ice_in;
  switch_rtp_activate_ice (D.43077, D.43374, D.43375, D.43376, D.43377, 1, iftmp.51, D.43383);

<bb 149>:
  D.43422 = &a_engine->local_dtls_fingerprint.str;
  D.43423 = _zstr (D.43422);
  if (D.43423 == 0)
    goto <bb 150>;
  else
    goto <bb 166>;

<bb 150>:
  D.43426 = switch_rtp_has_dtls ();
  if (D.43426 != 0)
    goto <bb 151>;
  else
    goto <bb 166>;

<bb 151>:
  D.43429 = smh->session;
  D.43430 = dtls_ok (D.43429);
  if (D.43430 != 0)
    goto <bb 152>;
  else
    goto <bb 166>;

<bb 152>:
  D.43429 = smh->session;
  D.43434 = D.43429->channel;
  D.43435 = switch_channel_direction (D.43434);
  if (D.43435 == 0)
    goto <bb 153>;
  else
    goto <bb 154>;

<bb 153>:
  iftmp.52 = 1;
  goto <bb 155>;

<bb 154>:
  iftmp.52 = 2;

<bb 155>:
  dtype = iftmp.52;
  D.43429 = smh->session;
  D.43434 = D.43429->channel;
  D.43439 = switch_channel_test_flag (D.43434, 112);
  if (D.43439 != 0)
    goto <bb 156>;
  else
    goto <bb 160>;

<bb 156>:
  if (dtype == 1)
    goto <bb 157>;
  else
    goto <bb 158>;

<bb 157>:
  iftmp.53 = 2;
  goto <bb 159>;

<bb 158>:
  iftmp.53 = 1;

<bb 159>:
  dtype = iftmp.53;

<bb 160>:
  xtype = 4;
  D.43397 = a_engine->rtcp_mux;
  if (D.43397 > 0)
    goto <bb 161>;
  else
    goto <bb 163>;

<bb 161>:
  D.43099 = smh->mparams;
  D.43448 = D.43099->rtcp_audio_interval_msec;
  if (D.43448 != 0B)
    goto <bb 162>;
  else
    goto <bb 163>;

<bb 162>:
  xtype = xtype | 8;

<bb 163>:
  D.43077 = a_engine->rtp_session;
  D.43451 = &a_engine->local_dtls_fingerprint;
  D.43452 = &a_engine->remote_dtls_fingerprint;
  D.43453 = dtype | xtype;
  switch_rtp_add_dtls (D.43077, D.43451, D.43452, D.43453);
  D.43397 = a_engine->rtcp_mux;
  if (D.43397 <= 0)
    goto <bb 164>;
  else
    goto <bb 166>;

<bb 164>:
  D.43099 = smh->mparams;
  D.43448 = D.43099->rtcp_audio_interval_msec;
  if (D.43448 != 0B)
    goto <bb 165>;
  else
    goto <bb 166>;

<bb 165>:
  xtype = 8;
  D.43077 = a_engine->rtp_session;
  D.43451 = &a_engine->local_dtls_fingerprint;
  D.43452 = &a_engine->remote_dtls_fingerprint;
  D.43453 = dtype | xtype;
  switch_rtp_add_dtls (D.43077, D.43451, D.43452, D.43453);

<bb 166>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "jitterbuffer_msec", 1, -1);
  if (val != 0B)
    goto <bb 168>;
  else
    goto <bb 167>;

<bb 167>:
  D.43099 = smh->mparams;
  val = D.43099->jb_msec;
  if (val != 0B)
    goto <bb 168>;
  else
    goto <bb 185>;

<bb 168>:
  jb_msec = atoi (val);
  maxlen = 0;
  max_drift = 0;
  p = __builtin_strchr (val, 58);
  if (p != 0B)
    goto <bb 169>;
  else
    goto <bb 171>;

<bb 169>:
  p = p + 1;
  maxlen = atoi (p);
  q = __builtin_strchr (p, 58);
  if (q != 0B)
    goto <bb 170>;
  else
    goto <bb 171>;

<bb 170>:
  q = q + 1;
  D.43465 = atoi (q);
  max_drift = ABS_EXPR <D.43465>;

<bb 171>:
  jb_msec.54 = (unsigned int) jb_msec;
  D.43467 = jb_msec.54 + 9;
  if (D.43467 <= 8)
    goto <bb 172>;
  else
    goto <bb 173>;

<bb 172>:
  D.43470 = a_engine->read_codec.implementation;
  D.43471 = D.43470->microseconds_per_packet;
  D.43472 = D.43471 / 1000;
  D.43473 = ABS_EXPR <jb_msec>;
  jb_msec = D.43472 * D.43473;

<bb 173>:
  jb_msec.54 = (unsigned int) jb_msec;
  D.43474 = jb_msec.54 + 4294967276;
  if (D.43474 > 9980)
    goto <bb 174>;
  else
    goto <bb 175>;

<bb 174>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5125, session, 3, "Invalid Jitterbuffer spec [%d] must be between 20 and 10000\n", jb_msec);
  goto <bb 185>;

<bb 175>:
  maxqlen = 50;
  D.43189 = a_engine->read_impl.microseconds_per_packet;
  D.43190 = D.43189 / 1000;
  qlen = jb_msec / D.43190;
  if (qlen <= 0)
    goto <bb 176>;
  else
    goto <bb 177>;

<bb 176>:
  qlen = 3;

<bb 177>:
  if (maxlen != 0)
    goto <bb 178>;
  else
    goto <bb 179>;

<bb 178>:
  D.43189 = a_engine->read_impl.microseconds_per_packet;
  D.43190 = D.43189 / 1000;
  maxqlen = maxlen / D.43190;

<bb 179>:
  if (maxqlen < qlen)
    goto <bb 180>;
  else
    goto <bb 181>;

<bb 180>:
  maxqlen = qlen * 5;

<bb 181>:
  D.43077 = a_engine->rtp_session;
  qlen.55 = (uint32_t) qlen;
  maxqlen.56 = (uint32_t) maxqlen;
  D.43294 = a_engine->read_impl.samples_per_packet;
  D.43486 = a_engine->read_impl.samples_per_second;
  max_drift.57 = (uint32_t) max_drift;
  D.43488 = switch_rtp_activate_jitter_buffer (D.43077, qlen.55, maxqlen.56, D.43294, D.43486, max_drift.57);
  if (D.43488 == 0)
    goto <bb 182>;
  else
    goto <bb 184>;

<bb 182>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5146, session, 7, "Setting Jitterbuffer to %dms (%d frames)\n", jb_msec, qlen);
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 57, 1);
  D.43073 = session->channel;
  D.43491 = switch_channel_get_variable_dup (D.43073, "rtp_jitter_buffer_plc", 1, -1);
  D.43492 = switch_false (D.43491);
  if (D.43492 == 0)
    goto <bb 183>;
  else
    goto <bb 185>;

<bb 183>:
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 58, 1);
  goto <bb 185>;

<bb 184>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5153, session, 4, "Error Setting Jitterbuffer to %dms (%d frames)\n", jb_msec, qlen);

<bb 185>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_timeout_sec", 1, -1);
  if (val != 0B)
    goto <bb 186>;
  else
    goto <bb 188>;

<bb 186>:
  v = atoi (val);
  if (v >= 0)
    goto <bb 187>;
  else
    goto <bb 188>;

<bb 187>:
  D.43099 = smh->mparams;
  v.58 = (uint32_t) v;
  D.43099->rtp_timeout_sec = v.58;

<bb 188>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_hold_timeout_sec", 1, -1);
  if (val != 0B)
    goto <bb 189>;
  else
    goto <bb 191>;

<bb 189>:
  v = atoi (val);
  if (v >= 0)
    goto <bb 190>;
  else
    goto <bb 191>;

<bb 190>:
  D.43099 = smh->mparams;
  v.59 = (uint32_t) v;
  D.43099->rtp_hold_timeout_sec = v.59;

<bb 191>:
  D.43099 = smh->mparams;
  D.43506 = D.43099->rtp_timeout_sec;
  if (D.43506 != 0)
    goto <bb 192>;
  else
    goto <bb 194>;

<bb 192>:
  D.43486 = a_engine->read_impl.samples_per_second;
  D.43099 = smh->mparams;
  D.43506 = D.43099->rtp_timeout_sec;
  D.43509 = D.43486 * D.43506;
  D.43294 = a_engine->read_impl.samples_per_packet;
  D.43510 = D.43509 / D.43294;
  a_engine->max_missed_packets = D.43510;
  D.43077 = a_engine->rtp_session;
  D.43511 = a_engine->max_missed_packets;
  switch_rtp_set_max_missed_packets (D.43077, D.43511);
  D.43099 = smh->mparams;
  D.43512 = D.43099->rtp_hold_timeout_sec;
  if (D.43512 == 0)
    goto <bb 193>;
  else
    goto <bb 194>;

<bb 193>:
  D.43099 = smh->mparams;
  D.43099 = smh->mparams;
  D.43506 = D.43099->rtp_timeout_sec;
  D.43515 = D.43506 * 10;
  D.43099->rtp_hold_timeout_sec = D.43515;

<bb 194>:
  D.43099 = smh->mparams;
  D.43512 = D.43099->rtp_hold_timeout_sec;
  if (D.43512 != 0)
    goto <bb 195>;
  else
    goto <bb 196>;

<bb 195>:
  D.43486 = a_engine->read_impl.samples_per_second;
  D.43099 = smh->mparams;
  D.43512 = D.43099->rtp_hold_timeout_sec;
  D.43518 = D.43486 * D.43512;
  D.43294 = a_engine->read_impl.samples_per_packet;
  D.43519 = D.43518 / D.43294;
  a_engine->max_missed_hold_packets = D.43519;

<bb 196>:
  D.43099 = smh->mparams;
  D.43520 = D.43099->te;
  if (D.43520 != 0)
    goto <bb 197>;
  else
    goto <bb 198>;

<bb 197>:
  D.43099 = smh->mparams;
  D.43520 = D.43099->te;
  D.43523 = (int) D.43520;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5188, session, 7, "Set 2833 dtmf send payload to %u\n", D.43523);
  D.43077 = a_engine->rtp_session;
  D.43099 = smh->mparams;
  D.43520 = D.43099->te;
  switch_rtp_set_telephony_event (D.43077, D.43520);
  D.43073 = session->channel;
  D.43099 = smh->mparams;
  D.43520 = D.43099->te;
  D.43523 = (int) D.43520;
  switch_channel_set_variable_printf (D.43073, "rtp_2833_send_payload", "%d", D.43523);

<bb 198>:
  D.43099 = smh->mparams;
  D.43524 = D.43099->recv_te;
  if (D.43524 != 0)
    goto <bb 199>;
  else
    goto <bb 200>;

<bb 199>:
  D.43099 = smh->mparams;
  D.43524 = D.43099->recv_te;
  D.43527 = (int) D.43524;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5194, session, 7, "Set 2833 dtmf receive payload to %u\n", D.43527);
  D.43077 = a_engine->rtp_session;
  D.43099 = smh->mparams;
  D.43524 = D.43099->recv_te;
  switch_rtp_set_telephony_recv_event (D.43077, D.43524);
  D.43073 = session->channel;
  D.43099 = smh->mparams;
  D.43524 = D.43099->recv_te;
  D.43527 = (int) D.43524;
  switch_channel_set_variable_printf (D.43073, "rtp_2833_recv_payload", "%d", D.43527);

<bb 200>:
  D.43531 = switch_media_handle_test_media_flag (smh, 9);
  if (D.43531 != 0)
    goto <bb 205>;
  else
    goto <bb 201>;

<bb 201>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "supress_cng", 1, -1);
  if (val != 0B)
    goto <bb 202>;
  else
    goto <bb 203>;

<bb 202>:
  D.43534 = switch_true (val);
  if (D.43534 != 0)
    goto <bb 205>;
  else
    goto <bb 203>;

<bb 203>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "suppress_cng", 1, -1);
  if (val != 0B)
    goto <bb 204>;
  else
    goto <bb 206>;

<bb 204>:
  D.43536 = switch_true (val);
  if (D.43536 != 0)
    goto <bb 205>;
  else
    goto <bb 206>;

<bb 205>:
  D.43099 = smh->mparams;
  D.43099->cng_pt = 0;

<bb 206>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_digit_delay", 1, -1);
  if (val != 0B)
    goto <bb 207>;
  else
    goto <bb 210>;

<bb 207>:
  delayi = atoi (val);
  if (delayi < 0)
    goto <bb 208>;
  else
    goto <bb 209>;

<bb 208>:
  delayi = 0;

<bb 209>:
  D.43099 = smh->mparams;
  delayi.60 = (unsigned int) delayi;
  D.43099->dtmf_delay = delayi.60;

<bb 210>:
  D.43099 = smh->mparams;
  D.43542 = D.43099->dtmf_delay;
  if (D.43542 != 0)
    goto <bb 211>;
  else
    goto <bb 212>;

<bb 211>:
  D.43077 = a_engine->rtp_session;
  D.43099 = smh->mparams;
  D.43542 = D.43099->dtmf_delay;
  switch_rtp_set_interdigit_delay (D.43077, D.43542);
  D.43073 = session->channel;
  D.43545 = switch_channel_get_name (D.43073);
  D.43099 = smh->mparams;
  D.43542 = D.43099->dtmf_delay;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5216, session, 7, "%s Set rtp dtmf delay to %u\n", D.43545, D.43542);

<bb 212>:
  D.43099 = smh->mparams;
  D.43143 = D.43099->cng_pt;
  if (D.43143 != 0)
    goto <bb 213>;
  else
    goto <bb 215>;

<bb 213>:
  D.43548 = switch_media_handle_test_media_flag (smh, 9);
  if (D.43548 == 0)
    goto <bb 214>;
  else
    goto <bb 215>;

<bb 214>:
  D.43099 = smh->mparams;
  D.43143 = D.43099->cng_pt;
  D.43551 = (int) D.43143;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5222, session, 7, "Set comfort noise payload to %u\n", D.43551);
  D.43077 = a_engine->rtp_session;
  D.43099 = smh->mparams;
  D.43143 = D.43099->cng_pt;
  switch_rtp_set_cng_pt (D.43077, D.43143);

<bb 215>:
  switch_core_session_apply_crypto (session, 0);
  D.43171 = a_engine->cur_payload_map;
  D.43174 = D.43171->remote_sdp_port;
  D.43179 = (int) D.43174;
  switch_snprintf (&tmp, 50, "%d", D.43179);
  D.43073 = session->channel;
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.43073, "remote_media_ip", D.43172, 1);
  D.43073 = session->channel;
  switch_channel_set_variable_var_check (D.43073, "remote_media_port", &tmp, 1);
  D.43073 = session->channel;
  D.43552 = switch_channel_test_flag (D.43073, 74);
  if (D.43552 != 0)
    goto <bb 216>;
  else
    goto <bb 217> (video);

<bb 216>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5234, session, 6, "Activating ZRTP PROXY MODE\n");
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5235, session, 7, "Disable NOTIMER_DURING_BRIDGE\n");
  D.43073 = session->channel;
  switch_channel_clear_flag (D.43073, 99);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5237, session, 7, "Activating audio UDPTL mode\n");
  D.43077 = a_engine->rtp_session;
  switch_rtp_udptl_mode (D.43077);

video:
  D.43073 = session->channel;
  D.43555 = switch_channel_direction (D.43073);
  if (D.43555 == 1)
    goto <bb 218>;
  else
    goto <bb 219>;

<bb 218>:
  switch_core_media_check_video_codecs (session);

<bb 219>:
  D.43073 = session->channel;
  D.43558 = switch_channel_test_flag (D.43073, 98);
  if (D.43558 != 0)
    goto <bb 220>;
  else
    goto <bb 328> (video_up);

<bb 220>:
  D.43561 = v_engine->cur_payload_map;
  D.43562 = D.43561->rm_encoding;
  if (D.43562 != 0B)
    goto <bb 221>;
  else
    goto <bb 328> (video_up);

<bb 221>:
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  if (D.43565 != 0)
    goto <bb 222>;
  else
    goto <bb 328> (video_up);

<bb 222>:
  D.43096 = v_engine->rtp_session;
  if (D.43096 != 0B)
    goto <bb 223>;
  else
    goto <bb 229>;

<bb 223>:
  D.43073 = session->channel;
  D.43570 = switch_channel_test_flag (D.43073, 103);
  if (D.43570 != 0)
    goto <bb 224>;
  else
    goto <bb 229>;

<bb 224>:
  D.43096 = v_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.43096);
  D.43096 = v_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.43096);
  D.43574 = remote_host != 0B;
  D.43575 = remote_port != 0;
  D.43576 = D.43574 && D.43575;
  if (D.43576 != 0)
    goto <bb 225>;
  else
    goto <bb 228>;

<bb 225>:
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.39400 = __builtin_strcmp (remote_host, D.43578);
  if (D.39400 == 0)
    goto <bb 226>;
  else
    goto <bb 228>;

<bb 226>:
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  if (D.43565 == remote_port)
    goto <bb 227>;
  else
    goto <bb 228>;

<bb 227>:
  D.43073 = session->channel;
  D.43581 = switch_channel_get_name (D.43073);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5263, session, 7, "Video params are unchanged for %s.\n", D.43581);
  goto <bb 328> (video_up);

<bb 228>:
  D.43073 = session->channel;
  D.43582 = switch_channel_get_name (D.43073);
  D.43583 = (int) remote_port;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43584 = (int) D.43565;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5267, session, 7, "Video params changed for %s from %s:%d to %s:%d\n", D.43582, remote_host, D.43583, D.43578, D.43584);

<bb 229>:
  D.43073 = session->channel;
  D.43585 = switch_channel_test_flag (D.43073, 29);
  if (D.43585 == 0)
    goto <bb 230>;
  else
    goto <bb 232>;

<bb 230>:
  D.43096 = v_engine->rtp_session;
  D.43588 = switch_rtp_ready (D.43096);
  if (D.43588 != 0)
    goto <bb 231>;
  else
    goto <bb 232>;

<bb 231>:
  D.43073 = session->channel;
  D.43591 = switch_channel_get_name (D.43073);
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43592 = v_engine->local_sdp_port;
  D.43593 = (int) D.43592;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43584 = (int) D.43565;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  D.43595 = (int) D.43594;
  D.43189 = a_engine->read_impl.microseconds_per_packet;
  D.43190 = D.43189 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5275, session, 7, "VIDEO RTP [%s] %s port %d -> %s port %d codec: %u ms: %d\n", D.43591, D.43172, D.43593, D.43578, D.43584, D.43595, D.43190);
  start_video_thread (session);
  D.43096 = v_engine->rtp_session;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  switch_rtp_set_default_payload (D.43096, D.43594);

<bb 232>:
  D.43592 = v_engine->local_sdp_port;
  D.43593 = (int) D.43592;
  switch_snprintf (&tmp, 50, "%d", D.43593);
  D.43073 = session->channel;
  D.43191 = a_engine->adv_sdp_ip;
  switch_channel_set_variable_var_check (D.43073, "local_video_ip", D.43191, 1);
  D.43073 = session->channel;
  switch_channel_set_variable_var_check (D.43073, "local_video_port", &tmp, 1);
  D.43096 = v_engine->rtp_session;
  if (D.43096 != 0B)
    goto <bb 233>;
  else
    goto <bb 244>;

<bb 233>:
  D.43073 = session->channel;
  D.43598 = switch_channel_test_flag (D.43073, 103);
  if (D.43598 != 0)
    goto <bb 234>;
  else
    goto <bb 244>;

<bb 234>:
  rport = 0B;
  remote_rtcp_port = v_engine->remote_rtcp_port;
  if (remote_rtcp_port == 0)
    goto <bb 235>;
  else
    goto <bb 237>;

<bb 235>:
  D.43073 = session->channel;
  rport = switch_channel_get_variable_dup (D.43073, "rtp_remote_video_rtcp_port", 1, -1);
  if (rport != 0B)
    goto <bb 236>;
  else
    goto <bb 237>;

<bb 236>:
  D.43605 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.43605;

<bb 237>:
  D.43096 = v_engine->rtp_session;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43606 = switch_rtp_set_remote_address (D.43096, D.43578, D.43565, remote_rtcp_port, 1, &err);
  if (D.43606 != 0)
    goto <bb 238>;
  else
    goto <bb 239>;

<bb 238>:
  err.45 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5306, session, 3, "VIDEO RTP REPORTS ERROR: [%s]\n", err.45);
  goto <bb 328> (video_up);

<bb 239>:
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43584 = (int) D.43565;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5308, session, 7, "VIDEO RTP CHANGING DEST TO: [%s:%d]\n", D.43578, D.43584);
  D.43612 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43612 == 0)
    goto <bb 240>;
  else
    goto <bb 328> (video_up);

<bb 240>:
  D.43073 = session->channel;
  D.43615 = switch_channel_test_flag (D.43073, 106);
  if (D.43615 == 0)
    goto <bb 241>;
  else
    goto <bb 328> (video_up);

<bb 241>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 243>;
  else
    goto <bb 242>;

<bb 242>:
  D.43619 = switch_true (val);
  if (D.43619 == 0)
    goto <bb 243>;
  else
    goto <bb 328> (video_up);

<bb 243>:
  D.43096 = v_engine->rtp_session;
  switch_rtp_set_flag (D.43096, 7);
  start_video_thread (session);
  goto <bb 328> (video_up);

<bb 244>:
  D.43073 = session->channel;
  D.43620 = switch_channel_test_flag (D.43073, 29);
  if (D.43620 != 0)
    goto <bb 245>;
  else
    goto <bb 252>;

<bb 245>:
  switch_core_media_proxy_remote_addr (session, 0B);
  memset (&flags, 0, 156);
  D.43270 = flags[19];
  D.43271 = D.43270 + 1;
  flags[19] = D.43271;
  D.43102 = flags[13];
  D.43103 = D.43102 + 1;
  flags[13] = D.43103;
  D.43625 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43625 == 0)
    goto <bb 246>;
  else
    goto <bb 250>;

<bb 246>:
  D.43073 = session->channel;
  D.43628 = switch_channel_test_flag (D.43073, 106);
  if (D.43628 == 0)
    goto <bb 247>;
  else
    goto <bb 250>;

<bb 247>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 249>;
  else
    goto <bb 248>;

<bb 248>:
  D.43632 = switch_true (val);
  if (D.43632 == 0)
    goto <bb 249>;
  else
    goto <bb 250>;

<bb 249>:
  D.43114 = flags[7];
  D.43115 = D.43114 + 1;
  flags[7] = D.43115;

<bb 250>:
  timer_name = 0B;
  D.43073 = session->channel;
  D.43633 = switch_channel_get_name (D.43073);
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43592 = v_engine->local_sdp_port;
  D.43593 = (int) D.43592;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43584 = (int) D.43565;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  D.43595 = (int) D.43594;
  D.43634 = v_engine->read_impl.microseconds_per_packet;
  D.43635 = D.43634 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5334, session, 7, "PROXY VIDEO RTP [%s] %s:%d->%s:%d codec: %u ms: %d\n", D.43633, D.43172, D.43593, D.43578, D.43584, D.43595, D.43635);
  D.43096 = v_engine->rtp_session;
  D.43636 = switch_rtp_ready (D.43096);
  if (D.43636 != 0)
    goto <bb 251>;
  else
    goto <bb 254>;

<bb 251>:
  D.43096 = v_engine->rtp_session;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  switch_rtp_set_default_payload (D.43096, D.43594);
  goto <bb 254>;

<bb 252>:
  D.43099 = smh->mparams;
  timer_name = D.43099->timer_name;
  D.43073 = session->channel;
  var = switch_channel_get_variable_dup (D.43073, "rtp_timer_name", 1, -1);
  if (var != 0B)
    goto <bb 253>;
  else
    goto <bb 254>;

<bb 253>:
  timer_name = var;

<bb 254>:
  D.43096 = v_engine->rtp_session;
  if (D.43096 != 0B)
    goto <bb 328> (video_up);
  else
    goto <bb 255>;

<bb 255>:
  D.43592 = v_engine->local_sdp_port;
  if (D.43592 == 0)
    goto <bb 256>;
  else
    goto <bb 257>;

<bb 256>:
  switch_core_media_choose_port (session, 1, 1);

<bb 257>:
  memset (&flags, 0, 156);
  D.43102 = flags[13];
  D.43103 = D.43102 + 1;
  flags[13] = D.43103;
  D.43137 = flags[8];
  D.43138 = D.43137 + 1;
  flags[8] = D.43138;
  D.43647 = switch_media_handle_test_media_flag (smh, 10);
  if (D.43647 == 0)
    goto <bb 258>;
  else
    goto <bb 263>;

<bb 258>:
  D.43073 = session->channel;
  D.43650 = switch_channel_test_flag (D.43073, 15);
  if (D.43650 == 0)
    goto <bb 259>;
  else
    goto <bb 263>;

<bb 259>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 261>;
  else
    goto <bb 260>;

<bb 260>:
  D.43654 = switch_true (val);
  if (D.43654 == 0)
    goto <bb 261>;
  else
    goto <bb 263>;

<bb 261>:
  D.43073 = session->channel;
  D.43655 = switch_channel_test_flag (D.43073, 106);
  if (D.43655 == 0)
    goto <bb 262>;
  else
    goto <bb 263>;

<bb 262>:
  D.43114 = flags[7];
  D.43115 = D.43114 + 1;
  flags[7] = D.43115;

<bb 263>:
  D.43073 = session->channel;
  D.43658 = switch_channel_test_flag (D.43073, 29);
  if (D.43658 != 0)
    goto <bb 264>;
  else
    goto <bb 265>;

<bb 264>:
  D.43270 = flags[19];
  D.43271 = D.43270 + 1;
  flags[19] = D.43271;

<bb 265>:
  switch_core_media_set_video_codec (session, 0);
  flags[3] = 0;
  flags[0] = 0;
  D.43661 = flags[30];
  D.43662 = D.43661 + 1;
  flags[30] = D.43662;
  D.43184 = a_engine->local_sdp_ip;
  D.43592 = v_engine->local_sdp_port;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  D.43663 = switch_core_session_get_pool (session);
  D.43664 = switch_rtp_new (D.43184, D.43592, D.43578, D.43565, D.43594, 1, 90000, &flags, 0B, &err, D.43663);
  v_engine->rtp_session = D.43664;
  D.43073 = session->channel;
  D.43666 = switch_channel_test_flag (D.43073, 29);
  if (D.43666 != 0)
    goto <bb 266>;
  else
    goto <bb 267>;

<bb 266>:
  iftmp.61 = "PROXY ";
  goto <bb 268>;

<bb 267>:
  iftmp.61 = "";

<bb 268>:
  D.43073 = session->channel;
  D.43670 = switch_channel_get_name (D.43073);
  D.43171 = a_engine->cur_payload_map;
  D.43172 = D.43171->remote_sdp_ip;
  D.43592 = v_engine->local_sdp_port;
  D.43593 = (int) D.43592;
  D.43561 = v_engine->cur_payload_map;
  D.43578 = D.43561->remote_sdp_ip;
  D.43561 = v_engine->cur_payload_map;
  D.43565 = D.43561->remote_sdp_port;
  D.43584 = (int) D.43565;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  D.43595 = (int) D.43594;
  D.43096 = v_engine->rtp_session;
  D.43672 = switch_rtp_ready (D.43096);
  if (D.43672 == 0)
    goto <bb 269>;
  else
    goto <bb 270>;

<bb 269>:
  iftmp.62 = err;
  goto <bb 271>;

<bb 270>:
  iftmp.62 = "SUCCESS";

<bb 271>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5391, session, 7, "%sVIDEO RTP [%s] %s:%d->%s:%d codec: %u ms: %d [%s]\n", iftmp.61, D.43670, D.43172, D.43593, D.43578, D.43584, D.43595, 0, iftmp.62);
  D.43096 = v_engine->rtp_session;
  D.43676 = switch_rtp_ready (D.43096);
  if (D.43676 != 0)
    goto <bb 272>;
  else
    goto <bb 320>;

<bb 272>:
  D.43679 = v_engine->fir;
  if (D.43679 != 0)
    goto <bb 273>;
  else
    goto <bb 274>;

<bb 273>:
  D.43096 = v_engine->rtp_session;
  switch_rtp_set_flag (D.43096, 36);

<bb 274>:
  D.43682 = v_engine->pli;
  if (D.43682 != 0)
    goto <bb 275>;
  else
    goto <bb 276>;

<bb 275>:
  D.43096 = v_engine->rtp_session;
  switch_rtp_set_flag (D.43096, 37);

<bb 276>:
  D.43096 = v_engine->rtp_session;
  D.43685 = &v_engine->payload_map;
  switch_rtp_set_payload_map (D.43096, D.43685);
  start_video_thread (session);
  D.43073 = session->channel;
  switch_channel_set_flag_value (D.43073, 23, 1);
  D.43073 = session->channel;
  ssrc = switch_channel_get_variable_dup (D.43073, "rtp_use_video_ssrc", 1, -1);
  if (ssrc != 0B)
    goto <bb 277>;
  else
    goto <bb 278>;

<bb 277>:
  ssrc_ul = strtoul (ssrc, 0B, 10);
  D.43096 = v_engine->rtp_session;
  switch_rtp_set_ssrc (D.43096, ssrc_ul);
  v_engine->ssrc = ssrc_ul;
  goto <bb 279>;

<bb 278>:
  D.43096 = v_engine->rtp_session;
  D.43689 = v_engine->ssrc;
  switch_rtp_set_ssrc (D.43096, D.43689);

<bb 279>:
  D.43690 = v_engine->remote_ssrc;
  if (D.43690 != 0)
    goto <bb 280>;
  else
    goto <bb 281>;

<bb 280>:
  D.43096 = v_engine->rtp_session;
  D.43690 = v_engine->remote_ssrc;
  switch_rtp_set_remote_ssrc (D.43096, D.43690);

<bb 281>:
  D.43693 = v_engine->ice_in.chosen[0];
  D.43694 = v_engine->ice_in.cands[D.43693][0].ready;
  if (D.43694 != 0)
    goto <bb 282>;
  else
    goto <bb 286>;

<bb 282>:
  gen_ice (session, 1, 0B, 0);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5433, session, 6, "Activating Video ICE\n");
  D.43096 = v_engine->rtp_session;
  D.43697 = v_engine->ice_in.ufrag;
  D.43698 = v_engine->ice_out.ufrag;
  D.43699 = v_engine->ice_out.pwd;
  D.43700 = v_engine->ice_in.pwd;
  D.43702 = switch_ice_direction (session);
  if (D.43702 == 1)
    goto <bb 283>;
  else
    goto <bb 284>;

<bb 283>:
  iftmp.63 = 2;
  goto <bb 285>;

<bb 284>:
  iftmp.63 = 6;

<bb 285>:
  D.43706 = &v_engine->ice_in;
  switch_rtp_activate_ice (D.43096, D.43697, D.43698, D.43699, D.43700, 0, iftmp.63, D.43706);

<bb 286>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtcp_video_interval_msec", 1, -1);
  if (val != 0B)
    goto <bb 288>;
  else
    goto <bb 287>;

<bb 287>:
  D.43099 = smh->mparams;
  val = D.43099->rtcp_video_interval_msec;
  if (val != 0B)
    goto <bb 288>;
  else
    goto <bb 304>;

<bb 288>:
  D.43073 = session->channel;
  rport = switch_channel_get_variable_dup (D.43073, "rtp_remote_video_rtcp_port", 1, -1);
  remote_port = v_engine->remote_rtcp_port;
  if (rport != 0B)
    goto <bb 289>;
  else
    goto <bb 290>;

<bb 289>:
  D.43712 = atoi (rport);
  remote_port = (switch_port_t) D.43712;

<bb 290>:
  D.43713 = strcasecmp (val, "passthru");
  if (D.43713 == 0)
    goto <bb 291>;
  else
    goto <bb 292>;

<bb 291>:
  D.43716 = (int) remote_port;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5462, session, 6, "Activating VIDEO RTCP PASSTHRU PORT %d\n", D.43716);
  D.43096 = v_engine->rtp_session;
  D.43717 = v_engine->rtcp_mux;
  D.43718 = D.43717 > 0;
  switch_rtp_activate_rtcp (D.43096, -1, remote_port, D.43718);
  goto <bb 295>;

<bb 292>:
  interval = atoi (val);
  interval.64 = (unsigned int) interval;
  D.43721 = interval.64 + 4294967196;
  if (D.43721 > 499900)
    goto <bb 293>;
  else
    goto <bb 294>;

<bb 293>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5467, session, 3, "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);

<bb 294>:
  interval = 10000;
  D.43716 = (int) remote_port;
  D.43717 = v_engine->rtcp_mux;
  D.43724 = (int) D.43717;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5471, session, 6, "Activating VIDEO RTCP PORT %d mux %d\n", D.43716, D.43724);
  D.43096 = v_engine->rtp_session;
  D.43717 = v_engine->rtcp_mux;
  D.43718 = D.43717 > 0;
  switch_rtp_activate_rtcp (D.43096, interval, remote_port, D.43718);

<bb 295>:
  D.43725 = v_engine->ice_in.chosen[1];
  D.43726 = v_engine->ice_in.cands[D.43725][1].ready;
  if (D.43726 != 0)
    goto <bb 296>;
  else
    goto <bb 304>;

<bb 296>:
  D.43717 = v_engine->rtcp_mux;
  if (D.43717 > 0)
    goto <bb 297>;
  else
    goto <bb 300>;

<bb 297>:
  D.43725 = v_engine->ice_in.chosen[1];
  D.43732 = v_engine->ice_in.cands[D.43725][1].con_addr;
  D.43693 = v_engine->ice_in.chosen[0];
  D.43733 = v_engine->ice_in.cands[D.43693][0].con_addr;
  D.39417 = __builtin_strcmp (D.43732, D.43733);
  if (D.39417 == 0)
    goto <bb 298>;
  else
    goto <bb 300>;

<bb 298>:
  D.43725 = v_engine->ice_in.chosen[1];
  D.43735 = v_engine->ice_in.cands[D.43725][1].con_port;
  D.43693 = v_engine->ice_in.chosen[0];
  D.43736 = v_engine->ice_in.cands[D.43693][0].con_port;
  if (D.43735 == D.43736)
    goto <bb 299>;
  else
    goto <bb 300>;

<bb 299>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5481, session, 6, "Skipping VIDEO RTCP ICE (Same as VIDEO RTP)\n");
  goto <bb 304>;

<bb 300>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5484, session, 6, "Activating VIDEO RTCP ICE\n");
  D.43096 = v_engine->rtp_session;
  D.43697 = v_engine->ice_in.ufrag;
  D.43698 = v_engine->ice_out.ufrag;
  D.43699 = v_engine->ice_out.pwd;
  D.43700 = v_engine->ice_in.pwd;
  D.43739 = switch_ice_direction (session);
  if (D.43739 == 1)
    goto <bb 301>;
  else
    goto <bb 302>;

<bb 301>:
  iftmp.65 = 2;
  goto <bb 303>;

<bb 302>:
  iftmp.65 = 6;

<bb 303>:
  D.43706 = &v_engine->ice_in;
  switch_rtp_activate_ice (D.43096, D.43697, D.43698, D.43699, D.43700, 1, iftmp.65, D.43706);

<bb 304>:
  D.43743 = &v_engine->local_dtls_fingerprint.str;
  D.43744 = _zstr (D.43743);
  if (D.43744 == 0)
    goto <bb 305>;
  else
    goto <bb 316>;

<bb 305>:
  D.43747 = switch_rtp_has_dtls ();
  if (D.43747 != 0)
    goto <bb 306>;
  else
    goto <bb 316>;

<bb 306>:
  D.43429 = smh->session;
  D.43750 = dtls_ok (D.43429);
  if (D.43750 != 0)
    goto <bb 307>;
  else
    goto <bb 316>;

<bb 307>:
  D.43429 = smh->session;
  D.43434 = D.43429->channel;
  D.43754 = switch_channel_direction (D.43434);
  if (D.43754 == 0)
    goto <bb 308>;
  else
    goto <bb 309>;

<bb 308>:
  iftmp.66 = 1;
  goto <bb 310>;

<bb 309>:
  iftmp.66 = 2;

<bb 310>:
  dtype = iftmp.66;
  xtype = 4;
  D.43717 = v_engine->rtcp_mux;
  if (D.43717 > 0)
    goto <bb 311>;
  else
    goto <bb 313>;

<bb 311>:
  D.43099 = smh->mparams;
  D.43760 = D.43099->rtcp_video_interval_msec;
  if (D.43760 != 0B)
    goto <bb 312>;
  else
    goto <bb 313>;

<bb 312>:
  xtype = xtype | 8;

<bb 313>:
  D.43096 = v_engine->rtp_session;
  D.43763 = &v_engine->local_dtls_fingerprint;
  D.43764 = &v_engine->remote_dtls_fingerprint;
  D.43765 = dtype | xtype;
  switch_rtp_add_dtls (D.43096, D.43763, D.43764, D.43765);
  D.43717 = v_engine->rtcp_mux;
  if (D.43717 <= 0)
    goto <bb 314>;
  else
    goto <bb 316>;

<bb 314>:
  D.43099 = smh->mparams;
  D.43760 = D.43099->rtcp_video_interval_msec;
  if (D.43760 != 0B)
    goto <bb 315>;
  else
    goto <bb 316>;

<bb 315>:
  xtype = 8;
  D.43096 = v_engine->rtp_session;
  D.43763 = &v_engine->local_dtls_fingerprint;
  D.43764 = &v_engine->remote_dtls_fingerprint;
  D.43765 = dtype | xtype;
  switch_rtp_add_dtls (D.43096, D.43763, D.43764, D.43765);

<bb 316>:
  D.43073 = session->channel;
  val = switch_channel_get_variable_dup (D.43073, "rtp_manual_video_rtp_bugs", 1, -1);
  if (val != 0B)
    goto <bb 317>;
  else
    goto <bb 318>;

<bb 317>:
  D.43772 = &v_engine->rtp_bugs;
  switch_core_media_parse_rtp_bugs (D.43772, val);

<bb 318>:
  D.43096 = v_engine->rtp_session;
  D.43773 = v_engine->rtp_bugs;
  D.43099 = smh->mparams;
  D.43774 = D.43099->manual_video_rtp_bugs;
  D.43775 = D.43773 | D.43774;
  switch_rtp_intentional_bugs (D.43096, D.43775);
  D.43073 = session->channel;
  D.43561 = v_engine->cur_payload_map;
  D.43594 = D.43561->agreed_pt;
  D.43595 = (int) D.43594;
  switch_channel_set_variable_printf (D.43073, "rtp_use_video_pt", "%d", D.43595);
  D.43096 = v_engine->rtp_session;
  D.43776 = switch_rtp_get_ssrc (D.43096);
  v_engine->ssrc = D.43776;
  D.43073 = session->channel;
  D.43689 = v_engine->ssrc;
  switch_channel_set_variable_printf (D.43073, "rtp_use_video_ssrc", "%u", D.43689);
  switch_core_session_apply_crypto (session, 1);
  D.43073 = session->channel;
  D.43777 = switch_channel_test_flag (D.43073, 74);
  if (D.43777 != 0)
    goto <bb 319>;
  else
    goto <bb 328> (video_up);

<bb 319>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5542, session, 7, "Activating video UDPTL mode\n");
  D.43096 = v_engine->rtp_session;
  switch_rtp_udptl_mode (D.43096);
  goto <bb 328> (video_up);

<bb 320>:
  err.45 = err;
  if (err.45 != 0B)
    goto <bb 321>;
  else
    goto <bb 322>;

<bb 321>:
  iftmp.67 = err;
  goto <bb 323>;

<bb 322>:
  iftmp.67 = "";

<bb 323>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5547, session, 3, "VIDEO RTP REPORTS ERROR: [%s]\n", iftmp.67);
  D.43073 = session->channel;
  switch_channel_perform_hangup (D.43073, "src/switch_core_media.c", &__func__, 5548, 27);
  goto <bb 331> (end);

<bb 324>:
  err.45 = err;
  if (err.45 != 0B)
    goto <bb 325>;
  else
    goto <bb 326>;

<bb 325>:
  iftmp.68 = err;
  goto <bb 327>;

<bb 326>:
  iftmp.68 = "";

<bb 327>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 5554, session, 3, "AUDIO RTP REPORTS ERROR: [%s]\n", iftmp.68);
  D.43073 = session->channel;
  switch_channel_perform_hangup (D.43073, "src/switch_core_media.c", &__func__, 5555, 27);
  status = 1;
  goto <bb 331> (end);

video_up:
  D.43262 = session != 0B;
  D.43790 = v_engine != 0B;
  D.43791 = D.43262 && D.43790;
  if (D.43791 != 0)
    goto <bb 329>;
  else
    goto <bb 330>;

<bb 329>:
  check_dtls_reinvite (session, v_engine);

<bb 330>:
  status = 0;

end:
  D.43073 = session->channel;
  switch_channel_clear_flag (D.43073, 103);
  switch_core_recovery_track (session);
  D.43070 = status;

<bb 332>:
  return D.43070;

}



;; Function start_video_thread (start_video_thread)

Scope blocks:

{ Scope block #0 
  struct switch_threadattr_t * thd_attr; (unused)
  struct switch_memory_pool_t * pool; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __func__[19] = "start_video_thread"; (unused)

}
start_video_thread (struct switch_core_session_t * session)
{
  static const char __func__[19] = "start_video_thread";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_memory_pool_t * pool;
  struct switch_threadattr_t * thd_attr;
  struct switch_memory_pool_t * D.43812;
  struct media_helper * D.43811;
  struct switch_thread_t * * D.43810;
  struct switch_mutex_t * * D.43809;
  struct switch_mutex_t * * D.43808;
  struct switch_thread_cond_t * * D.43807;
  struct switch_threadattr_t * thd_attr.69;
  switch_payload_t D.43805;
  struct payload_map_t * D.43804;
  struct switch_rtp_t * D.43803;
  char * D.43802;
  struct switch_channel_t * D.43801;
  struct switch_thread_t * D.43798;
  switch_status_t D.43797;

<bb 2>:
  thd_attr = 0B;
  pool = switch_core_session_get_pool (session);
  v_engine = 0B;
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.43797 = 1;
  goto <bb 7>;

<bb 4>:
  v_engine = &smh->engines[1];
  D.43798 = v_engine->media_thread;
  if (D.43798 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.43797 = 1;
  goto <bb 7>;

<bb 6>:
  D.43801 = switch_core_session_get_channel (session);
  D.43802 = switch_channel_get_name (D.43801);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4120, session, 5, "%s Starting Video thread\n", D.43802);
  D.43803 = v_engine->rtp_session;
  D.43804 = v_engine->cur_payload_map;
  D.43805 = D.43804->agreed_pt;
  switch_rtp_set_default_payload (D.43803, D.43805);
  v_engine->mh.session = session;
  switch_threadattr_create (&thd_attr, pool);
  thd_attr.69 = thd_attr;
  switch_threadattr_stacksize_set (thd_attr.69, 245760);
  D.43807 = &v_engine->mh.cond;
  switch_thread_cond_create (D.43807, pool);
  D.43808 = &v_engine->mh.cond_mutex;
  switch_mutex_init (D.43808, 1, pool);
  D.43809 = &v_engine->read_mutex[1];
  switch_mutex_init (D.43809, 1, pool);
  D.43810 = &v_engine->media_thread;
  thd_attr.69 = thd_attr;
  D.43811 = &v_engine->mh;
  D.43812 = switch_core_session_get_pool (session);
  switch_thread_create (D.43810, thd_attr.69, video_helper_thread, D.43811, D.43812);
  D.43797 = 0;

<bb 7>:
  return D.43797;

}



;; Function video_helper_thread (video_helper_thread)

Scope blocks:

{ Scope block #0 
  struct media_helper * mh; (unused)
  struct switch_core_session_t * session; (unused)
  struct switch_channel_t * channel; (unused)
  switch_status_t status; (unused)
  struct switch_frame_t * read_frame; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __func__[20] = "video_helper_thread"; (unused)

}
video_helper_thread (struct switch_thread_t * thread, void * obj)
{
  static const char __func__[20] = "video_helper_thread";
  struct switch_media_handle_t * smh;
  struct switch_frame_t * read_frame;
  switch_status_t status;
  struct switch_channel_t * channel;
  struct switch_core_session_t * session;
  struct media_helper * mh;
  char * D.43871;
  switch_channel_state_t D.43870;
  uint32_t D.43867;
  _Bool D.43864;
  int D.43863;
  int D.43862;
  switch_frame_flag_t D.43861;
  struct switch_frame_t * read_frame.73;
  uint32_t D.43857;
  _Bool D.43852;
  _Bool D.43851;
  _Bool D.43850;
  uint32_t D.43847;
  uint32_t D.43844;
  uint32_t D.43841;
  uint32_t D.43837;
  char * iftmp.72;
  char * D.43835;
  struct switch_thread_cond_t * D.43834;
  uint32_t D.43830;
  char * iftmp.71;
  char * D.43828;
  uint32_t D.43825;
  uint32_t D.43821;
  char * iftmp.70;
  char * D.43819;
  struct switch_channel_t * D.43818;
  struct switch_mutex_t * D.43817;
  void * D.43816;

<bb 2>:
  mh = obj;
  session = mh->session;
  channel = switch_core_session_get_channel (session);
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.43816 = 0B;
  goto <bb 32>;

<bb 4>:
  switch_core_session_read_lock (session);
  mh->up = 1;
  D.43817 = mh->cond_mutex;
  switch_mutex_lock (D.43817);
  D.43818 = session->channel;
  D.43819 = switch_channel_get_name (D.43818);
  D.43821 = switch_channel_test_flag (channel, 115);
  if (D.43821 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  iftmp.70 = "on";
  goto <bb 7>;

<bb 6>:
  iftmp.70 = "off";

<bb 7>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4044, 0B, 7, "%s Video thread started. Echo is %s\n", D.43819, iftmp.70);
  switch_core_session_refresh_video (session);
  goto <bb 30>;

<bb 8>:
  D.43825 = switch_channel_test_flag (channel, 113);
  if (D.43825 != 0)
    goto <bb 9>;
  else
    goto <bb 16>;

<bb 9>:
  D.43818 = session->channel;
  D.43828 = switch_channel_get_name (D.43818);
  D.43830 = switch_channel_test_flag (channel, 115);
  if (D.43830 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  iftmp.71 = "on";
  goto <bb 12>;

<bb 11>:
  iftmp.71 = "off";

<bb 12>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4051, 0B, 7, "%s Video thread paused. Echo is %s\n", D.43828, iftmp.71);
  D.43834 = mh->cond;
  D.43817 = mh->cond_mutex;
  switch_thread_cond_wait (D.43834, D.43817);
  D.43818 = session->channel;
  D.43835 = switch_channel_get_name (D.43818);
  D.43837 = switch_channel_test_flag (channel, 115);
  if (D.43837 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  iftmp.72 = "on";
  goto <bb 15>;

<bb 14>:
  iftmp.72 = "off";

<bb 15>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4054, 0B, 7, "%s Video thread resumed  Echo is %s\n", D.43835, iftmp.72);
  switch_core_session_refresh_video (session);

<bb 16>:
  D.43841 = switch_channel_test_flag (channel, 113);
  if (D.43841 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  // predicted unlikely by continue predictor.
  goto <bb 30>;

<bb 18>:
  D.43818 = session->channel;
  D.43844 = switch_channel_test_flag (D.43818, 1);
  if (D.43844 == 0)
    goto <bb 19>;
  else
    goto <bb 21>;

<bb 19>:
  D.43818 = session->channel;
  D.43847 = switch_channel_test_flag (D.43818, 3);
  if (D.43847 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  switch_sleep (10000);
  // predicted unlikely by continue predictor.
  goto <bb 30>;

<bb 21>:
  status = switch_core_session_read_video_frame (session, &read_frame, 0, 0);
  D.43850 = status != 0;
  D.43851 = status != 11;
  D.43852 = D.43850 && D.43851;
  if (D.43852 != 0)
    goto <bb 22>;
  else
    goto <bb 24>;

<bb 22>:
  if (status != 10)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  switch_cond_next ();
  // predicted unlikely by continue predictor.
  goto <bb 30>;

<bb 24>:
  D.43857 = switch_channel_test_flag (channel, 70);
  if (D.43857 != 0)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  switch_core_session_refresh_video (session);
  switch_channel_clear_flag (channel, 70);

<bb 26>:
  read_frame.73 = read_frame;
  D.43861 = read_frame.73->flags;
  D.43862 = (int) D.43861;
  D.43863 = D.43862 & 1;
  D.43864 = (_Bool) D.43863;
  if (D.43864 != 0)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  // predicted unlikely by continue predictor.
  goto <bb 30>;

<bb 28>:
  D.43867 = switch_channel_test_flag (channel, 115);
  if (D.43867 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  read_frame.73 = read_frame;
  switch_core_session_write_video_frame (session, read_frame.73, 0, 0);

<bb 30>:
  D.43870 = switch_channel_get_state (channel);
  if (D.43870 <= 9)
    goto <bb 8>;
  else
    goto <bb 31>;

<bb 31>:
  D.43818 = session->channel;
  D.43871 = switch_channel_get_name (D.43818);
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4093, 0B, 7, "%s Video thread ended\n", D.43871);
  D.43817 = mh->cond_mutex;
  switch_mutex_unlock (D.43817);
  switch_core_session_rwunlock (session);
  mh->up = 0;
  D.43816 = 0B;

<bb 32>:
  return D.43816;

}



;; Function switch_core_session_apply_crypto (switch_core_session_apply_crypto)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)
  const char * varname; (unused)

}
Removing basic block 6
;; basic block 6, loop depth 0, count 0
;; prev block 5, next block 7
;; pred:      
;; succ:       12 (fallthru)
<bb 6>:
goto <bb 12>;


Removing basic block 8
;; basic block 8, loop depth 0, count 0
;; prev block 7, next block 9
;; pred:      
;; succ:       12 (fallthru)
<bb 8>:
goto <bb 12>;


switch_core_session_apply_crypto (struct switch_core_session_t * session, switch_media_type_t type)
{
  const char * varname;
  struct switch_rtp_engine_t * engine;
  char * D.43903;
  unsigned char[64] * D.43902;
  uint32_t D.43901;
  int D.43900;
  switch_size_t D.43899;
  int D.43898;
  unsigned char[64] * D.43897;
  switch_rtp_crypto_key_type_t D.43896;
  struct switch_rtp_t * D.43895;
  struct switch_secure_settings_t * D.43894;
  unsigned int D.43893;
  struct switch_secure_settings_t[10] * D.43892;
  uint32_t D.43889;
  char * D.43886;
  switch_rtp_crypto_key_type_t D.43885;
  uint32_t D.43882;
  struct switch_channel_t * D.43881;
  unsigned int D.43880;
  struct switch_rtp_engine_t[2] * D.43879;
  struct switch_media_handle_t * D.43876;

<bb 2>:
  if (type == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  varname = "rtp_secure_audio_confirmed";
  goto <bb 5>;

<bb 4>:
  varname = "rtp_secure_video_confirmed";

<bb 5>:
  D.43876 = session->media_handle;
  if (D.43876 == 0B)
    goto <bb 10>;
  else
    goto <bb 6>;

<bb 6>:
  D.43876 = session->media_handle;
  D.43879 = &D.43876->engines;
  D.43880 = type * 11416;
  engine = D.43879 + D.43880;
  D.43881 = session->channel;
  D.43882 = switch_channel_test_flag (D.43881, 84);
  if (D.43882 != 0)
    goto <bb 10>;
  else
    goto <bb 7>;

<bb 7>:
  D.43885 = engine->crypto_type;
  D.43886 = engine->ssec[D.43885].remote_crypto_key;
  if (D.43886 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

<bb 8>:
  D.43881 = session->channel;
  D.43889 = switch_channel_test_flag (D.43881, 92);
  if (D.43889 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.43892 = &engine->ssec;
  D.43885 = engine->crypto_type;
  D.43893 = D.43885 * 144;
  D.43894 = D.43892 + D.43893;
  D.43885 = engine->crypto_type;
  D.43886 = engine->ssec[D.43885].remote_crypto_key;
  switch_core_media_add_crypto (D.43894, D.43886, 1);
  D.43895 = engine->rtp_session;
  D.43885 = engine->crypto_type;
  D.43896 = engine->ssec[D.43885].crypto_type;
  D.43885 = engine->crypto_type;
  D.43897 = &engine->ssec[D.43885].local_raw_key;
  D.43885 = engine->crypto_type;
  D.43896 = engine->ssec[D.43885].crypto_type;
  D.43898 = SUITES[D.43896].keylen;
  D.43899 = (switch_size_t) D.43898;
  switch_rtp_add_crypto_key (D.43895, 0, 1, D.43896, D.43897, D.43899);
  D.43895 = engine->rtp_session;
  D.43885 = engine->crypto_type;
  D.43900 = engine->ssec[D.43885].crypto_tag;
  D.43901 = (uint32_t) D.43900;
  D.43885 = engine->crypto_type;
  D.43896 = engine->ssec[D.43885].crypto_type;
  D.43885 = engine->crypto_type;
  D.43902 = &engine->ssec[D.43885].remote_raw_key;
  D.43885 = engine->crypto_type;
  D.43896 = engine->ssec[D.43885].crypto_type;
  D.43898 = SUITES[D.43896].keylen;
  D.43899 = (switch_size_t) D.43898;
  switch_rtp_add_crypto_key (D.43895, 1, D.43901, D.43896, D.43902, D.43899);
  D.43881 = session->channel;
  switch_channel_set_variable_var_check (D.43881, varname, "true", 1);
  D.43881 = session->channel;
  D.43885 = engine->crypto_type;
  D.43903 = SUITES[D.43885].name;
  switch_channel_set_variable_var_check (D.43881, "rtp_secure_media_negotiated", D.43903, 1);

<bb 10>:
  return;

}



;; Function check_dtls_reinvite (check_dtls_reinvite)

Scope blocks:

{ Scope block #0 
  static const char __func__[20] = "check_dtls_reinvite"; (unused)

  { Scope block #0 
    dtls_type_t xtype; (unused)
    dtls_type_t dtype; (unused)

  }

}
check_dtls_reinvite (struct switch_core_session_t * session, struct switch_rtp_engine_t * engine)
{
  dtls_type_t dtype;
  dtls_type_t xtype;
  static const char __func__[20] = "check_dtls_reinvite";
  unsigned int D.43935;
  struct dtls_fingerprint_t * D.43934;
  struct dtls_fingerprint_t * D.43933;
  struct switch_rtp_t * D.43932;
  int8_t D.43929;
  switch_media_type_t D.43925;
  char * iftmp.75;
  switch_call_direction_t D.43920;
  dtls_type_t iftmp.74;
  int D.43916;
  int D.43913;
  int D.43910;
  char[192] * D.43909;
  uint32_t D.43906;
  struct switch_channel_t * D.43905;

<bb 2>:
  D.43905 = session->channel;
  D.43906 = switch_channel_test_flag (D.43905, 103);
  if (D.43906 != 0)
    goto <bb 3>;
  else
    goto <bb 16>;

<bb 3>:
  D.43909 = &engine->local_dtls_fingerprint.str;
  D.43910 = _zstr (D.43909);
  if (D.43910 == 0)
    goto <bb 4>;
  else
    goto <bb 16>;

<bb 4>:
  D.43913 = switch_rtp_has_dtls ();
  if (D.43913 != 0)
    goto <bb 5>;
  else
    goto <bb 16>;

<bb 5>:
  D.43916 = dtls_ok (session);
  if (D.43916 != 0)
    goto <bb 6>;
  else
    goto <bb 16>;

<bb 6>:
  D.43920 = switch_ice_direction (session);
  if (D.43920 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  iftmp.74 = 1;
  goto <bb 9>;

<bb 8>:
  iftmp.74 = 2;

<bb 9>:
  dtype = iftmp.74;
  D.43925 = engine->type;
  if (D.43925 == 1)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  iftmp.75 = "video";
  goto <bb 12>;

<bb 11>:
  iftmp.75 = "audio";

<bb 12>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4701, session, 6, "RE-SETTING %s DTLS\n", iftmp.75);
  xtype = 4;
  D.43929 = engine->rtcp_mux;
  if (D.43929 > 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  xtype = xtype | 8;

<bb 14>:
  D.43932 = engine->rtp_session;
  D.43933 = &engine->local_dtls_fingerprint;
  D.43934 = &engine->remote_dtls_fingerprint;
  D.43935 = dtype | xtype;
  switch_rtp_add_dtls (D.43932, D.43933, D.43934, D.43935);
  D.43929 = engine->rtcp_mux;
  if (D.43929 <= 0)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  xtype = 8;
  D.43932 = engine->rtp_session;
  D.43933 = &engine->local_dtls_fingerprint;
  D.43934 = &engine->remote_dtls_fingerprint;
  D.43935 = dtype | xtype;
  switch_rtp_add_dtls (D.43932, D.43933, D.43934, D.43935);

<bb 16>:
  return;

}



;; Function switch_core_session_wake_video_thread (switch_core_session_wake_video_thread)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       8 (fallthru)
<bb 3>:
goto <bb 8>;


Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       8 (fallthru)
<bb 5>:
goto <bb 8>;


switch_core_session_wake_video_thread (struct switch_core_session_t * session)
{
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  struct switch_thread_cond_t * D.43947;
  switch_status_t D.43944;
  struct switch_mutex_t * D.43943;
  struct switch_rtp_t * D.43940;

<bb 2>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 6>;
  else
    goto <bb 3>;

<bb 3>:
  v_engine = &smh->engines[1];
  D.43940 = v_engine->rtp_session;
  if (D.43940 == 0B)
    goto <bb 6>;
  else
    goto <bb 4>;

<bb 4>:
  D.43943 = v_engine->mh.cond_mutex;
  D.43944 = switch_mutex_trylock (D.43943);
  if (D.43944 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.43947 = v_engine->mh.cond;
  switch_thread_cond_broadcast (D.43947);
  D.43943 = v_engine->mh.cond_mutex;
  switch_mutex_unlock (D.43943);

<bb 6>:
  return;

}



;; Function switch_core_media_deactivate_rtp (switch_core_media_deactivate_rtp)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_deactivate_rtp"; (unused)

  { Scope block #0 
    switch_status_t st; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       24 (fallthru)
<bb 5>:
goto <bb 24>;


switch_core_media_deactivate_rtp (struct switch_core_session_t * session)
{
  switch_status_t st;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_deactivate_rtp";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  switch_port_t D.43993;
  int D.43990;
  int D.43987;
  switch_port_t D.43982;
  struct switch_rtp_t * * D.43980;
  struct switch_rtp_t * D.43977;
  switch_port_t D.43976;
  int D.43973;
  int D.43970;
  char * D.43969;
  char * D.43966;
  struct switch_core_media_params_t * D.43965;
  switch_port_t D.43962;
  struct switch_rtp_t * * D.43960;
  struct switch_rtp_t * D.43957;
  struct switch_channel_t * D.43956;
  struct switch_thread_t * D.43953;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4554, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 23>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.43953 = v_engine->media_thread;
  if (D.43953 != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.43956 = session->channel;
  switch_channel_clear_flag (D.43956, 113);
  v_engine->mh.up = 0;
  D.43953 = v_engine->media_thread;
  switch_thread_join (&st, D.43953);
  v_engine->media_thread = 0B;

<bb 7>:
  D.43957 = v_engine->rtp_session;
  if (D.43957 != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.43960 = &v_engine->rtp_session;
  switch_rtp_destroy (D.43960);
  goto <bb 11>;

<bb 9>:
  D.43962 = v_engine->local_sdp_port;
  if (D.43962 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.43965 = smh->mparams;
  D.43966 = D.43965->rtpip;
  D.43962 = v_engine->local_sdp_port;
  switch_rtp_release_port (D.43966, D.43962);

<bb 11>:
  D.43962 = v_engine->local_sdp_port;
  if (D.43962 != 0)
    goto <bb 12>;
  else
    goto <bb 15>;

<bb 12>:
  D.43965 = smh->mparams;
  D.43969 = D.43965->remote_ip;
  D.43970 = _zstr (D.43969);
  if (D.43970 == 0)
    goto <bb 13>;
  else
    goto <bb 15>;

<bb 13>:
  D.43965 = smh->mparams;
  D.43969 = D.43965->remote_ip;
  D.43973 = switch_core_media_check_nat (smh, D.43969);
  if (D.43973 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.43962 = v_engine->local_sdp_port;
  switch_nat_del_mapping (D.43962, 0);
  D.43962 = v_engine->local_sdp_port;
  D.43976 = D.43962 + 1;
  switch_nat_del_mapping (D.43976, 0);

<bb 15>:
  D.43977 = a_engine->rtp_session;
  if (D.43977 != 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.43980 = &a_engine->rtp_session;
  switch_rtp_destroy (D.43980);
  goto <bb 19>;

<bb 17>:
  D.43982 = a_engine->local_sdp_port;
  if (D.43982 != 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  D.43965 = smh->mparams;
  D.43966 = D.43965->rtpip;
  D.43982 = a_engine->local_sdp_port;
  switch_rtp_release_port (D.43966, D.43982);

<bb 19>:
  D.43982 = a_engine->local_sdp_port;
  if (D.43982 != 0)
    goto <bb 20>;
  else
    goto <bb 23>;

<bb 20>:
  D.43965 = smh->mparams;
  D.43969 = D.43965->remote_ip;
  D.43987 = _zstr (D.43969);
  if (D.43987 == 0)
    goto <bb 21>;
  else
    goto <bb 23>;

<bb 21>:
  D.43965 = smh->mparams;
  D.43969 = D.43965->remote_ip;
  D.43990 = switch_core_media_check_nat (smh, D.43969);
  if (D.43990 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.43982 = a_engine->local_sdp_port;
  switch_nat_del_mapping (D.43982, 0);
  D.43982 = a_engine->local_sdp_port;
  D.43993 = D.43982 + 1;
  switch_nat_del_mapping (D.43993, 0);

<bb 23>:
  return;

}



;; Function switch_core_media_choose_ports (switch_core_media_choose_ports)

Scope blocks:

{ Scope block #0 
  switch_status_t status; (unused)

}
Merging blocks 7 and 8
switch_core_media_choose_ports (struct switch_core_session_t * session, switch_bool_t audio, switch_bool_t video)
{
  switch_status_t status;
  switch_status_t D.44005;
  uint32_t D.44002;
  struct switch_channel_t * D.44001;

<bb 2>:
  status = 0;
  if (audio != 0)
    goto <bb 3>;
  else
    goto <bb 7>;

<bb 3>:
  status = switch_core_media_choose_port (session, 0, 0);
  if (status == 0)
    goto <bb 4>;
  else
    goto <bb 7>;

<bb 4>:
  if (video != 0)
    goto <bb 5>;
  else
    goto <bb 7>;

<bb 5>:
  switch_core_media_check_video_codecs (session);
  D.44001 = session->channel;
  D.44002 = switch_channel_test_flag (D.44001, 98);
  if (D.44002 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  switch_core_media_choose_port (session, 1, 0);

<bb 7>:
  D.44005 = status;
  return D.44005;

}



;; Function switch_core_media_choose_port (switch_core_media_choose_port)

Scope blocks:

{ Scope block #0 
  char * lookup_rtpip; (unused)
  switch_port_t sdp_port; (unused)
  const char * use_ip; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  const char * tstr; (unused)
  char vname[128]; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_choose_port"; (unused)
  static const char __func__[30] = "switch_core_media_choose_port"; (unused)

}
Removing basic block 25
;; basic block 25, loop depth 0, count 0
;; prev block 24, next block 26
;; pred:      
;; succ:       27 (fallthru)
<bb 25>:
goto <bb 27>;


switch_core_media_choose_port (struct switch_core_session_t * session, switch_media_type_t type, int force)
{
  static const char __func__[30] = "switch_core_media_choose_port";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_choose_port";
  char vname[128];
  const char * tstr;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  const char * use_ip;
  switch_port_t sdp_port;
  char * lookup_rtpip;
  char * D.44058;
  int D.44057;
  char * D.44056;
  char * D.44053;
  char * D.44052;
  switch_port_t sdp_port.78;
  switch_status_t D.44047;
  int D.44042;
  char * D.44041;
  int D.44037;
  int D.44035;
  char * D.44034;
  switch_port_t D.44029;
  switch_port_t sdp_port.77;
  switch_port_t D.44025;
  uint32_t D.44023;
  uint32_t D.44021;
  struct switch_channel_t * D.44020;
  char * lookup_rtpip.76;
  struct switch_core_media_params_t * D.44014;
  unsigned int D.44013;
  struct switch_rtp_engine_t[2] * D.44012;
  switch_status_t D.44011;

<bb 2>:
  use_ip = 0B;
  tstr = switch_media_type2str (type);
  vname = "";
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4450, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.44011 = 1;
  goto <bb 30>;

<bb 6>:
  D.44012 = &smh->engines;
  D.44013 = type * 11416;
  engine = D.44012 + D.44013;
  D.44014 = smh->mparams;
  lookup_rtpip.76 = D.44014->rtpip;
  lookup_rtpip = lookup_rtpip.76;
  if (force == 0)
    goto <bb 7>;
  else
    goto <bb 11>;

<bb 7>:
  D.44020 = session->channel;
  D.44021 = switch_channel_test_flag (D.44020, 15);
  if (D.44021 != 0)
    goto <bb 10>;
  else
    goto <bb 8>;

<bb 8>:
  D.44020 = session->channel;
  D.44023 = switch_channel_test_flag (D.44020, 29);
  if (D.44023 != 0)
    goto <bb 10>;
  else
    goto <bb 9>;

<bb 9>:
  D.44025 = engine->adv_sdp_port;
  if (D.44025 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.44011 = 0;
  goto <bb 30>;

<bb 11>:
  sdp_port.77 = engine->local_sdp_port;
  if (sdp_port.77 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  D.44014 = smh->mparams;
  lookup_rtpip.76 = D.44014->rtpip;
  sdp_port.77 = engine->local_sdp_port;
  switch_rtp_release_port (lookup_rtpip.76, sdp_port.77);

<bb 13>:
  D.44014 = smh->mparams;
  lookup_rtpip.76 = D.44014->rtpip;
  D.44029 = switch_rtp_request_port (lookup_rtpip.76);
  engine->local_sdp_port = D.44029;
  sdp_port.77 = engine->local_sdp_port;
  if (sdp_port.77 == 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4475, session, 2, "No %s RTP ports available!\n", tstr);
  D.44011 = 1;
  goto <bb 30>;

<bb 15>:
  D.44014 = smh->mparams;
  lookup_rtpip.76 = D.44014->rtpip;
  engine->local_sdp_ip = lookup_rtpip.76;
  sdp_port.77 = engine->local_sdp_port;
  sdp_port = sdp_port.77;
  D.44014 = smh->mparams;
  D.44034 = D.44014->remote_ip;
  D.44035 = _zstr (D.44034);
  if (D.44035 == 0)
    goto <bb 16>;
  else
    goto <bb 25>;

<bb 16>:
  D.44014 = smh->mparams;
  D.44034 = D.44014->remote_ip;
  D.44037 = switch_core_media_check_nat (smh, D.44034);
  if (D.44037 != 0)
    goto <bb 17>;
  else
    goto <bb 25>;

<bb 17>:
  sdp_port.77 = engine->local_sdp_port;
  switch_nat_add_mapping (sdp_port.77, 0, &sdp_port, 0);
  switch_snprintf (&vname, 128, "rtp_adv_%s_ip", tstr);
  D.44020 = session->channel;
  use_ip = switch_channel_get_variable_dup (D.44020, &vname, 1, -1);
  if (use_ip == 0B)
    goto <bb 18>;
  else
    goto <bb 20>;

<bb 18>:
  D.44014 = smh->mparams;
  D.44041 = D.44014->extrtpip;
  D.44042 = _zstr (D.44041);
  if (D.44042 == 0)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  D.44014 = smh->mparams;
  use_ip = D.44014->extrtpip;

<bb 20>:
  if (use_ip != 0B)
    goto <bb 21>;
  else
    goto <bb 24>;

<bb 21>:
  D.44047 = switch_core_media_ext_address_lookup (session, &lookup_rtpip, &sdp_port, use_ip);
  if (D.44047 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.44011 = 1;
  goto <bb 30>;

<bb 23>:
  use_ip = lookup_rtpip;
  goto <bb 26>;

<bb 24>:
  D.44014 = smh->mparams;
  use_ip = D.44014->rtpip;
  goto <bb 26>;

<bb 25>:
  D.44014 = smh->mparams;
  use_ip = D.44014->rtpip;

<bb 26>:
  sdp_port.78 = sdp_port;
  engine->adv_sdp_port = sdp_port.78;
  D.44014 = smh->mparams;
  D.44014 = smh->mparams;
  D.44052 = switch_core_perform_session_strdup (session, use_ip, "src/switch_core_media.c", &__func__, 4515);
  D.44014->extrtpip = D.44052;
  D.44041 = D.44014->extrtpip;
  D.44014->adv_sdp_audio_ip = D.44041;
  D.44053 = D.44014->adv_sdp_audio_ip;
  engine->adv_sdp_ip = D.44053;
  if (type == 0)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  D.44020 = session->channel;
  D.44056 = engine->local_sdp_ip;
  switch_channel_set_variable_var_check (D.44020, "local_media_ip", D.44056, 1);
  D.44020 = session->channel;
  sdp_port.78 = sdp_port;
  D.44057 = (int) sdp_port.78;
  switch_channel_set_variable_printf (D.44020, "local_media_port", "%d", D.44057);
  D.44020 = session->channel;
  D.44058 = engine->adv_sdp_ip;
  switch_channel_set_variable_var_check (D.44020, "advertised_media_ip", D.44058, 1);
  goto <bb 29>;

<bb 28>:
  D.44020 = session->channel;
  D.44058 = engine->adv_sdp_ip;
  switch_channel_set_variable_var_check (D.44020, "local_video_ip", D.44058, 1);
  D.44020 = session->channel;
  sdp_port.78 = sdp_port;
  D.44057 = (int) sdp_port.78;
  switch_channel_set_variable_printf (D.44020, "local_video_port", "%d", D.44057);

<bb 29>:
  D.44011 = 0;

<bb 30>:
  return D.44011;

}



;; Function switch_media_type2str (switch_media_type2str)

Scope blocks:

{ Scope block #0 

}
switch_media_type2str (switch_media_type_t type)
{
  const char * D.44061;

<bb 2>:
  switch (type) <default: <L2>, case 0: <L0>, case 1: <L1>>

<L0>:
  D.44061 = "audio";
  goto <bb 6>;

<L1>:
  D.44061 = "video";
  goto <bb 6>;

<L2>:
  D.44061 = "!ERR";

<bb 6>:
  return D.44061;

}



;; Function switch_core_media_reset_autofix (switch_core_media_reset_autofix)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_reset_autofix"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       7 (fallthru)
<bb 5>:
goto <bb 7>;


switch_core_media_reset_autofix (struct switch_core_session_t * session, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_reset_autofix";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  unsigned int D.44068;
  struct switch_rtp_engine_t[2] * D.44067;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4425, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

<bb 5>:
  D.44067 = &smh->engines;
  D.44068 = type * 11416;
  engine = D.44067 + D.44068;
  engine->check_frames = 0;
  engine->last_ts = 0;

<bb 6>:
  return;

}



;; Function switch_core_media_ext_address_lookup (switch_core_media_ext_address_lookup)

Scope blocks:

{ Scope block #0 
  char * error; (unused)
  switch_status_t status; (unused)
  int x; (unused)
  switch_port_t myport; (unused)
  switch_port_t stun_port; (unused)
  char * stun_ip; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_memory_pool_t * pool; (unused)
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_ext_address_lookup"; (unused)
  static const char __func__[37] = "switch_core_media_ext_address_lookup"; (unused)
  void out = <<< error >>>; (unused)

  { Scope block #0 
    char * p; (unused)

    { Scope block #0 
      int iport; (unused)

    }

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

  }

}
Removing basic block 28
;; basic block 28, loop depth 0, count 0
;; prev block 27, next block 29
;; pred:      
;; succ:       30 (fallthru)
<bb 28>:
goto <bb 30> (out);


switch_core_media_ext_address_lookup (struct switch_core_session_t * session, char * * ip, switch_port_t * port, const char * sourceip)
{
  size_t __s2_len;
  size_t __s1_len;
  int iport;
  char * p;
  static const char __func__[37] = "switch_core_media_ext_address_lookup";
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_ext_address_lookup";
  struct switch_memory_pool_t * pool;
  struct switch_media_handle_t * smh;
  char * stun_ip;
  switch_port_t stun_port;
  switch_port_t myport;
  int x;
  switch_status_t status;
  char * error;
  uint32_t D.44113;
  uint32_t D.44112;
  char * D.44111;
  char * D.44109;
  struct switch_core_media_params_t * D.44108;
  int D.39263;
  int D.44104;
  switch_port_t D.44103;
  char * error.80;
  int D.44099;
  int D.44093;
  unsigned int D.44090;
  unsigned int iport.79;
  int D.44084;
  char * D.44082;
  char * D.44081;
  const char * D.44080;
  int D.44077;
  switch_status_t D.44074;

<bb 2>:
  error = "";
  status = 1;
  myport = *port;
  stun_port = 3478;
  stun_ip = 0B;
  pool = switch_core_session_get_pool (session);
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4351, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.44074 = 1;
  goto <bb 32>;

<bb 6>:
  if (sourceip == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.44074 = status;
  goto <bb 32>;

<bb 8>:
  D.44077 = strncasecmp (sourceip, "host:", 5);
  if (D.44077 == 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.44080 = sourceip + 5;
  D.44081 = switch_stun_host_lookup (D.44080, pool);
  *ip = D.44081;
  D.44082 = *ip;
  status = D.44082 == 0B;
  goto <bb 29> (out);

<bb 10>:
  D.44084 = strncasecmp (sourceip, "stun:", 5);
  if (D.44084 == 0)
    goto <bb 11>;
  else
    goto <bb 28>;

<bb 11>:
  D.44080 = sourceip + 5;
  stun_ip = __strdup (D.44080);
  p = __builtin_strchr (stun_ip, 58);
  if (p != 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

<bb 12>:
  *p = 0;
  p = p + 1;
  iport = atoi (p);
  iport.79 = (unsigned int) iport;
  D.44090 = iport.79 + 4294967295;
  if (D.44090 <= 65533)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  stun_port = (switch_port_t) iport;

<bb 14>:
  D.44093 = _zstr (stun_ip);
  if (D.44093 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4378, 0B, 3, "STUN Failed! NO STUN SERVER\n");
  goto <bb 29> (out);

<bb 16>:
  x = 0;
  goto <bb 19>;

<bb 17>:
  status = switch_stun_lookup (ip, port, stun_ip, stun_port, &error, pool);
  if (status != 0)
    goto <bb 18>;
  else
    goto <bb 20>;

<bb 18>:
  switch_sleep (100000);
  x = x + 1;

<bb 19>:
  if (x <= 4)
    goto <bb 17>;
  else
    goto <bb 20>;

<bb 20>:
  if (status != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  D.44099 = (int) stun_port;
  error.80 = error;
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4390, 0B, 3, "STUN Failed! %s:%d [%s]\n", stun_ip, D.44099, error.80);
  goto <bb 29> (out);

<bb 22>:
  D.44082 = *ip;
  if (D.44082 == 0B)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4394, 0B, 3, "STUN Failed! No IP returned\n");
  goto <bb 29> (out);

<bb 24>:
  D.44082 = *ip;
  D.44103 = *port;
  D.44104 = (int) D.44103;
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4397, 0B, 7, "STUN Success [%s]:[%d]\n", D.44082, D.44104);
  status = 0;
  D.44103 = *port;
  if (D.44103 == myport)
    goto <bb 25>;
  else
    goto <bb 27>;

<bb 25>:
  D.44082 = *ip;
  D.44108 = smh->mparams;
  D.44109 = D.44108->rtpip;
  D.39263 = __builtin_strcmp (D.44082, D.44109);
  if (D.39263 == 0)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  D.44082 = *ip;
  D.44103 = *port;
  D.44104 = (int) D.44103;
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 4401, 0B, 7, "STUN Not Required ip and port match. [%s]:[%d]\n", D.44082, D.44104);
  goto <bb 29> (out);

<bb 27>:
  D.44108 = smh->mparams;
  D.44111 = switch_core_perform_session_strdup (session, stun_ip, "src/switch_core_media.c", &__func__, 4403);
  D.44108->stun_ip = D.44111;
  D.44108 = smh->mparams;
  D.44108->stun_port = stun_port;
  D.44108 = smh->mparams;
  D.44108 = smh->mparams;
  D.44112 = D.44108->stun_flags;
  D.44113 = D.44112 | 1;
  D.44108->stun_flags = D.44113;
  goto <bb 29> (out);

<bb 28>:
  *ip = sourceip;
  status = 0;

out:
  if (stun_ip != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  free (stun_ip);
  stun_ip = 0B;

<bb 31>:
  D.44074 = status;

<bb 32>:
  return D.44074;

}



;; Function switch_core_media_check_nat (switch_core_media_check_nat)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_check_nat"; (unused)

}
Merging blocks 9 and 10
switch_core_media_check_nat (struct switch_media_handle_t * smh, const char * network_ip)
{
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_check_nat";
  switch_bool_t D.44130;
  char * D.44129;
  switch_bool_t D.44127;
  char * D.44125;
  struct switch_core_media_params_t * D.44124;
  int iftmp.81;
  int D.44120;

<bb 2>:
  if (network_ip == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("network_ip", "src/switch_core_media.c", 4331, &__PRETTY_FUNCTION__);

<bb 4>:
  D.44124 = smh->mparams;
  D.44125 = D.44124->extsipip;
  if (D.44125 != 0B)
    goto <bb 5>;
  else
    goto <bb 8>;

<bb 5>:
  D.44127 = switch_check_network_list_ip_token (network_ip, "loopback.auto", 0B);
  if (D.44127 == 0)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 6>:
  D.44124 = smh->mparams;
  D.44129 = D.44124->local_network;
  D.44130 = switch_check_network_list_ip_token (network_ip, D.44129, 0B);
  if (D.44130 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  iftmp.81 = 1;
  goto <bb 9>;

<bb 8>:
  iftmp.81 = 0;

<bb 9>:
  D.44120 = iftmp.81;
  return D.44120;

}



;; Function switch_core_media_proxy_remote_addr (switch_core_media_proxy_remote_addr)

Scope blocks:

{ Scope block #0 
  const char * err; (unused)
  char rip[512]; (unused)
  char rp[512]; (unused)
  char rvp[512]; (unused)
  char * p; (unused)
  char * ip_ptr; (unused)
  char * port_ptr; (unused)
  char * vid_port_ptr; (unused)
  char * pe; (unused)
  int x; (unused)
  const char * val; (unused)
  switch_status_t status; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[36] = "switch_core_media_proxy_remote_addr"; (unused)
  void end = <<< error >>>; (unused)
  static const char __func__[36] = "switch_core_media_proxy_remote_addr"; (unused)

  { Scope block #0 
    char * tmp; (unused)

  }

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

  { Scope block #0 
    const char * rport; (unused)
    switch_port_t remote_rtcp_port; (unused)

  }

  { Scope block #0 
    char * remote_host; (unused)
    switch_port_t remote_port; (unused)
    const char * rport; (unused)
    switch_port_t remote_rtcp_port; (unused)

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

    }

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

      { Scope block #0 
        const unsigned char * __s1; (unused)
        register int __result; (unused)

      }

    }

    { Scope block #0 
      size_t __s1_len; (unused)
      size_t __s2_len; (unused)

      { Scope block #0 
        const unsigned char * __s1; (unused)
        register int __result; (unused)

      }

    }

  }

}
switch_core_media_proxy_remote_addr (struct switch_core_session_t * session, const char * sdp_str)
{
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  size_t __s2_len;
  size_t __s1_len;
  switch_port_t remote_rtcp_port;
  const char * rport;
  switch_port_t remote_port;
  char * remote_host;
  switch_port_t remote_rtcp_port;
  const char * rport;
  size_t __s2_len;
  size_t __s1_len;
  char * tmp;
  static const char __func__[36] = "switch_core_media_proxy_remote_addr";
  static const char __PRETTY_FUNCTION__[36] = "switch_core_media_proxy_remote_addr";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  switch_status_t status;
  const char * val;
  int x;
  char * pe;
  char * vid_port_ptr;
  char * port_ptr;
  char * ip_ptr;
  char * p;
  char rvp[512];
  char rp[512];
  char rip[512];
  const char * err;
  int32_t D.44351;
  uint32_t D.44348;
  int D.44347;
  int32_t D.44343;
  switch_status_t D.44337;
  int D.44336;
  int D.44332;
  const unsigned char D.44331;
  const unsigned char * D.44330;
  _Bool D.44327;
  _Bool D.44326;
  int D.44325;
  const unsigned char D.44324;
  const unsigned char * D.44323;
  _Bool D.44320;
  _Bool D.44319;
  int D.44318;
  const unsigned char D.44317;
  const unsigned char * D.44316;
  _Bool D.44313;
  _Bool D.44312;
  _Bool D.44311;
  int D.44310;
  const unsigned char D.44309;
  int D.39223;
  int iftmp.85;
  int D.39224;
  int D.44303;
  const unsigned char D.44302;
  char * D.44301;
  int D.44300;
  const unsigned char D.44299;
  const unsigned char * D.44298;
  _Bool D.44295;
  _Bool D.44294;
  int D.44293;
  const unsigned char D.44292;
  char * D.44291;
  int D.44290;
  const unsigned char D.44289;
  const unsigned char * D.44288;
  _Bool D.44285;
  _Bool D.44284;
  int D.44283;
  const unsigned char D.44282;
  char * D.44281;
  int D.44280;
  const unsigned char D.44279;
  const unsigned char * D.44278;
  _Bool D.44275;
  _Bool D.44274;
  _Bool D.44273;
  int D.44272;
  const unsigned char D.44271;
  char[8] * D.44270;
  int D.44269;
  const unsigned char D.44268;
  int D.39214;
  int iftmp.84;
  int D.39215;
  int D.44260;
  switch_port_t D.44258;
  char * D.44256;
  int D.39206;
  _Bool D.44254;
  _Bool D.44253;
  _Bool D.44252;
  uint8_t D.44248;
  struct switch_rtp_t * D.44247;
  int32_t D.44244;
  uint32_t D.44241;
  int D.44240;
  uint32_t D.44236;
  int32_t D.44233;
  const char * err.83;
  switch_status_t D.44226;
  int D.44225;
  uint8_t D.44218;
  struct switch_rtp_t * D.44217;
  int D.44215;
  int D.44214;
  int D.39191;
  switch_port_t D.44208;
  char * D.44205;
  struct switch_channel_t * D.44204;
  short unsigned int D.44203;
  int D.44202;
  char * D.44201;
  struct payload_map_t * D.44200;
  char D.44197;
  short unsigned int D.44196;
  int D.44195;
  char * D.44194;
  struct payload_map_t * D.44193;
  char D.44192;
  char D.44190;
  char D.44184;
  char D.44180;
  char D.44178;
  _Bool D.44175;
  _Bool D.44174;
  _Bool D.44173;
  char D.44172;
  char D.44171;
  _Bool D.44168;
  _Bool D.44167;
  _Bool D.44166;
  unsigned int x.82;
  char D.44163;
  size_t D.44162;
  _Bool D.44160;
  _Bool D.44159;
  _Bool D.44158;
  int D.44153;
  int D.44142;
  struct switch_core_media_params_t * D.44141;
  int D.44138;
  switch_status_t D.44137;

<bb 2>:
  rip = "";
  rp = "";
  rvp = "";
  ip_ptr = 0B;
  port_ptr = 0B;
  vid_port_ptr = 0B;
  status = 1;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 4152, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.44137 = 1;
  goto <bb 99>;

<bb 6>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.44138 = _zstr (sdp_str);
  if (D.44138 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.44141 = smh->mparams;
  sdp_str = D.44141->remote_sdp_str;

<bb 8>:
  D.44142 = _zstr (sdp_str);
  if (D.44142 != 0)
    goto <bb 98> (end);
  else
    goto <bb 9>;

<bb 9>:
  p = switch_stristr ("c=IN IP4 ", sdp_str);
  if (p != 0B)
    goto <bb 11>;
  else
    goto <bb 10>;

<bb 10>:
  p = switch_stristr ("c=IN IP6 ", sdp_str);
  if (p != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  ip_ptr = p + 9;

<bb 12>:
  p = switch_stristr ("m=audio ", sdp_str);
  if (p != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  port_ptr = p + 8;

<bb 14>:
  p = switch_stristr ("m=image ", sdp_str);
  if (p != 0B)
    goto <bb 15>;
  else
    goto <bb 18>;

<bb 15>:
  tmp = p + 8;
  if (tmp != 0B)
    goto <bb 16>;
  else
    goto <bb 18>;

<bb 16>:
  D.44153 = atoi (tmp);
  if (D.44153 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  port_ptr = tmp;

<bb 18>:
  p = switch_stristr ("m=video ", sdp_str);
  if (p != 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  vid_port_ptr = p + 8;

<bb 20>:
  D.44158 = ip_ptr == 0B;
  D.44159 = port_ptr == 0B;
  D.44160 = D.44158 || D.44159;
  if (D.44160 != 0)
    goto <bb 98> (end);
  else
    goto <bb 21>;

<bb 21>:
  p = ip_ptr;
  D.44162 = strlen (p);
  pe = p + D.44162;
  x = 0;
  goto <bb 23>;

<bb 22>:
  D.44163 = *p;
  rip[x] = D.44163;
  x = x + 1;
  p = p + 1;
  if (p >= pe)
    goto <bb 98> (end);
  else
    goto <bb 23>;

<bb 23>:
  x.82 = (unsigned int) x;
  D.44166 = x.82 <= 510;
  D.44167 = p != 0B;
  D.44168 = D.44166 && D.44167;
  if (D.44168 != 0)
    goto <bb 24>;
  else
    goto <bb 29>;

<bb 24>:
  D.44163 = *p;
  if (D.44163 != 0)
    goto <bb 25>;
  else
    goto <bb 29>;

<bb 25>:
  D.44171 = *p;
  D.44172 = D.44171 + 208;
  D.44173 = D.44172 <= 9;
  D.44174 = D.44171 == 46;
  D.44175 = D.44173 || D.44174;
  if (D.44175 != 0)
    goto <bb 22>;
  else
    goto <bb 26>;

<bb 26>:
  D.44163 = *p;
  if (D.44163 == 58)
    goto <bb 22>;
  else
    goto <bb 27>;

<bb 27>:
  D.44163 = *p;
  D.44178 = D.44163 + 159;
  if (D.44178 <= 5)
    goto <bb 22>;
  else
    goto <bb 28>;

<bb 28>:
  D.44163 = *p;
  D.44180 = D.44163 + 191;
  if (D.44180 <= 5)
    goto <bb 22>;
  else
    goto <bb 29>;

<bb 29>:
  p = port_ptr;
  x = 0;
  goto <bb 31>;

<bb 30>:
  D.44163 = *p;
  rp[x] = D.44163;
  x = x + 1;
  p = p + 1;
  if (p >= pe)
    goto <bb 98> (end);
  else
    goto <bb 31>;

<bb 31>:
  x.82 = (unsigned int) x;
  D.44166 = x.82 <= 510;
  D.44167 = p != 0B;
  D.44168 = D.44166 && D.44167;
  if (D.44168 != 0)
    goto <bb 32>;
  else
    goto <bb 34>;

<bb 32>:
  D.44163 = *p;
  if (D.44163 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.44163 = *p;
  D.44184 = D.44163 + 208;
  if (D.44184 <= 9)
    goto <bb 30>;
  else
    goto <bb 34>;

<bb 34>:
  p = vid_port_ptr;
  x = 0;
  goto <bb 36>;

<bb 35>:
  D.44163 = *p;
  rvp[x] = D.44163;
  x = x + 1;
  p = p + 1;
  if (p >= pe)
    goto <bb 98> (end);
  else
    goto <bb 36>;

<bb 36>:
  x.82 = (unsigned int) x;
  D.44166 = x.82 <= 510;
  D.44167 = p != 0B;
  D.44168 = D.44166 && D.44167;
  if (D.44168 != 0)
    goto <bb 37>;
  else
    goto <bb 39>;

<bb 37>:
  D.44163 = *p;
  if (D.44163 != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  D.44163 = *p;
  D.44184 = D.44163 + 208;
  if (D.44184 <= 9)
    goto <bb 35>;
  else
    goto <bb 39>;

<bb 39>:
  D.44190 = rip[0];
  if (D.44190 == 0)
    goto <bb 41>;
  else
    goto <bb 40>;

<bb 40>:
  D.44192 = rp[0];
  if (D.44192 == 0)
    goto <bb 41>;
  else
    goto <bb 42>;

<bb 41>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4225, session, 3, "invalid SDP\n");
  goto <bb 98> (end);

<bb 42>:
  D.44193 = a_engine->cur_payload_map;
  D.44194 = switch_core_perform_session_strdup (session, &rip, "src/switch_core_media.c", &__func__, 4229);
  D.44193->remote_sdp_ip = D.44194;
  D.44193 = a_engine->cur_payload_map;
  D.44195 = atoi (&rp);
  D.44196 = (short unsigned int) D.44195;
  D.44193->remote_sdp_port = D.44196;
  D.44197 = rvp[0];
  if (D.44197 != 0)
    goto <bb 43>;
  else
    goto <bb 44>;

<bb 43>:
  D.44200 = v_engine->cur_payload_map;
  D.44201 = switch_core_perform_session_strdup (session, &rip, "src/switch_core_media.c", &__func__, 4233);
  D.44200->remote_sdp_ip = D.44201;
  D.44200 = v_engine->cur_payload_map;
  D.44202 = atoi (&rvp);
  D.44203 = (short unsigned int) D.44202;
  D.44200->remote_sdp_port = D.44203;
  D.44204 = session->channel;
  switch_channel_set_flag_value (D.44204, 98, 1);
  D.44204 = session->channel;
  switch_channel_set_flag_value (D.44204, 23, 1);

<bb 44>:
  D.44200 = v_engine->cur_payload_map;
  D.44205 = D.44200->remote_sdp_ip;
  if (D.44205 != 0B)
    goto <bb 45>;
  else
    goto <bb 63>;

<bb 45>:
  D.44200 = v_engine->cur_payload_map;
  D.44208 = D.44200->remote_sdp_port;
  if (D.44208 != 0)
    goto <bb 46>;
  else
    goto <bb 63>;

<bb 46>:
  D.44200 = v_engine->cur_payload_map;
  D.44205 = D.44200->remote_sdp_ip;
  D.39191 = __builtin_strcmp (D.44205, &rip);
  if (D.39191 == 0)
    goto <bb 47>;
  else
    goto <bb 49>;

<bb 47>:
  D.44214 = atoi (&rvp);
  D.44200 = v_engine->cur_payload_map;
  D.44208 = D.44200->remote_sdp_port;
  D.44215 = (int) D.44208;
  if (D.44214 == D.44215)
    goto <bb 48>;
  else
    goto <bb 49>;

<bb 48>:
  D.44200 = v_engine->cur_payload_map;
  D.44205 = D.44200->remote_sdp_ip;
  D.44200 = v_engine->cur_payload_map;
  D.44208 = D.44200->remote_sdp_port;
  D.44215 = (int) D.44208;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4241, session, 7, "Remote video address:port [%s:%d] has not changed.\n", D.44205, D.44215);
  goto <bb 63>;

<bb 49>:
  D.44204 = session->channel;
  switch_channel_set_flag_value (D.44204, 98, 1);
  D.44204 = session->channel;
  switch_channel_set_flag_value (D.44204, 23, 1);
  D.44217 = v_engine->rtp_session;
  D.44218 = switch_rtp_ready (D.44217);
  if (D.44218 != 0)
    goto <bb 50>;
  else
    goto <bb 63>;

<bb 50>:
  rport = 0B;
  remote_rtcp_port = v_engine->remote_rtcp_port;
  if (remote_rtcp_port == 0)
    goto <bb 51>;
  else
    goto <bb 53>;

<bb 51>:
  D.44204 = session->channel;
  rport = switch_channel_get_variable_dup (D.44204, "rtp_remote_video_rtcp_port", 1, -1);
  if (rport != 0B)
    goto <bb 52>;
  else
    goto <bb 53>;

<bb 52>:
  D.44225 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.44225;

<bb 53>:
  D.44217 = v_engine->rtp_session;
  D.44200 = v_engine->cur_payload_map;
  D.44205 = D.44200->remote_sdp_ip;
  D.44200 = v_engine->cur_payload_map;
  D.44208 = D.44200->remote_sdp_port;
  D.44226 = switch_rtp_set_remote_address (D.44217, D.44205, D.44208, remote_rtcp_port, 1, &err);
  if (D.44226 != 0)
    goto <bb 54>;
  else
    goto <bb 55>;

<bb 54>:
  err.83 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4259, session, 3, "VIDEO RTP REPORTS ERROR: [%s]\n", err.83);
  goto <bb 63>;

<bb 55>:
  D.44200 = v_engine->cur_payload_map;
  D.44205 = D.44200->remote_sdp_ip;
  D.44200 = v_engine->cur_payload_map;
  D.44208 = D.44200->remote_sdp_port;
  D.44215 = (int) D.44208;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4261, session, 7, "VIDEO RTP CHANGING DEST TO: [%s:%d]\n", D.44205, D.44215);
  D.44233 = switch_media_handle_test_media_flag (smh, 10);
  if (D.44233 == 0)
    goto <bb 56>;
  else
    goto <bb 61>;

<bb 56>:
  D.44204 = session->channel;
  D.44236 = switch_channel_test_flag (D.44204, 15);
  if (D.44236 == 0)
    goto <bb 57>;
  else
    goto <bb 61>;

<bb 57>:
  D.44204 = session->channel;
  val = switch_channel_get_variable_dup (D.44204, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 59>;
  else
    goto <bb 58>;

<bb 58>:
  D.44240 = switch_true (val);
  if (D.44240 == 0)
    goto <bb 59>;
  else
    goto <bb 61>;

<bb 59>:
  D.44204 = session->channel;
  D.44241 = switch_channel_test_flag (D.44204, 106);
  if (D.44241 == 0)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  D.44217 = v_engine->rtp_session;
  switch_rtp_set_flag (D.44217, 7);
  start_video_thread (session);

<bb 61>:
  D.44244 = switch_media_handle_test_media_flag (smh, 2);
  if (D.44244 != 0)
    goto <bb 62>;
  else
    goto <bb 63>;

<bb 62>:
  v_engine->check_frames = 0;

<bb 63>:
  D.44247 = a_engine->rtp_session;
  D.44248 = switch_rtp_ready (D.44247);
  if (D.44248 != 0)
    goto <bb 64>;
  else
    goto <bb 98> (end);

<bb 64>:
  D.44247 = a_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.44247);
  D.44247 = a_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.44247);
  rport = 0B;
  remote_rtcp_port = 0;
  D.44252 = remote_host != 0B;
  D.44253 = remote_port != 0;
  D.44254 = D.44252 && D.44253;
  if (D.44254 != 0)
    goto <bb 65>;
  else
    goto <bb 68>;

<bb 65>:
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  D.39206 = __builtin_strcmp (remote_host, D.44256);
  if (D.39206 == 0)
    goto <bb 66>;
  else
    goto <bb 68>;

<bb 66>:
  D.44193 = a_engine->cur_payload_map;
  D.44258 = D.44193->remote_sdp_port;
  if (D.44258 == remote_port)
    goto <bb 67>;
  else
    goto <bb 68>;

<bb 67>:
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  D.44193 = a_engine->cur_payload_map;
  D.44258 = D.44193->remote_sdp_port;
  D.44260 = (int) D.44258;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4286, session, 7, "Remote address:port [%s:%d] has not changed.\n", D.44256, D.44260);
  status = 11;
  goto <bb 98> (end);

<bb 68>:
  if (remote_host != 0B)
    goto <bb 69>;
  else
    goto <bb 86>;

<bb 69>:
  __s2_len = 7;
  if (__s2_len <= 3)
    goto <bb 70>;
  else
    goto <bb 75>;

<bb 70>:
  __s1 = remote_host;
  D.44268 = *__s1;
  D.44269 = (int) D.44268;
  D.44270 = "0.0.0.0";
  D.44271 = MEM[(const unsigned char *)D.44270];
  D.44272 = (int) D.44271;
  __result = D.44269 - D.44272;
  D.44273 = __s2_len != 0;
  D.44274 = __result == 0;
  D.44275 = D.44273 && D.44274;
  if (D.44275 != 0)
    goto <bb 71>;
  else
    goto <bb 74>;

<bb 71>:
  D.44278 = __s1 + 1;
  D.44279 = *D.44278;
  D.44280 = (int) D.44279;
  D.44281 = &"0.0.0.0"[1];
  D.44282 = MEM[(const unsigned char *)D.44281];
  D.44283 = (int) D.44282;
  __result = D.44280 - D.44283;
  D.44284 = __s2_len > 1;
  D.44274 = __result == 0;
  D.44285 = D.44284 && D.44274;
  if (D.44285 != 0)
    goto <bb 72>;
  else
    goto <bb 74>;

<bb 72>:
  D.44288 = __s1 + 2;
  D.44289 = *D.44288;
  D.44290 = (int) D.44289;
  D.44291 = &"0.0.0.0"[2];
  D.44292 = MEM[(const unsigned char *)D.44291];
  D.44293 = (int) D.44292;
  __result = D.44290 - D.44293;
  D.44294 = __s2_len > 2;
  D.44274 = __result == 0;
  D.44295 = D.44294 && D.44274;
  if (D.44295 != 0)
    goto <bb 73>;
  else
    goto <bb 74>;

<bb 73>:
  D.44298 = __s1 + 3;
  D.44299 = *D.44298;
  D.44300 = (int) D.44299;
  D.44301 = &"0.0.0.0"[3];
  D.44302 = MEM[(const unsigned char *)D.44301];
  D.44303 = (int) D.44302;
  __result = D.44300 - D.44303;

<bb 74>:
  D.39214 = __result;
  iftmp.84 = D.39214;
  goto <bb 76>;

<bb 75>:
  iftmp.84 = __builtin_strcmp (remote_host, "0.0.0.0");

<bb 76>:
  D.39215 = iftmp.84;
  if (D.39215 == 0)
    goto <bb 85>;
  else
    goto <bb 77>;

<bb 77>:
  __s2_len = 7;
  if (__s2_len <= 3)
    goto <bb 78>;
  else
    goto <bb 83>;

<bb 78>:
  D.44193 = a_engine->cur_payload_map;
  __s1 = D.44193->remote_sdp_ip;
  D.44309 = *__s1;
  D.44310 = (int) D.44309;
  D.44270 = "0.0.0.0";
  D.44271 = MEM[(const unsigned char *)D.44270];
  D.44272 = (int) D.44271;
  __result = D.44310 - D.44272;
  D.44311 = __s2_len != 0;
  D.44312 = __result == 0;
  D.44313 = D.44311 && D.44312;
  if (D.44313 != 0)
    goto <bb 79>;
  else
    goto <bb 82>;

<bb 79>:
  D.44316 = __s1 + 1;
  D.44317 = *D.44316;
  D.44318 = (int) D.44317;
  D.44281 = &"0.0.0.0"[1];
  D.44282 = MEM[(const unsigned char *)D.44281];
  D.44283 = (int) D.44282;
  __result = D.44318 - D.44283;
  D.44319 = __s2_len > 1;
  D.44312 = __result == 0;
  D.44320 = D.44319 && D.44312;
  if (D.44320 != 0)
    goto <bb 80>;
  else
    goto <bb 82>;

<bb 80>:
  D.44323 = __s1 + 2;
  D.44324 = *D.44323;
  D.44325 = (int) D.44324;
  D.44291 = &"0.0.0.0"[2];
  D.44292 = MEM[(const unsigned char *)D.44291];
  D.44293 = (int) D.44292;
  __result = D.44325 - D.44293;
  D.44326 = __s2_len > 2;
  D.44312 = __result == 0;
  D.44327 = D.44326 && D.44312;
  if (D.44327 != 0)
    goto <bb 81>;
  else
    goto <bb 82>;

<bb 81>:
  D.44330 = __s1 + 3;
  D.44331 = *D.44330;
  D.44332 = (int) D.44331;
  D.44301 = &"0.0.0.0"[3];
  D.44302 = MEM[(const unsigned char *)D.44301];
  D.44303 = (int) D.44302;
  __result = D.44332 - D.44303;

<bb 82>:
  D.39223 = __result;
  iftmp.85 = D.39223;
  goto <bb 84>;

<bb 83>:
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  iftmp.85 = __builtin_strcmp (D.44256, "0.0.0.0");

<bb 84>:
  D.39224 = iftmp.85;
  if (D.39224 == 0)
    goto <bb 85>;
  else
    goto <bb 86>;

<bb 85>:
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4292, session, 7, "Remote address changed from [%s] to [%s]. Ignoring...\n", D.44256, remote_host);
  status = 11;
  goto <bb 98> (end);

<bb 86>:
  D.44204 = session->channel;
  rport = switch_channel_get_variable_dup (D.44204, "rtp_remote_audio_rtcp_port", 1, -1);
  if (rport != 0B)
    goto <bb 87>;
  else
    goto <bb 88>;

<bb 87>:
  D.44336 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.44336;

<bb 88>:
  D.44247 = a_engine->rtp_session;
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  D.44193 = a_engine->cur_payload_map;
  D.44258 = D.44193->remote_sdp_port;
  D.44337 = switch_rtp_set_remote_address (D.44247, D.44256, D.44258, remote_rtcp_port, 1, &err);
  if (D.44337 != 0)
    goto <bb 89>;
  else
    goto <bb 90>;

<bb 89>:
  err.83 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4305, session, 3, "AUDIO RTP REPORTS ERROR: [%s]\n", err.83);
  status = 9;
  goto <bb 98> (end);

<bb 90>:
  D.44193 = a_engine->cur_payload_map;
  D.44256 = D.44193->remote_sdp_ip;
  D.44193 = a_engine->cur_payload_map;
  D.44258 = D.44193->remote_sdp_port;
  D.44260 = (int) D.44258;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 4308, session, 7, "AUDIO RTP CHANGING DEST TO: [%s:%d]\n", D.44256, D.44260);
  D.44343 = switch_media_handle_test_media_flag (smh, 10);
  if (D.44343 == 0)
    goto <bb 91>;
  else
    goto <bb 95>;

<bb 91>:
  D.44204 = session->channel;
  val = switch_channel_get_variable_dup (D.44204, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 93>;
  else
    goto <bb 92>;

<bb 92>:
  D.44347 = switch_true (val);
  if (D.44347 == 0)
    goto <bb 93>;
  else
    goto <bb 95>;

<bb 93>:
  D.44204 = session->channel;
  D.44348 = switch_channel_test_flag (D.44204, 106);
  if (D.44348 == 0)
    goto <bb 94>;
  else
    goto <bb 95>;

<bb 94>:
  D.44247 = a_engine->rtp_session;
  switch_rtp_set_flag (D.44247, 7);

<bb 95>:
  D.44351 = switch_media_handle_test_media_flag (smh, 2);
  if (D.44351 != 0)
    goto <bb 96>;
  else
    goto <bb 97>;

<bb 96>:
  a_engine->check_frames = 0;

<bb 97>:
  status = 0;

end:
  D.44137 = status;

<bb 99>:
  return D.44137;

}



;; Function switch_core_media_toggle_hold (switch_core_media_toggle_hold)

Scope blocks:

{ Scope block #0 
  int changed; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_core_session_t * b_session; (unused)
  struct switch_channel_t * b_channel; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_toggle_hold"; (unused)
  static const char __func__[30] = "switch_core_media_toggle_hold"; (unused)
  void end = <<< error >>>; (unused)

  { Scope block #0 
    const char * stream; (unused)
    const char * msg; (unused)
    const char * info; (unused)

  }

  { Scope block #0 
    const char * val; (unused)

  }

}
Removing basic block 56
;; basic block 56, loop depth 0, count 0
;; prev block 55, next block 57
;; pred:      
;; succ:       53 (fallthru)
<bb 56>:
goto <bb 53>;


Removing basic block 35
;; basic block 35, loop depth 0, count 0
;; prev block 34, next block 36
;; pred:      
;; succ:       69 (fallthru)
<bb 35>:
goto <bb 69> (end);


Removing basic block 55
;; basic block 55, loop depth 0, count 0
;; prev block 54, next block 57
;; pred:      
;; succ:       57 (fallthru)
<bb 55>:


switch_core_media_toggle_hold (struct switch_core_session_t * session, int sendonly)
{
  const char * val;
  const char * info;
  const char * msg;
  const char * stream;
  static const char __func__[30] = "switch_core_media_toggle_hold";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_toggle_hold";
  struct switch_channel_t * b_channel;
  struct switch_core_session_t * b_session;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  int changed;
  uint32_t D.44454;
  int D.44453;
  int32_t D.44449;
  uint32_t D.44444;
  uint32_t D.44440;
  uint32_t D.44433;
  char * D.44432;
  uint32_t D.44431;
  uint32_t D.44429;
  uint32_t D.44422;
  uint32_t D.44415;
  char * D.44414;
  char * D.44412;
  int D.44409;
  uint32_t D.44408;
  int D.44404;
  uint32_t D.44393;
  struct switch_rtp_t * D.44390;
  struct switch_rtp_t * D.44387;
  const char * D.44384;
  switch_bool_t sendonly.87;
  uint32_t D.44380;
  uint32_t D.44378;
  uint32_t D.44376;
  uint32_t D.44370;
  uint32_t D.44368;
  struct switch_channel_t * D.44367;
  struct switch_core_session_t * b_session.86;
  switch_status_t D.44360;
  int D.44359;

<bb 2>:
  changed = 0;
  b_session = 0B;
  b_channel = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 3872, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.44359 = 0;
  goto <bb 69>;

<bb 6>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.44360 = switch_core_session_perform_get_partner (session, &b_session, "src/switch_core_media.c", &__func__, 3882);
  if (D.44360 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  b_session.86 = b_session;
  b_channel = switch_core_session_get_channel (b_session.86);

<bb 8>:
  if (sendonly != 0)
    goto <bb 9>;
  else
    goto <bb 35>;

<bb 9>:
  D.44367 = session->channel;
  D.44368 = switch_channel_test_flag (D.44367, 1);
  if (D.44368 != 0)
    goto <bb 10>;
  else
    goto <bb 35>;

<bb 10>:
  D.44367 = session->channel;
  D.44370 = switch_channel_test_flag (D.44367, 96);
  if (D.44370 == 0)
    goto <bb 11>;
  else
    goto <bb 66> (end);

<bb 11>:
  msg = "hold";
  D.44367 = session->channel;
  D.44376 = switch_channel_test_flag (D.44367, 94);
  if (D.44376 != 0)
    goto <bb 13>;
  else
    goto <bb 12>;

<bb 12>:
  D.44367 = session->channel;
  D.44378 = switch_channel_test_flag (D.44367, 95);
  if (D.44378 != 0)
    goto <bb 13>;
  else
    goto <bb 16>;

<bb 13>:
  if (b_channel == 0B)
    goto <bb 15>;
  else
    goto <bb 14>;

<bb 14>:
  D.44380 = switch_channel_test_flag (b_channel, 25);
  if (D.44380 != 0)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.44367 = session->channel;
  sendonly.87 = (switch_bool_t) sendonly;
  switch_channel_mark_hold (D.44367, sendonly.87);
  D.44367 = session->channel;
  switch_channel_set_flag_value (D.44367, 96, 1);
  changed = 0;
  goto <bb 66> (end);

<bb 16>:
  D.44367 = session->channel;
  info = switch_channel_get_variable_dup (D.44367, "presence_call_info", 1, -1);
  if (info != 0B)
    goto <bb 17>;
  else
    goto <bb 19>;

<bb 17>:
  D.44384 = switch_stristr ("private", info);
  if (D.44384 != 0B)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  msg = "hold-private";

<bb 19>:
  D.44387 = a_engine->rtp_session;
  if (D.44387 != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.44387 = a_engine->rtp_session;
  switch_rtp_set_flag (D.44387, 35);

<bb 21>:
  D.44390 = v_engine->rtp_session;
  if (D.44390 != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.44390 = v_engine->rtp_session;
  switch_rtp_set_flag (D.44390, 35);

<bb 23>:
  D.44367 = session->channel;
  switch_channel_set_flag_value (D.44367, 96, 1);
  D.44367 = session->channel;
  switch_channel_mark_hold (D.44367, 1);
  D.44367 = session->channel;
  switch_channel_perform_presence (D.44367, "unknown", msg, 0B, "src/switch_core_media.c", &__func__, 3918);
  changed = 1;
  D.44393 = a_engine->max_missed_hold_packets;
  if (D.44393 != 0)
    goto <bb 24>;
  else
    goto <bb 26>;

<bb 24>:
  D.44387 = a_engine->rtp_session;
  if (D.44387 != 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  D.44387 = a_engine->rtp_session;
  D.44393 = a_engine->max_missed_hold_packets;
  switch_rtp_set_max_missed_packets (D.44387, D.44393);

<bb 26>:
  D.44367 = session->channel;
  stream = switch_channel_get_hold_music (D.44367);
  if (stream == 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  stream = "local_stream://moh";

<bb 28>:
  if (stream != 0B)
    goto <bb 29>;
  else
    goto <bb 66> (end);

<bb 29>:
  D.44404 = strcasecmp (stream, "silence");
  if (D.44404 != 0)
    goto <bb 30>;
  else
    goto <bb 66> (end);

<bb 30>:
  if (b_channel == 0B)
    goto <bb 32>;
  else
    goto <bb 31>;

<bb 31>:
  D.44408 = switch_channel_test_flag (b_channel, 25);
  if (D.44408 == 0)
    goto <bb 32>;
  else
    goto <bb 66> (end);

<bb 32>:
  D.44409 = strcasecmp (stream, "indicate_hold");
  if (D.44409 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.44367 = session->channel;
  switch_channel_set_flag_value (D.44367, 16, 1);
  D.44367 = session->channel;
  switch_channel_set_flag_value (D.44367, 10, 1);
  b_session.86 = b_session;
  D.44412 = switch_core_session_get_uuid (b_session.86);
  switch_ivr_hold_uuid (D.44412, 0B, 0);
  goto <bb 66> (end);

<bb 34>:
  b_session.86 = b_session;
  D.44414 = switch_core_session_get_uuid (b_session.86);
  switch_ivr_broadcast (D.44414, stream, 274);
  switch_sleep (250000);
  goto <bb 66> (end);

<bb 35>:
  D.44367 = session->channel;
  D.44415 = switch_channel_test_flag (D.44367, 97);
  if (D.44415 != 0)
    goto <bb 36>;
  else
    goto <bb 41>;

<bb 36>:
  D.44367 = session->channel;
  switch_channel_set_flag_value (D.44367, 96, 1);
  D.44367 = session->channel;
  switch_channel_mark_hold (D.44367, 1);
  D.44387 = a_engine->rtp_session;
  if (D.44387 != 0B)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  D.44387 = a_engine->rtp_session;
  switch_rtp_set_flag (D.44387, 35);

<bb 38>:
  D.44390 = v_engine->rtp_session;
  if (D.44390 != 0B)
    goto <bb 39>;
  else
    goto <bb 40>;

<bb 39>:
  D.44390 = v_engine->rtp_session;
  switch_rtp_set_flag (D.44390, 35);

<bb 40>:
  changed = 1;

<bb 41>:
  D.44367 = session->channel;
  switch_channel_clear_flag (D.44367, 97);
  D.44367 = session->channel;
  D.44422 = switch_channel_test_flag (D.44367, 96);
  if (D.44422 != 0)
    goto <bb 42>;
  else
    goto <bb 66> (end);

<bb 42>:
  switch_sleep (250000);
  if (b_channel != 0B)
    goto <bb 43>;
  else
    goto <bb 46>;

<bb 43>:
  D.44367 = session->channel;
  D.44429 = switch_channel_test_flag (D.44367, 120);
  if (D.44429 != 0)
    goto <bb 45>;
  else
    goto <bb 44>;

<bb 44>:
  D.44431 = switch_channel_test_flag (b_channel, 120);
  if (D.44431 != 0)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  D.44432 = switch_core_session_get_uuid (session);
  switch_ivr_nomedia (D.44432, 1);

<bb 46>:
  D.44433 = a_engine->max_missed_packets;
  if (D.44433 != 0)
    goto <bb 47>;
  else
    goto <bb 49>;

<bb 47>:
  D.44387 = a_engine->rtp_session;
  if (D.44387 != 0B)
    goto <bb 48>;
  else
    goto <bb 49>;

<bb 48>:
  D.44387 = a_engine->rtp_session;
  switch_rtp_reset_media_timer (D.44387);
  D.44387 = a_engine->rtp_session;
  D.44433 = a_engine->max_missed_packets;
  switch_rtp_set_max_missed_packets (D.44387, D.44433);

<bb 49>:
  if (b_channel != 0B)
    goto <bb 50>;
  else
    goto <bb 55>;

<bb 50>:
  D.44367 = session->channel;
  D.44440 = switch_channel_test_flag (D.44367, 10);
  if (D.44440 != 0)
    goto <bb 51>;
  else
    goto <bb 52>;

<bb 51>:
  b_session.86 = b_session;
  switch_ivr_unhold (b_session.86);
  D.44367 = session->channel;
  switch_channel_clear_flag (D.44367, 16);
  D.44367 = session->channel;
  switch_channel_clear_flag (D.44367, 10);
  goto <bb 55>;

<bb 52>:
  D.44444 = switch_channel_test_flag (b_channel, 21);
  if (D.44444 != 0)
    goto <bb 53>;
  else
    goto <bb 54>;

<bb 53>:
  switch_channel_set_flag_value (b_channel, 28, 1);
  switch_channel_set_flag_value (b_channel, 20, 1);

<bb 54>:
  switch_channel_wait_for_flag (b_channel, 21, 0, 5000, 0B);

<bb 55>:
  D.44449 = switch_media_handle_test_media_flag (smh, 10);
  if (D.44449 == 0)
    goto <bb 56>;
  else
    goto <bb 63>;

<bb 56>:
  D.44367 = session->channel;
  val = switch_channel_get_variable_dup (D.44367, "disable_rtp_auto_adjust", 1, -1);
  if (val == 0B)
    goto <bb 58>;
  else
    goto <bb 57>;

<bb 57>:
  D.44453 = switch_true (val);
  if (D.44453 == 0)
    goto <bb 58>;
  else
    goto <bb 63>;

<bb 58>:
  D.44367 = session->channel;
  D.44454 = switch_channel_test_flag (D.44367, 106);
  if (D.44454 == 0)
    goto <bb 59>;
  else
    goto <bb 63>;

<bb 59>:
  D.44387 = a_engine->rtp_session;
  if (D.44387 != 0B)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  D.44387 = a_engine->rtp_session;
  switch_rtp_set_flag (D.44387, 7);

<bb 61>:
  D.44390 = v_engine->rtp_session;
  if (D.44390 != 0B)
    goto <bb 62>;
  else
    goto <bb 63>;

<bb 62>:
  D.44390 = v_engine->rtp_session;
  switch_rtp_set_flag (D.44390, 7);

<bb 63>:
  D.44367 = session->channel;
  switch_channel_clear_flag (D.44367, 96);
  D.44367 = session->channel;
  switch_channel_mark_hold (D.44367, 0);
  D.44367 = session->channel;
  switch_channel_perform_presence (D.44367, "unknown", "unhold", 0B, "src/switch_core_media.c", &__func__, 4004);
  D.44387 = a_engine->rtp_session;
  switch_rtp_clear_flag (D.44387, 35);
  D.44390 = v_engine->rtp_session;
  if (D.44390 != 0B)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  D.44390 = v_engine->rtp_session;
  switch_rtp_clear_flag (D.44390, 35);

<bb 65>:
  changed = 1;

end:
  b_session.86 = b_session;
  if (b_session.86 != 0B)
    goto <bb 67>;
  else
    goto <bb 68>;

<bb 67>:
  b_session.86 = b_session;
  switch_core_session_rwunlock (b_session.86);

<bb 68>:
  D.44359 = changed;

<bb 69>:
  return D.44359;

}



;; Function switch_core_media_negotiate_sdp (switch_core_media_negotiate_sdp)

Scope blocks:

{ Scope block #0 
  uint8_t match; (unused)
  switch_payload_t best_te; (unused)
  switch_payload_t te; (unused)
  switch_payload_t cng_pt; (unused)
  struct sdp_media_t * m; (unused)
  struct sdp_attribute_t * attr; (unused)
  int ptime; (unused)
  int dptime; (unused)
  int maxptime; (unused)
  int dmaxptime; (unused)
  int sendonly; (unused)
  int recvonly; (unused)
  int greedy; (unused)
  int x; (unused)
  int skip; (unused)
  struct switch_channel_t * channel; (unused)
  const char * val; (unused)
  const char * crypto; (unused)
  int got_crypto; (unused)
  int got_video_crypto; (unused)
  int got_audio; (unused)
  int got_avp; (unused)
  int got_video_avp; (unused)
  int got_video_savp; (unused)
  int got_savp; (unused)
  int got_udptl; (unused)
  int got_webrtc; (unused)
  int scrooge; (unused)
  struct sdp_parser_t * parser; (unused)
  struct sdp_session_t * sdp; (unused)
  int reneg; (unused)
  const struct switch_codec_implementation_t * * codec_array; (unused)
  int total_codecs; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  uint32_t near_rate; (unused)
  const struct switch_codec_implementation_t * mimp; (unused)
  const struct switch_codec_implementation_t * near_match; (unused)
  struct sdp_rtpmap_t * mmap; (unused)
  struct sdp_rtpmap_t * near_map; (unused)
  struct matches matches[30]; (unused)
  struct matches near_matches[30]; (unused)
  int codec_ms; (unused)
  uint32_t remote_codec_rate; (unused)
  uint32_t fmtp_remote_codec_rate; (unused)
  const char * tmp; (unused)
  int m_idx; (unused)
  int nm_idx; (unused)
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_negotiate_sdp"; (unused)
  static const char __func__[32] = "switch_core_media_negotiate_sdp"; (unused)
  void done = <<< error >>>; (unused)

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

    { Scope block #0 
      const unsigned char * __s1; (unused)
      register int __result; (unused)

    }

  }

  { Scope block #0 
    struct sdp_connection_t * connection; (unused)
    struct switch_core_session_t * other_session; (unused)

    { Scope block #0 
      struct switch_t38_options_t * t38_options; (unused)

      { Scope block #0 
        const char * var; (unused)
        int pass; (unused)

        { Scope block #0 
          struct switch_channel_t * other_channel; (unused)
          struct switch_core_session_message_t * msg; (unused)
          char * remote_host; (unused)
          switch_port_t remote_port; (unused)
          char tmp[32]; (unused)

          { Scope block #0 
            size_t __s1_len; (unused)
            size_t __s2_len; (unused)

          }

          { Scope block #0 
            const char * err; (unused)

          }

        }

      }

    }

    { Scope block #0 
      struct sdp_rtpmap_t * map; (unused)

      { Scope block #0 
        int crypto_tag; (unused)

      }

      { Scope block #0 
        int32_t i; (unused)
        const char * rm_encoding; (unused)
        uint32_t map_bit_rate; (unused)
        struct switch_codec_fmtp_t codec_fmtp; (unused)

        { Scope block #0 
          const struct switch_codec_implementation_t * imp; (unused)
          uint32_t bit_rate; (unused)
          uint32_t codec_rate; (unused)

        }

      }

      { Scope block #0 
        int j; (unused)

        { Scope block #0 
          const struct switch_codec_implementation_t * search[1]; (unused)
          char * prefs[1]; (unused)
          char tmp[80]; (unused)
          int num; (unused)
          const struct switch_codec_implementation_t * timp; (unused)

        }

      }

      { Scope block #0 
        int j; (unused)

        { Scope block #0 
          struct payload_map_t * pmap; (unused)

        }

      }

      { Scope block #0 
        char tmp[50]; (unused)

      }

    }

    { Scope block #0 
      struct sdp_rtpmap_t * map; (unused)
      const char * rm_encoding; (unused)
      const struct switch_codec_implementation_t * mimp; (unused)
      int vmatch; (unused)
      int i; (unused)

      { Scope block #0 
        size_t __s1_len; (unused)
        size_t __s2_len; (unused)

        { Scope block #0 
          const unsigned char * __s1; (unused)
          register int __result; (unused)

        }

      }

      { Scope block #0 
        int crypto_tag; (unused)

      }

      { Scope block #0 
        const struct switch_codec_implementation_t * imp; (unused)

      }

      { Scope block #0 
        char tmp[50]; (unused)
        int j; (unused)

        { Scope block #0 
          struct payload_map_t * pmap; (unused)

        }

      }

    }

  }

}
Removing basic block 58
;; basic block 58, loop depth 0, count 0
;; prev block 57, next block 59
;; pred:      
;; succ:       66 (fallthru)
<bb 58>:
goto <bb 66>;


Removing basic block 101
;; basic block 101, loop depth 0, count 0
;; prev block 100, next block 102
;; pred:      
;; succ:       109 (fallthru)
<bb 101>:
goto <bb 109>;


Removing basic block 106
;; basic block 106, loop depth 0, count 0
;; prev block 105, next block 107
;; pred:      
;; succ:       109 (fallthru)
<bb 106>:
goto <bb 109>;


Removing basic block 160
;; basic block 160, loop depth 0, count 0
;; prev block 159, next block 161
;; pred:      
;; succ:       175 (fallthru)
<bb 160>:
goto <bb 175>;


Removing basic block 216
;; basic block 216, loop depth 0, count 0
;; prev block 215, next block 217
;; pred:      
;; succ:       224 (fallthru)
<bb 216>:
goto <bb 224>;


Removing basic block 297
;; basic block 297, loop depth 0, count 0
;; prev block 296, next block 298
;; pred:      
;; succ:       299 (fallthru)
<bb 297>:
goto <bb 299>;


Removing basic block 315
;; basic block 315, loop depth 0, count 0
;; prev block 314, next block 316
;; pred:      
;; succ:       318 (fallthru)
<bb 315>:
goto <bb 318>;


Removing basic block 318
;; basic block 318, loop depth 0, count 0
;; prev block 317, next block 319
;; pred:      
;; succ:       322 (fallthru)
<bb 318>:
goto <bb 322>;


Removing basic block 322
;; basic block 322, loop depth 0, count 0
;; prev block 321, next block 323
;; pred:      
;; succ:       409 (fallthru)
<bb 322>:
goto <bb 409>;


Removing basic block 341
;; basic block 341, loop depth 0, count 0
;; prev block 340, next block 342
;; pred:      
;; succ:       369 (fallthru)
<bb 341>:
goto <bb 369>;


Removing basic block 347
;; basic block 347, loop depth 0, count 0
;; prev block 346, next block 348
;; pred:      
;; succ:       369 (fallthru)
<bb 347>:
goto <bb 369>;


Removing basic block 360
;; basic block 360, loop depth 0, count 0
;; prev block 359, next block 361
;; pred:      
;; succ:       369 (fallthru)
<bb 360>:
goto <bb 369>;


switch_core_media_negotiate_sdp (struct switch_core_session_t * session, const char * r_sdp, uint8_t * proceed, switch_sdp_type_t sdp_type)
{
  struct payload_map_t * pmap;
  int j;
  char tmp[50];
  const struct switch_codec_implementation_t * imp;
  int crypto_tag;
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  int i;
  int vmatch;
  const struct switch_codec_implementation_t * mimp;
  const char * rm_encoding;
  struct sdp_rtpmap_t * map;
  char tmp[50];
  struct payload_map_t * pmap;
  int j;
  const struct switch_codec_implementation_t * timp;
  int num;
  char tmp[80];
  char * prefs[1];
  const struct switch_codec_implementation_t * search[1];
  int j;
  uint32_t codec_rate;
  uint32_t bit_rate;
  const struct switch_codec_implementation_t * imp;
  struct switch_codec_fmtp_t codec_fmtp;
  uint32_t map_bit_rate;
  const char * rm_encoding;
  int32_t i;
  int crypto_tag;
  struct sdp_rtpmap_t * map;
  const char * err;
  size_t __s2_len;
  size_t __s1_len;
  char tmp[32];
  switch_port_t remote_port;
  char * remote_host;
  struct switch_core_session_message_t * msg;
  struct switch_channel_t * other_channel;
  int pass;
  const char * var;
  struct switch_t38_options_t * t38_options;
  struct switch_core_session_t * other_session;
  struct sdp_connection_t * connection;
  register int __result;
  const unsigned char * __s1;
  size_t __s2_len;
  size_t __s1_len;
  static const char __func__[32] = "switch_core_media_negotiate_sdp";
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_negotiate_sdp";
  int nm_idx;
  int m_idx;
  const char * tmp;
  uint32_t fmtp_remote_codec_rate;
  uint32_t remote_codec_rate;
  int codec_ms;
  struct matches near_matches[30];
  struct matches matches[30];
  struct sdp_rtpmap_t * near_map;
  struct sdp_rtpmap_t * mmap;
  const struct switch_codec_implementation_t * near_match;
  const struct switch_codec_implementation_t * mimp;
  uint32_t near_rate;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  int total_codecs;
  const struct switch_codec_implementation_t * * codec_array;
  int reneg;
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  int scrooge;
  int got_webrtc;
  int got_udptl;
  int got_savp;
  int got_video_savp;
  int got_video_avp;
  int got_avp;
  int got_audio;
  int got_video_crypto;
  int got_crypto;
  const char * crypto;
  const char * val;
  struct switch_channel_t * channel;
  int skip;
  int x;
  int greedy;
  int recvonly;
  int sendonly;
  int dmaxptime;
  int maxptime;
  int dptime;
  int ptime;
  struct sdp_attribute_t * attr;
  struct sdp_media_t * m;
  switch_payload_t cng_pt;
  switch_payload_t te;
  switch_payload_t best_te;
  uint8_t match;
  switch_status_t D.45317;
  switch_bool_t D.45314;
  struct switch_codec_t * D.45313;
  _Bool D.45310;
  _Bool D.45309;
  _Bool D.45308;
  int D.45307;
  switch_payload_t D.45306;
  int D.45305;
  switch_payload_t D.45304;
  char * D.45303;
  char * D.45302;
  int D.45301;
  switch_port_t D.45300;
  char * D.45299;
  const char * D.45298;
  char * D.45297;
  uint32_t D.45296;
  int D.45295;
  const int D.45294;
  unsigned char D.45293;
  char * D.45292;
  switch_payload_t D.45291;
  struct switch_rtp_t * D.45288;
  struct payload_map_t * D.45287;
  uint32_t D.45284;
  int D.45283;
  const int D.45282;
  const uint32_t D.45281;
  const struct switch_codec_implementation_t * D.45280;
  uint32_t D.45279;
  <unnamed-unsigned:7> D.45278;
  const char * D.45277;
  const char * D.45276;
  struct sdp_rtpmap_t * D.45275;
  _Bool D.45268;
  _Bool D.45267;
  const uint32_t D.45264;
  long unsigned int D.45263;
  int D.45260;
  int D.45257;
  const char * D.45256;
  int D.45252;
  const switch_payload_t D.45251;
  char * const D.45250;
  int D.45249;
  <unnamed-unsigned:7> D.45248;
  uint32_t D.45245;
  switch_call_direction_t D.45242;
  const switch_codec_type_t D.45239;
  const struct switch_codec_implementation_t * * D.45238;
  unsigned int D.45237;
  unsigned int i.99;
  int D.45229;
  const char * D.45228;
  int D.45223;
  int D.45220;
  char * D.45215;
  short unsigned int D.45214;
  int D.45213;
  int D.45210;
  const unsigned char D.45209;
  char * D.45208;
  int D.45207;
  const unsigned char D.45206;
  const unsigned char * D.45205;
  _Bool D.45202;
  _Bool D.45201;
  int D.45200;
  const unsigned char D.45199;
  char * D.45198;
  int D.45197;
  const unsigned char D.45196;
  const unsigned char * D.45195;
  _Bool D.45192;
  _Bool D.45191;
  int D.45190;
  const unsigned char D.45189;
  char * D.45188;
  int D.45187;
  const unsigned char D.45186;
  const unsigned char * D.45185;
  _Bool D.45182;
  _Bool D.45181;
  _Bool D.45180;
  int D.45179;
  const unsigned char D.45178;
  char[2] * D.45177;
  int D.45176;
  const unsigned char D.45175;
  int D.39088;
  int iftmp.98;
  int D.39089;
  int D.45169;
  uint8_t D.45165;
  uint8_t D.45164;
  const char * D.45161;
  int D.45158;
  int D.45155;
  int D.45152;
  int D.45147;
  int D.45144;
  int D.45141;
  int D.45138;
  int D.45126;
  const char * D.45125;
  int D.45121;
  switch_call_direction_t D.45115;
  int D.45112;
  switch_payload_t D.45111;
  uint32_t D.45110;
  int32_t D.45108;
  switch_status_t D.45100;
  uint32_t D.45099;
  switch_bool_t D.45096;
  struct switch_codec_t * D.45095;
  int D.45094;
  switch_payload_t D.45093;
  int D.45090;
  char * D.45089;
  short unsigned int D.45088;
  char * D.45087;
  const char * D.45086;
  const char * D.45083;
  int D.45081;
  const char * D.45080;
  int D.45074;
  int D.45071;
  const char * D.45067;
  int iftmp.97;
  uint32_t D.45065;
  const int D.45064;
  uint32_t D.45063;
  int D.45062;
  const int D.45061;
  const uint32_t D.45060;
  int D.45057;
  const uint32_t D.45056;
  unsigned char D.45055;
  <unnamed-unsigned:7> D.45054;
  char * D.45053;
  char * const D.45052;
  char * D.45051;
  const char * D.45050;
  switch_payload_t D.45049;
  uint32_t D.45044;
  int D.45043;
  const int D.45042;
  const uint32_t D.45041;
  const struct switch_codec_implementation_t * D.45040;
  uint32_t D.45039;
  <unnamed-unsigned:7> D.45038;
  const char * D.45037;
  const char * D.45036;
  struct sdp_rtpmap_t * D.45035;
  int near_rate.96;
  int D.45029;
  const uint32_t D.45028;
  char * const D.45027;
  int D.45026;
  const int D.45025;
  const unsigned int iftmp.95;
  char * const D.45014;
  int D.45013;
  _Bool D.45010;
  _Bool D.45009;
  _Bool D.45008;
  _Bool D.45005;
  _Bool D.45004;
  _Bool D.45003;
  switch_rtp_crypto_mode_t D.45002;
  _Bool D.45000;
  _Bool D.44999;
  _Bool D.44998;
  int D.44997;
  int codec_rate.94;
  int D.44994;
  _Bool D.44992;
  _Bool D.44991;
  _Bool D.44990;
  const uint32_t D.44985;
  int D.44980;
  int D.44978;
  _Bool D.44975;
  _Bool D.44974;
  _Bool D.44973;
  _Bool D.44970;
  _Bool D.44969;
  int D.44964;
  int D.44961;
  _Bool D.44958;
  _Bool D.44957;
  _Bool D.44956;
  _Bool D.44953;
  _Bool D.44952;
  _Bool D.44951;
  const uint32_t D.44948;
  int D.44945;
  int iftmp.93;
  _Bool D.44939;
  int D.44938;
  int D.44937;
  int D.44935;
  int D.44931;
  const int D.44930;
  int D.44929;
  const switch_payload_t D.44928;
  char * const D.44927;
  int remote_codec_rate.92;
  int D.44925;
  const switch_codec_type_t D.44922;
  const int D.44921;
  const struct switch_codec_implementation_t * * D.44920;
  unsigned int D.44919;
  unsigned int i.91;
  uint32_t D.44915;
  int D.44912;
  int D.44909;
  switch_status_t D.44906;
  int D.44901;
  int D.44897;
  int D.44894;
  const char * D.44893;
  int D.44890;
  const char * D.44889;
  unsigned char D.44886;
  uint32_t D.44885;
  uint32_t D.44884;
  _Bool D.44879;
  _Bool D.44878;
  _Bool D.44877;
  _Bool D.44870;
  switch_payload_t D.44869;
  int D.44868;
  int D.44863;
  int32_t D.44858;
  int D.44857;
  <unnamed-unsigned:7> D.44856;
  long unsigned int D.44855;
  long unsigned int D.44854;
  int D.44848;
  int D.44839;
  _Bool D.44836;
  _Bool D.44835;
  _Bool D.44834;
  _Bool D.44831;
  _Bool D.44830;
  _Bool D.44829;
  int D.44826;
  const char * D.44825;
  unsigned int D.44822;
  switch_core_media_NDLB_t D.44821;
  int D.44818;
  int D.44815;
  int D.44810;
  int D.44805;
  char * D.44800;
  short unsigned int D.44799;
  int D.44798;
  int D.44795;
  int D.44790;
  int D.44787;
  int D.44784;
  int D.44781;
  _Bool D.44779;
  _Bool D.44778;
  _Bool D.44777;
  char * D.44773;
  struct switch_channel_t * D.44772;
  const char * err.90;
  switch_status_t D.44768;
  int D.44767;
  int D.44766;
  char * D.44765;
  char * D.44764;
  switch_port_t D.44762;
  char * D.44760;
  int D.39032;
  _Bool D.44758;
  _Bool D.44757;
  _Bool D.44756;
  uint16_t D.44753;
  char * D.44752;
  const char * D.44751;
  struct payload_map_t * D.44750;
  int D.44747;
  const char * D.44746;
  int D.44743;
  const char * D.44742;
  char * D.44741;
  char * D.44740;
  uint32_t D.44737;
  struct switch_core_session_t * other_session.89;
  switch_status_t D.44733;
  uint8_t D.44730;
  uint32_t D.44728;
  uint32_t D.44726;
  uint32_t D.44724;
  uint32_t D.44723;
  int D.44716;
  int D.44707;
  uint32_t D.44706;
  int D.44703;
  const char * D.44702;
  int D.44699;
  long unsigned int D.44697;
  sdp_media_e D.44681;
  _Bool D.44678;
  _Bool D.44677;
  _Bool D.44676;
  sdp_proto_e D.44675;
  int D.44672;
  const char * D.44669;
  sdp_proto_e D.44666;
  const char * D.44665;
  const char * D.44663;
  const char * D.44661;
  int D.44655;
  struct switch_media_bug_t * D.44649;
  int D.44640;
  int D.44639;
  int D.44636;
  int D.44635;
  int32_t D.44631;
  _Bool D.44626;
  _Bool D.44625;
  _Bool D.44624;
  int D.44621;
  const char * D.44619;
  int D.44616;
  int D.44614;
  uint8_t D.44606;
  struct switch_rtp_t * D.44605;
  int D.44602;
  int D.44598;
  int D.44594;
  int D.44591;
  const char * D.44590;
  int D.44588;
  const unsigned char D.44587;
  char * D.44586;
  int D.44585;
  const unsigned char D.44584;
  const unsigned char * D.44583;
  _Bool D.44580;
  _Bool D.44579;
  int D.44578;
  const unsigned char D.44577;
  char * D.44576;
  int D.44575;
  const unsigned char D.44574;
  const unsigned char * D.44573;
  _Bool D.44570;
  _Bool D.44569;
  int D.44568;
  const unsigned char D.44567;
  char * D.44566;
  int D.44565;
  const unsigned char D.44564;
  const unsigned char * D.44563;
  _Bool D.44560;
  _Bool D.44559;
  _Bool D.44558;
  int D.44557;
  const unsigned char D.44556;
  char[8] * D.44555;
  int D.44554;
  const unsigned char D.44553;
  int D.39007;
  int iftmp.88;
  int D.39008;
  const char * D.44548;
  struct sdp_connection_t * D.44546;
  _Bool D.44544;
  _Bool D.44543;
  _Bool D.44542;
  unsigned char D.44541;
  unsigned char D.44540;
  int D.44533;
  struct switch_channel_t * D.44530;
  unsigned int D.44529;
  char * D.44526;
  unsigned int D.44523;
  unsigned int D.44522;
  switch_rtp_bug_flag_t D.44521;
  char * D.44518;
  _Bool D.44515;
  int D.44514;
  int D.44513;
  switch_rtp_bug_flag_t D.44512;
  char * D.44509;
  char * D.44508;
  const char * D.44507;
  struct sdp_origin_t * D.44506;
  int D.44502;
  int D.44498;
  int D.44494;
  int32_t D.44491;
  int32_t D.44490;
  int D.44485;
  struct switch_channel_t * D.44482;
  struct switch_core_session_t * D.44481;
  int D.44478;
  int D.44473;
  size_t D.44472;
  struct switch_core_media_params_t * D.44471;
  uint8_t D.44470;

<bb 2>:
  match = 0;
  best_te = 0;
  te = 0;
  cng_pt = 0;
  ptime = 0;
  dptime = 0;
  maxptime = 0;
  dmaxptime = 0;
  sendonly = 0;
  recvonly = 0;
  greedy = 0;
  x = 0;
  skip = 0;
  channel = switch_core_session_get_channel (session);
  crypto = 0B;
  got_crypto = 0;
  got_video_crypto = 0;
  got_audio = 0;
  got_avp = 0;
  got_video_avp = 0;
  got_video_savp = 0;
  got_savp = 0;
  got_udptl = 0;
  got_webrtc = 0;
  scrooge = 0;
  parser = 0B;
  reneg = 1;
  near_rate = 0;
  mimp = 0B;
  near_match = 0B;
  mmap = 0B;
  near_map = 0B;
  matches = {};
  near_matches = {};
  codec_ms = 0;
  remote_codec_rate = 0;
  fmtp_remote_codec_rate = 0;
  m_idx = 0;
  nm_idx = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2922, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.44470 = 0;
  goto <bb 402>;

<bb 6>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  codec_array = &smh->codecs;
  D.44471 = smh->mparams;
  total_codecs = D.44471->num_codecs;
  D.44472 = strlen (r_sdp);
  D.44473 = (int) D.44472;
  parser = sdp_parse (0B, r_sdp, D.44473, 0);
  if (parser == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.44470 = 0;
  goto <bb 402>;

<bb 8>:
  sdp = sdp_session (parser);
  if (sdp == 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  sdp_parser_free (parser);
  D.44470 = 0;
  goto <bb 402>;

<bb 10>:
  D.44478 = dtls_ok (session);
  if (D.44478 != 0)
    goto <bb 11>;
  else
    goto <bb 14>;

<bb 11>:
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  tmp = switch_channel_get_variable_dup (D.44482, "webrtc_enable_dtls", 1, -1);
  if (tmp != 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

<bb 12>:
  D.44485 = switch_false (tmp);
  if (D.44485 != 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  switch_channel_clear_flag (D.44482, 111);
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  switch_channel_clear_flag (D.44482, 109);

<bb 14>:
  switch_core_session_parse_crypto_prefs (session);
  clear_pmaps (a_engine);
  clear_pmaps (v_engine);
  if (proceed != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  *proceed = 1;

<bb 16>:
  D.44490 = switch_media_handle_test_media_flag (smh, 3);
  greedy = D.44490 != 0;
  D.44491 = switch_media_handle_test_media_flag (smh, 4);
  scrooge = D.44491 != 0;
  val = switch_channel_get_variable_dup (channel, "rtp_codec_negotiation", 1, -1);
  if (val != 0B)
    goto <bb 17>;
  else
    goto <bb 24>;

<bb 17>:
  D.44494 = strcasecmp (val, "generous");
  if (D.44494 == 0)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  greedy = 0;
  scrooge = 0;
  goto <bb 24>;

<bb 19>:
  D.44498 = strcasecmp (val, "greedy");
  if (D.44498 == 0)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  greedy = 1;
  scrooge = 0;
  goto <bb 24>;

<bb 21>:
  D.44502 = strcasecmp (val, "scrooge");
  if (D.44502 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  scrooge = 1;
  greedy = 1;
  goto <bb 24>;

<bb 23>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2969, session, 7, "rtp_codec_negotiation ignored invalid value : \'%s\' \n", val);

<bb 24>:
  D.44506 = sdp->sdp_origin;
  D.44507 = D.44506->o_username;
  D.44508 = switch_core_perform_session_strdup (session, D.44507, "src/switch_core_media.c", &__func__, 2973);
  smh->origin = D.44508;
  D.44509 = smh->origin;
  if (D.44509 != 0B)
    goto <bb 25>;
  else
    goto <bb 31>;

<bb 25>:
  D.44471 = smh->mparams;
  D.44512 = D.44471->auto_rtp_bugs;
  D.44513 = (int) D.44512;
  D.44514 = D.44513 & 1;
  D.44515 = (_Bool) D.44514;
  if (D.44515 != 0)
    goto <bb 26>;
  else
    goto <bb 28>;

<bb 26>:
  D.44509 = smh->origin;
  D.44518 = strstr (D.44509, "CiscoSystemsSIP-GW-UserAgent");
  if (D.44518 != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  D.44521 = a_engine->rtp_bugs;
  D.44522 = D.44521 | 1;
  a_engine->rtp_bugs = D.44522;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2979, session, 7, "Activate Buggy RFC2833 Mode!\n");

<bb 28>:
  D.44471 = smh->mparams;
  D.44512 = D.44471->auto_rtp_bugs;
  D.44523 = D.44512 & 2;
  if (D.44523 != 0)
    goto <bb 29>;
  else
    goto <bb 31>;

<bb 29>:
  D.44509 = smh->origin;
  D.44526 = strstr (D.44509, "Sonus_UAC");
  if (D.44526 != 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  D.44521 = a_engine->rtp_bugs;
  D.44529 = D.44521 | 2;
  a_engine->rtp_bugs = D.44529;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2986, session, 4, "Hello,\nI see you have a Sonus!\nFYI, Sonus cannot follow the RFC on the proper way to send DTMF.\nSadly, my creator had to spend several hours figuring this out so I thought you\'d like to know that!\nDon\'t worry, DTMF will work but you may want to ask them to fix it......\n");

<bb 31>:
  D.44530 = session->channel;
  val = switch_channel_get_variable_dup (D.44530, "rtp_liberal_dtmf", 1, -1);
  if (val != 0B)
    goto <bb 32>;
  else
    goto <bb 34>;

<bb 32>:
  D.44533 = switch_true (val);
  if (D.44533 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.44530 = session->channel;
  switch_channel_set_flag_value (D.44530, 93, 1);

<bb 34>:
  m = sdp->sdp_media;
  if (m != 0B)
    goto <bb 35>;
  else
    goto <bb 47>;

<bb 35>:
  D.44540 = BIT_FIELD_REF <*m, 8, 544>;
  D.44541 = D.44540 & 6;
  D.44542 = D.44541 == 2;
  D.44543 = D.44541 == 0;
  D.44544 = D.44542 || D.44543;
  if (D.44544 != 0)
    goto <bb 46>;
  else
    goto <bb 36>;

<bb 36>:
  D.44546 = m->m_connections;
  if (D.44546 != 0B)
    goto <bb 37>;
  else
    goto <bb 47>;

<bb 37>:
  D.44546 = m->m_connections;
  D.44548 = D.44546->c_address;
  if (D.44548 != 0B)
    goto <bb 38>;
  else
    goto <bb 47>;

<bb 38>:
  __s2_len = 7;
  if (__s2_len <= 3)
    goto <bb 39>;
  else
    goto <bb 44>;

<bb 39>:
  D.44546 = m->m_connections;
  __s1 = D.44546->c_address;
  D.44553 = *__s1;
  D.44554 = (int) D.44553;
  D.44555 = "0.0.0.0";
  D.44556 = MEM[(const unsigned char *)D.44555];
  D.44557 = (int) D.44556;
  __result = D.44554 - D.44557;
  D.44558 = __s2_len != 0;
  D.44559 = __result == 0;
  D.44560 = D.44558 && D.44559;
  if (D.44560 != 0)
    goto <bb 40>;
  else
    goto <bb 43>;

<bb 40>:
  D.44563 = __s1 + 1;
  D.44564 = *D.44563;
  D.44565 = (int) D.44564;
  D.44566 = &"0.0.0.0"[1];
  D.44567 = MEM[(const unsigned char *)D.44566];
  D.44568 = (int) D.44567;
  __result = D.44565 - D.44568;
  D.44569 = __s2_len > 1;
  D.44559 = __result == 0;
  D.44570 = D.44569 && D.44559;
  if (D.44570 != 0)
    goto <bb 41>;
  else
    goto <bb 43>;

<bb 41>:
  D.44573 = __s1 + 2;
  D.44574 = *D.44573;
  D.44575 = (int) D.44574;
  D.44576 = &"0.0.0.0"[2];
  D.44577 = MEM[(const unsigned char *)D.44576];
  D.44578 = (int) D.44577;
  __result = D.44575 - D.44578;
  D.44579 = __s2_len > 2;
  D.44559 = __result == 0;
  D.44580 = D.44579 && D.44559;
  if (D.44580 != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

<bb 42>:
  D.44583 = __s1 + 3;
  D.44584 = *D.44583;
  D.44585 = (int) D.44584;
  D.44586 = &"0.0.0.0"[3];
  D.44587 = MEM[(const unsigned char *)D.44586];
  D.44588 = (int) D.44587;
  __result = D.44585 - D.44588;

<bb 43>:
  D.39007 = __result;
  iftmp.88 = D.39007;
  goto <bb 45>;

<bb 44>:
  D.44546 = m->m_connections;
  D.44548 = D.44546->c_address;
  iftmp.88 = __builtin_strcmp (D.44548, "0.0.0.0");

<bb 45>:
  D.39008 = iftmp.88;
  if (D.39008 == 0)
    goto <bb 46>;
  else
    goto <bb 47>;

<bb 46>:
  sendonly = 2;

<bb 47>:
  attr = sdp->sdp_attributes;
  goto <bb 66>;

<bb 48>:
  D.44590 = attr->a_name;
  D.44591 = _zstr (D.44590);
  if (D.44591 != 0)
    goto <bb 49>;
  else
    goto <bb 50>;

<bb 49>:
  // predicted unlikely by continue predictor.
  goto <bb 65>;

<bb 50>:
  D.44590 = attr->a_name;
  D.44594 = strcasecmp (D.44590, "sendonly");
  if (D.44594 == 0)
    goto <bb 51>;
  else
    goto <bb 52>;

<bb 51>:
  sendonly = 1;
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "media_audio_mode", "recvonly", 1);
  goto <bb 65>;

<bb 52>:
  D.44590 = attr->a_name;
  D.44598 = strcasecmp (D.44590, "inactive");
  if (D.44598 == 0)
    goto <bb 53>;
  else
    goto <bb 54>;

<bb 53>:
  sendonly = 1;
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "media_audio_mode", "inactive", 1);
  goto <bb 65>;

<bb 54>:
  D.44590 = attr->a_name;
  D.44602 = strcasecmp (D.44590, "recvonly");
  if (D.44602 == 0)
    goto <bb 55>;
  else
    goto <bb 58>;

<bb 55>:
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "media_audio_mode", "sendonly", 1);
  recvonly = 1;
  D.44605 = a_engine->rtp_session;
  D.44606 = switch_rtp_ready (D.44605);
  if (D.44606 != 0)
    goto <bb 56>;
  else
    goto <bb 57>;

<bb 56>:
  D.44605 = a_engine->rtp_session;
  switch_rtp_set_max_missed_packets (D.44605, 0);
  a_engine->max_missed_hold_packets = 0;
  a_engine->max_missed_packets = 0;
  goto <bb 65>;

<bb 57>:
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "rtp_timeout_sec", "0", 1);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "rtp_hold_timeout_sec", "0", 1);
  goto <bb 65>;

<bb 58>:
  if (sendonly <= 1)
    goto <bb 59>;
  else
    goto <bb 61>;

<bb 59>:
  D.44590 = attr->a_name;
  D.44614 = strcasecmp (D.44590, "sendrecv");
  if (D.44614 == 0)
    goto <bb 60>;
  else
    goto <bb 61>;

<bb 60>:
  sendonly = 0;
  goto <bb 65>;

<bb 61>:
  D.44590 = attr->a_name;
  D.44616 = strcasecmp (D.44590, "ptime");
  if (D.44616 == 0)
    goto <bb 62>;
  else
    goto <bb 63>;

<bb 62>:
  D.44619 = attr->a_value;
  dptime = atoi (D.44619);
  goto <bb 65>;

<bb 63>:
  D.44590 = attr->a_name;
  D.44621 = strcasecmp (D.44590, "maxptime");
  if (D.44621 == 0)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  D.44619 = attr->a_value;
  dmaxptime = atoi (D.44619);

<bb 65>:
  attr = attr->a_next;

<bb 66>:
  if (attr != 0B)
    goto <bb 48>;
  else
    goto <bb 67>;

<bb 67>:
  D.44624 = sendonly != 1;
  D.44625 = recvonly != 1;
  D.44626 = D.44624 && D.44625;
  if (D.44626 != 0)
    goto <bb 68>;
  else
    goto <bb 69>;

<bb 68>:
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "media_audio_mode", 0B, 1);

<bb 69>:
  D.44631 = switch_media_handle_test_media_flag (smh, 5);
  if (D.44631 == 0)
    goto <bb 70>;
  else
    goto <bb 76>;

<bb 70>:
  D.44530 = session->channel;
  val = switch_channel_get_variable_dup (D.44530, "rtp_disable_hold", 1, -1);
  if (val == 0B)
    goto <bb 72>;
  else
    goto <bb 71>;

<bb 71>:
  D.44635 = switch_true (val);
  if (D.44635 == 0)
    goto <bb 72>;
  else
    goto <bb 76>;

<bb 72>:
  D.44471 = smh->mparams;
  D.44636 = D.44471->hold_laps;
  if (D.44636 == 0)
    goto <bb 73>;
  else
    goto <bb 76>;

<bb 73>:
  D.44471 = smh->mparams;
  D.44636 = D.44471->hold_laps;
  D.44639 = D.44636 + 1;
  D.44471->hold_laps = D.44639;
  D.44640 = switch_core_media_toggle_hold (session, sendonly);
  if (D.44640 != 0)
    goto <bb 74>;
  else
    goto <bb 76>;

<bb 74>:
  reneg = switch_media_handle_test_media_flag (smh, 6);
  D.44530 = session->channel;
  val = switch_channel_get_variable_dup (D.44530, "rtp_renegotiate_codec_on_hold", 1, -1);
  if (val != 0B)
    goto <bb 75>;
  else
    goto <bb 76>;

<bb 75>:
  reneg = switch_true (val);

<bb 76>:
  if (reneg != 0)
    goto <bb 77>;
  else
    goto <bb 79>;

<bb 77>:
  reneg = switch_media_handle_test_media_flag (smh, 7);
  D.44530 = session->channel;
  val = switch_channel_get_variable_dup (D.44530, "rtp_renegotiate_codec_on_reinvite", 1, -1);
  if (val != 0B)
    goto <bb 78>;
  else
    goto <bb 79>;

<bb 78>:
  reneg = switch_true (val);

<bb 79>:
  D.44649 = session->bugs;
  if (D.44649 != 0B)
    goto <bb 80>;
  else
    goto <bb 81>;

<bb 80>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3063, session, 7, "Session is connected to a media bug. Re-Negotiation implicitly disabled.\n");
  reneg = 0;

<bb 81>:
  if (reneg == 0)
    goto <bb 82>;
  else
    goto <bb 84>;

<bb 82>:
  D.44655 = smh->num_negotiated_codecs;
  if (D.44655 != 0)
    goto <bb 83>;
  else
    goto <bb 84>;

<bb 83>:
  codec_array = &smh->negotiated_codecs;
  total_codecs = smh->num_negotiated_codecs;
  goto <bb 86>;

<bb 84>:
  if (reneg != 0)
    goto <bb 85>;
  else
    goto <bb 86>;

<bb 85>:
  D.44471 = smh->mparams;
  D.44471->num_codecs = 0;
  switch_core_media_prepare_codecs (session, 0);
  codec_array = &smh->codecs;
  D.44471 = smh->mparams;
  total_codecs = D.44471->num_codecs;

<bb 86>:
  D.44661 = switch_stristr ("T38FaxFillBitRemoval:", r_sdp);
  if (D.44661 != 0B)
    goto <bb 89>;
  else
    goto <bb 87>;

<bb 87>:
  D.44663 = switch_stristr ("T38FaxTranscodingMMR:", r_sdp);
  if (D.44663 != 0B)
    goto <bb 89>;
  else
    goto <bb 88>;

<bb 88>:
  D.44665 = switch_stristr ("T38FaxTranscodingJBIG:", r_sdp);
  if (D.44665 != 0B)
    goto <bb 89>;
  else
    goto <bb 90>;

<bb 89>:
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "t38_broken_boolean", "true", 1);

<bb 90>:
  switch_core_media_find_zrtp_hash (session, sdp);
  switch_core_media_pass_zrtp_hash (session);
  check_ice (smh, 0, sdp, 0B);
  check_ice (smh, 1, sdp, 0B);
  m = sdp->sdp_media;
  goto <bb 398>;

<bb 91>:
  ptime = dptime;
  maxptime = dmaxptime;
  D.44666 = m->m_proto;
  if (D.44666 == 261)
    goto <bb 92>;
  else
    goto <bb 93>;

<bb 92>:
  got_webrtc = got_webrtc + 1;
  switch_core_session_set_ice (session);

<bb 93>:
  D.44669 = m->m_proto_name;
  if (D.44669 != 0B)
    goto <bb 94>;
  else
    goto <bb 96>;

<bb 94>:
  D.44669 = m->m_proto_name;
  D.44672 = strcasecmp (D.44669, "UDP/TLS/RTP/SAVPF");
  if (D.44672 == 0)
    goto <bb 95>;
  else
    goto <bb 96>;

<bb 95>:
  D.44530 = session->channel;
  switch_channel_set_flag_value (D.44530, 107, 1);

<bb 96>:
  D.44675 = m->m_proto;
  D.44676 = D.44675 == 257;
  D.44677 = D.44675 == 261;
  D.44678 = D.44676 || D.44677;
  if (D.44678 != 0)
    goto <bb 97>;
  else
    goto <bb 100>;

<bb 97>:
  D.44681 = m->m_type;
  if (D.44681 == 2)
    goto <bb 98>;
  else
    goto <bb 99>;

<bb 98>:
  got_savp = got_savp + 1;
  goto <bb 106>;

<bb 99>:
  got_video_savp = got_video_savp + 1;
  goto <bb 106>;

<bb 100>:
  D.44666 = m->m_proto;
  if (D.44666 == 256)
    goto <bb 101>;
  else
    goto <bb 104>;

<bb 101>:
  D.44681 = m->m_type;
  if (D.44681 == 2)
    goto <bb 102>;
  else
    goto <bb 103>;

<bb 102>:
  got_avp = got_avp + 1;
  goto <bb 106>;

<bb 103>:
  got_video_avp = got_video_avp + 1;
  goto <bb 106>;

<bb 104>:
  D.44666 = m->m_proto;
  if (D.44666 == 258)
    goto <bb 105>;
  else
    goto <bb 106>;

<bb 105>:
  got_udptl = got_udptl + 1;

<bb 106>:
  if (got_udptl != 0)
    goto <bb 107>;
  else
    goto <bb 142>;

<bb 107>:
  D.44681 = m->m_type;
  if (D.44681 == 8)
    goto <bb 108>;
  else
    goto <bb 142>;

<bb 108>:
  D.44697 = m->m_port;
  if (D.44697 != 0)
    goto <bb 109>;
  else
    goto <bb 142>;

<bb 109>:
  t38_options = switch_core_media_process_udptl (session, sdp, m);
  D.44530 = session->channel;
  D.44699 = switch_channel_test_app_flag_key ("T38", D.44530, 16);
  if (D.44699 != 0)
    goto <bb 110>;
  else
    goto <bb 111>;

<bb 110>:
  match = 1;
  goto <bb 399> (done);

<bb 111>:
  D.44702 = switch_channel_get_variable_dup (channel, "refuse_t38", 1, -1);
  D.44703 = switch_true (D.44702);
  if (D.44703 != 0)
    goto <bb 112>;
  else
    goto <bb 113>;

<bb 112>:
  D.44530 = session->channel;
  switch_channel_clear_app_flag_key ("T38", D.44530, 2);
  match = 0;
  goto <bb 399> (done);

<bb 113>:
  var = switch_channel_get_variable_dup (channel, "t38_passthru", 1, -1);
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  D.44706 = switch_channel_test_flag (D.44482, 101);
  pass = (int) D.44706;
  D.44530 = session->channel;
  D.44707 = switch_channel_test_app_flag_key ("T38", D.44530, 2);
  if (D.44707 != 0)
    goto <bb 114>;
  else
    goto <bb 116>;

<bb 114>:
  if (proceed != 0B)
    goto <bb 115>;
  else
    goto <bb 116>;

<bb 115>:
  *proceed = 0;

<bb 116>:
  if (var != 0B)
    goto <bb 117>;
  else
    goto <bb 120>;

<bb 117>:
  pass = switch_true (var);
  if (pass == 0)
    goto <bb 118>;
  else
    goto <bb 120>;

<bb 118>:
  D.44716 = strcasecmp (var, "once");
  if (D.44716 == 0)
    goto <bb 119>;
  else
    goto <bb 120>;

<bb 119>:
  pass = 2;

<bb 120>:
  if (pass == 2)
    goto <bb 121>;
  else
    goto <bb 122>;

<bb 121>:
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  D.44723 = switch_channel_test_flag (D.44482, 101);
  if (D.44723 != 0)
    goto <bb 126>;
  else
    goto <bb 122>;

<bb 122>:
  D.44530 = session->channel;
  D.44724 = switch_channel_test_flag (D.44530, 103);
  if (D.44724 == 0)
    goto <bb 126>;
  else
    goto <bb 123>;

<bb 123>:
  D.44530 = session->channel;
  D.44726 = switch_channel_test_flag (D.44530, 15);
  if (D.44726 != 0)
    goto <bb 126>;
  else
    goto <bb 124>;

<bb 124>:
  D.44530 = session->channel;
  D.44728 = switch_channel_test_flag (D.44530, 29);
  if (D.44728 != 0)
    goto <bb 126>;
  else
    goto <bb 125>;

<bb 125>:
  D.44605 = a_engine->rtp_session;
  D.44730 = switch_rtp_ready (D.44605);
  if (D.44730 == 0)
    goto <bb 126>;
  else
    goto <bb 127>;

<bb 126>:
  pass = 0;

<bb 127>:
  if (pass != 0)
    goto <bb 128>;
  else
    goto <bb 141>;

<bb 128>:
  D.44733 = switch_core_session_perform_get_partner (session, &other_session, "src/switch_core_media.c", &__func__, 3161);
  if (D.44733 == 0)
    goto <bb 129>;
  else
    goto <bb 141>;

<bb 129>:
  other_session.89 = other_session;
  other_channel = switch_core_session_get_channel (other_session.89);
  D.44605 = a_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.44605);
  D.44605 = a_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.44605);
  tmp = "";
  D.44737 = switch_channel_test_flag (other_channel, 1);
  if (D.44737 == 0)
    goto <bb 130>;
  else
    goto <bb 131>;

<bb 130>:
  D.44530 = session->channel;
  D.44740 = switch_channel_get_name (D.44530);
  D.44741 = switch_channel_get_name (other_channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3170, session, 4, "%s Error Passing T.38 to unanswered channel %s\n", D.44740, D.44741);
  other_session.89 = other_session;
  switch_core_session_rwunlock (other_session.89);
  pass = 0;
  match = 0;
  goto <bb 399> (done);

<bb 131>:
  D.44530 = session->channel;
  D.44742 = switch_channel_get_variable_dup (D.44530, "t38_broken_boolean", 1, -1);
  D.44743 = switch_true (D.44742);
  if (D.44743 != 0)
    goto <bb 132>;
  else
    goto <bb 134>;

<bb 132>:
  D.44530 = session->channel;
  D.44746 = switch_channel_get_variable_dup (D.44530, "t38_pass_broken_boolean", 1, -1);
  D.44747 = switch_true (D.44746);
  if (D.44747 != 0)
    goto <bb 133>;
  else
    goto <bb 134>;

<bb 133>:
  switch_channel_set_variable_var_check (other_channel, "t38_broken_boolean", "true", 1);

<bb 134>:
  D.44750 = a_engine->cur_payload_map;
  D.44751 = t38_options->remote_ip;
  D.44752 = switch_core_perform_session_strdup (session, D.44751, "src/switch_core_media.c", &__func__, 3186);
  D.44750->remote_sdp_ip = D.44752;
  D.44750 = a_engine->cur_payload_map;
  D.44753 = t38_options->remote_port;
  D.44750->remote_sdp_port = D.44753;
  D.44756 = remote_host != 0B;
  D.44757 = remote_port != 0;
  D.44758 = D.44756 && D.44757;
  if (D.44758 != 0)
    goto <bb 135>;
  else
    goto <bb 138>;

<bb 135>:
  D.44750 = a_engine->cur_payload_map;
  D.44760 = D.44750->remote_sdp_ip;
  D.39032 = __builtin_strcmp (remote_host, D.44760);
  if (D.39032 == 0)
    goto <bb 136>;
  else
    goto <bb 138>;

<bb 136>:
  D.44750 = a_engine->cur_payload_map;
  D.44762 = D.44750->remote_sdp_port;
  if (D.44762 == remote_port)
    goto <bb 137>;
  else
    goto <bb 138>;

<bb 137>:
  D.44530 = session->channel;
  D.44764 = switch_channel_get_name (D.44530);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3190, session, 7, "Audio params are unchanged for %s.\n", D.44764);
  goto <bb 140>;

<bb 138>:
  err = 0B;
  D.44530 = session->channel;
  D.44765 = switch_channel_get_name (D.44530);
  D.44766 = (int) remote_port;
  D.44750 = a_engine->cur_payload_map;
  D.44760 = D.44750->remote_sdp_ip;
  D.44750 = a_engine->cur_payload_map;
  D.44762 = D.44750->remote_sdp_port;
  D.44767 = (int) D.44762;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3195, session, 7, "Audio params changed for %s from %s:%d to %s:%d\n", D.44765, remote_host, D.44766, D.44760, D.44767);
  D.44750 = a_engine->cur_payload_map;
  D.44762 = D.44750->remote_sdp_port;
  D.44767 = (int) D.44762;
  switch_snprintf (&tmp, 32, "%d", D.44767);
  D.44530 = session->channel;
  D.44750 = a_engine->cur_payload_map;
  D.44760 = D.44750->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.44530, "remote_media_ip", D.44760, 1);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "remote_media_port", &tmp, 1);
  D.44605 = a_engine->rtp_session;
  D.44750 = a_engine->cur_payload_map;
  D.44760 = D.44750->remote_sdp_ip;
  D.44750 = a_engine->cur_payload_map;
  D.44762 = D.44750->remote_sdp_port;
  D.44768 = switch_rtp_set_remote_address (D.44605, D.44760, D.44762, 0, 1, &err);
  if (D.44768 != 0)
    goto <bb 139>;
  else
    goto <bb 140>;

<bb 139>:
  err.90 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3205, session, 3, "AUDIO RTP REPORTS ERROR: [%s]\n", err.90);
  switch_channel_perform_hangup (channel, "src/switch_core_media.c", &__func__, 3206, 88);

<bb 140>:
  other_session.89 = other_session;
  switch_core_media_copy_t38_options (t38_options, other_session.89);
  D.44481 = smh->session;
  D.44482 = D.44481->channel;
  switch_channel_set_flag_value (D.44482, 101, 1);
  other_session.89 = other_session;
  D.44772 = other_session.89->channel;
  switch_channel_set_flag_value (D.44772, 101, 1);
  other_session.89 = other_session;
  msg = switch_core_perform_session_alloc (other_session.89, 108, "src/switch_core_media.c", &__func__, 3218);
  msg->message_id = 21;
  msg->from = "src/switch_core_media.c";
  other_session.89 = other_session;
  D.44773 = switch_core_perform_session_strdup (other_session.89, r_sdp, "src/switch_core_media.c", &__func__, 3221);
  msg->string_arg = D.44773;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3222, session, 7, "Passing T38 req to other leg.\n%s\n", r_sdp);
  other_session.89 = other_session;
  switch_core_session_queue_message (other_session.89, msg);
  other_session.89 = other_session;
  switch_core_session_rwunlock (other_session.89);

<bb 141>:
  match = 1;
  goto <bb 399> (done);

<bb 142>:
  D.44681 = m->m_type;
  if (D.44681 == 2)
    goto <bb 143>;
  else
    goto <bb 314>;

<bb 143>:
  D.44697 = m->m_port;
  D.44777 = D.44697 != 0;
  D.44778 = got_audio == 0;
  D.44779 = D.44777 && D.44778;
  if (D.44779 != 0)
    goto <bb 144>;
  else
    goto <bb 314>;

<bb 144>:
  D.44781 = switch_rtp_has_dtls ();
  if (D.44781 != 0)
    goto <bb 145>;
  else
    goto <bb 152>;

<bb 145>:
  D.44784 = dtls_ok (session);
  if (D.44784 != 0)
    goto <bb 146>;
  else
    goto <bb 152>;

<bb 146>:
  attr = m->m_attributes;
  goto <bb 151>;

<bb 147>:
  D.44590 = attr->a_name;
  D.44787 = strcasecmp (D.44590, "fingerprint");
  if (D.44787 == 0)
    goto <bb 148>;
  else
    goto <bb 150>;

<bb 148>:
  D.44619 = attr->a_value;
  D.44790 = _zstr (D.44619);
  if (D.44790 == 0)
    goto <bb 149>;
  else
    goto <bb 150>;

<bb 149>:
  got_crypto = 1;

<bb 150>:
  attr = attr->a_next;

<bb 151>:
  if (attr != 0B)
    goto <bb 147>;
  else
    goto <bb 152>;

<bb 152>:
  attr = m->m_attributes;
  goto <bb 172>;

<bb 153>:
  D.44590 = attr->a_name;
  D.44795 = strcasecmp (D.44590, "rtcp");
  if (D.44795 == 0)
    goto <bb 154>;
  else
    goto <bb 157>;

<bb 154>:
  D.44619 = attr->a_value;
  if (D.44619 != 0B)
    goto <bb 155>;
  else
    goto <bb 157>;

<bb 155>:
  D.44530 = session->channel;
  D.44619 = attr->a_value;
  switch_channel_set_variable_var_check (D.44530, "rtp_remote_audio_rtcp_port", D.44619, 1);
  D.44619 = attr->a_value;
  D.44798 = atoi (D.44619);
  D.44799 = (short unsigned int) D.44798;
  a_engine->remote_rtcp_port = D.44799;
  D.44471 = smh->mparams;
  D.44800 = D.44471->rtcp_audio_interval_msec;
  if (D.44800 == 0B)
    goto <bb 156>;
  else
    goto <bb 171>;

<bb 156>:
  D.44471 = smh->mparams;
  D.44471->rtcp_audio_interval_msec = "5000";
  goto <bb 171>;

<bb 157>:
  D.44590 = attr->a_name;
  D.44805 = strcasecmp (D.44590, "ptime");
  if (D.44805 == 0)
    goto <bb 158>;
  else
    goto <bb 160>;

<bb 158>:
  D.44619 = attr->a_value;
  if (D.44619 != 0B)
    goto <bb 159>;
  else
    goto <bb 160>;

<bb 159>:
  D.44619 = attr->a_value;
  ptime = atoi (D.44619);
  goto <bb 171>;

<bb 160>:
  D.44590 = attr->a_name;
  D.44810 = strcasecmp (D.44590, "maxptime");
  if (D.44810 == 0)
    goto <bb 161>;
  else
    goto <bb 163>;

<bb 161>:
  D.44619 = attr->a_value;
  if (D.44619 != 0B)
    goto <bb 162>;
  else
    goto <bb 163>;

<bb 162>:
  D.44619 = attr->a_value;
  maxptime = atoi (D.44619);
  goto <bb 171>;

<bb 163>:
  if (got_crypto <= 0)
    goto <bb 164>;
  else
    goto <bb 171>;

<bb 164>:
  D.44590 = attr->a_name;
  D.44815 = strcasecmp (D.44590, "crypto");
  if (D.44815 == 0)
    goto <bb 165>;
  else
    goto <bb 171>;

<bb 165>:
  D.44619 = attr->a_value;
  D.44818 = _zstr (D.44619);
  if (D.44818 == 0)
    goto <bb 166>;
  else
    goto <bb 171>;

<bb 166>:
  D.44471 = smh->mparams;
  D.44821 = D.44471->ndlb;
  D.44822 = D.44821 & 4;
  if (D.44822 == 0)
    goto <bb 167>;
  else
    goto <bb 170>;

<bb 167>:
  D.44530 = session->channel;
  D.44825 = switch_channel_get_variable_dup (D.44530, "rtp_allow_crypto_in_avp", 1, -1);
  D.44826 = switch_true (D.44825);
  if (D.44826 == 0)
    goto <bb 168>;
  else
    goto <bb 170>;

<bb 168>:
  D.44666 = m->m_proto;
  D.44829 = D.44666 != 257;
  D.44830 = got_webrtc == 0;
  D.44831 = D.44829 && D.44830;
  if (D.44831 != 0)
    goto <bb 169>;
  else
    goto <bb 170>;

<bb 169>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3262, session, 3, "a=crypto in RTP/AVP, refer to rfc3711\n");
  match = 0;
  goto <bb 399> (done);

<bb 170>:
  crypto = attr->a_value;
  crypto_tag = atoi (crypto);
  got_crypto = switch_core_session_check_incoming_crypto (session, "rtp_has_crypto", 0, crypto, crypto_tag, sdp_type);

<bb 171>:
  attr = attr->a_next;

<bb 172>:
  if (attr != 0B)
    goto <bb 153>;
  else
    goto <bb 173>;

<bb 173>:
  D.44834 = got_crypto == -1;
  D.44835 = got_savp != 0;
  D.44836 = D.44834 && D.44835;
  if (D.44836 != 0)
    goto <bb 174>;
  else
    goto <bb 176>;

<bb 174>:
  D.44839 = got_avp | got_webrtc;
  if (D.44839 == 0)
    goto <bb 175>;
  else
    goto <bb 176>;

<bb 175>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3277, session, 4, "Declining invite with only SAVP because secure media is administratively disabled\n");
  match = 0;
  goto <bb 399> (done);

<bb 176>:
  connection = sdp->sdp_connection;
  D.44546 = m->m_connections;
  if (D.44546 != 0B)
    goto <bb 177>;
  else
    goto <bb 178>;

<bb 177>:
  connection = m->m_connections;

<bb 178>:
  if (connection == 0B)
    goto <bb 179>;
  else
    goto <bb 180>;

<bb 179>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3288, session, 3, "Cannot find a c= line in the sdp at media or session level!\n");
  match = 0;
  goto <bb 399> (done);

<bb 180>:
  x = 0;
  map = m->m_rtpmaps;
  goto <bb 256>;

<bb 181>:
  map_bit_rate = 0;
  codec_fmtp = {};
  rm_encoding = map->rm_encoding;
  if (rm_encoding == 0B)
    goto <bb 182>;
  else
    goto <bb 183>;

<bb 182>:
  rm_encoding = "";

<bb 183>:
  D.44848 = strcasecmp (rm_encoding, "telephone-event");
  if (D.44848 == 0)
    goto <bb 184>;
  else
    goto <bb 188>;

<bb 184>:
  if (best_te == 0)
    goto <bb 186>;
  else
    goto <bb 185>;

<bb 185>:
  D.44854 = map->rm_rate;
  D.44750 = a_engine->cur_payload_map;
  D.44855 = D.44750->rm_rate;
  if (D.44854 == D.44855)
    goto <bb 186>;
  else
    goto <bb 187>;

<bb 186>:
  D.44856 = map->rm_pt;
  best_te = (switch_payload_t) D.44856;
  D.44857 = (int) best_te;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3309, session, 7, "Set telephone-event payload to %u\n", D.44857);

<bb 187>:
  // predicted unlikely by continue predictor.
  goto <bb 255>;

<bb 188>:
  D.44858 = switch_media_handle_test_media_flag (smh, 9);
  if (D.44858 == 0)
    goto <bb 189>;
  else
    goto <bb 194>;

<bb 189>:
  if (cng_pt == 0)
    goto <bb 190>;
  else
    goto <bb 194>;

<bb 190>:
  D.44863 = strcasecmp (rm_encoding, "CN");
  if (D.44863 == 0)
    goto <bb 191>;
  else
    goto <bb 194>;

<bb 191>:
  D.44856 = map->rm_pt;
  cng_pt = (switch_payload_t) D.44856;
  D.44605 = a_engine->rtp_session;
  if (D.44605 != 0B)
    goto <bb 192>;
  else
    goto <bb 193>;

<bb 192>:
  D.44868 = (int) cng_pt;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3317, session, 7, "Set comfort noise payload to %u\n", D.44868);
  D.44605 = a_engine->rtp_session;
  D.44471 = smh->mparams;
  D.44869 = D.44471->cng_pt;
  switch_rtp_set_cng_pt (D.44605, D.44869);

<bb 193>:
  // predicted unlikely by continue predictor.
  goto <bb 255>;

<bb 194>:
  D.44870 = x < skip;
  x = x + 1;
  if (D.44870 != 0)
    goto <bb 195>;
  else
    goto <bb 196>;

<bb 195>:
  // predicted unlikely by continue predictor.
  goto <bb 255>;

<bb 196>:
  if (match != 0)
    goto <bb 197>;
  else
    goto <bb 198>;

<bb 197>:
  // predicted unlikely by continue predictor.
  goto <bb 255>;

<bb 198>:
  codec_ms = ptime;
  if (maxptime != 0)
    goto <bb 199>;
  else
    goto <bb 201>;

<bb 199>:
  D.44877 = codec_ms == 0;
  D.44878 = codec_ms > maxptime;
  D.44879 = D.44877 || D.44878;
  if (D.44879 != 0)
    goto <bb 200>;
  else
    goto <bb 201>;

<bb 200>:
  codec_ms = maxptime;

<bb 201>:
  if (codec_ms == 0)
    goto <bb 202>;
  else
    goto <bb 203>;

<bb 202>:
  D.44856 = map->rm_pt;
  D.44884 = (uint32_t) D.44856;
  D.44885 = switch_default_ptime (rm_encoding, D.44884);
  codec_ms = (int) D.44885;

<bb 203>:
  D.44856 = map->rm_pt;
  D.44886 = (unsigned char) D.44856;
  map_bit_rate = switch_known_bitrate (D.44886);
  if (ptime == 0)
    goto <bb 204>;
  else
    goto <bb 206>;

<bb 204>:
  D.44889 = map->rm_encoding;
  D.44890 = strcasecmp (D.44889, "g723");
  if (D.44890 == 0)
    goto <bb 205>;
  else
    goto <bb 206>;

<bb 205>:
  codec_ms = 33;

<bb 206>:
  remote_codec_rate = map->rm_rate;
  fmtp_remote_codec_rate = 0;
  memset (&codec_fmtp, 0, 16);
  D.44893 = map->rm_fmtp;
  D.44894 = _zstr (D.44893);
  if (D.44894 != 0)
    goto <bb 207>;
  else
    goto <bb 212>;

<bb 207>:
  D.44889 = map->rm_encoding;
  D.44897 = strcasecmp (D.44889, "ilbc");
  if (D.44897 == 0)
    goto <bb 208>;
  else
    goto <bb 209>;

<bb 208>:
  codec_ms = 32;
  map_bit_rate = 13332;
  goto <bb 219>;

<bb 209>:
  D.44889 = map->rm_encoding;
  D.44901 = strcasecmp (D.44889, "isac");
  if (D.44901 == 0)
    goto <bb 210>;
  else
    goto <bb 211>;

<bb 210>:
  codec_ms = 39;
  map_bit_rate = 32001;
  goto <bb 219>;

<bb 211>:
  map_bit_rate = 32099;
  goto <bb 219>;

<bb 212>:
  D.44889 = map->rm_encoding;
  D.44893 = map->rm_fmtp;
  D.44854 = map->rm_rate;
  D.44906 = switch_core_codec_parse_fmtp (D.44889, D.44893, D.44854, &codec_fmtp);
  if (D.44906 == 0)
    goto <bb 213>;
  else
    goto <bb 219>;

<bb 213>:
  D.44909 = codec_fmtp.bits_per_second;
  if (D.44909 != 0)
    goto <bb 214>;
  else
    goto <bb 215>;

<bb 214>:
  D.44909 = codec_fmtp.bits_per_second;
  map_bit_rate = (uint32_t) D.44909;

<bb 215>:
  D.44912 = codec_fmtp.microseconds_per_packet;
  if (D.44912 != 0)
    goto <bb 216>;
  else
    goto <bb 217>;

<bb 216>:
  D.44912 = codec_fmtp.microseconds_per_packet;
  codec_ms = D.44912 / 1000;

<bb 217>:
  D.44915 = codec_fmtp.actual_samples_per_second;
  if (D.44915 != 0)
    goto <bb 218>;
  else
    goto <bb 219>;

<bb 218>:
  fmtp_remote_codec_rate = codec_fmtp.actual_samples_per_second;

<bb 219>:
  i = 0;
  goto <bb 253>;

<bb 220>:
  i.91 = (unsigned int) i;
  D.44919 = i.91 * 4;
  D.44920 = codec_array + D.44919;
  imp = *D.44920;
  D.44921 = imp->bits_per_second;
  bit_rate = (uint32_t) D.44921;
  codec_rate = imp->samples_per_second;
  D.44922 = imp->codec_type;
  if (D.44922 != 0)
    goto <bb 221>;
  else
    goto <bb 222>;

<bb 221>:
  // predicted unlikely by continue predictor.
  goto <bb 252>;

<bb 222>:
  D.44856 = map->rm_pt;
  D.44925 = (int) D.44856;
  remote_codec_rate.92 = (int) remote_codec_rate;
  D.44927 = imp->iananame;
  D.44928 = imp->ianacode;
  D.44929 = (int) D.44928;
  D.44930 = imp->microseconds_per_packet;
  D.44931 = D.44930 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3383, session, 7, "Audio Codec Compare [%s:%d:%u:%d:%u]/[%s:%d:%u:%d:%u]\n", rm_encoding, D.44925, remote_codec_rate.92, codec_ms, map_bit_rate, D.44927, D.44929, codec_rate, D.44931, bit_rate);
  D.44889 = map->rm_encoding;
  D.44935 = _zstr (D.44889);
  if (D.44935 != 0)
    goto <bb 224>;
  else
    goto <bb 223>;

<bb 223>:
  D.44471 = smh->mparams;
  D.44821 = D.44471->ndlb;
  D.44937 = (int) D.44821;
  D.44938 = D.44937 & 1;
  D.44939 = (_Bool) D.44938;
  if (D.44939 != 0)
    goto <bb 224>;
  else
    goto <bb 226>;

<bb 224>:
  D.44856 = map->rm_pt;
  D.44925 = (int) D.44856;
  if (D.44925 <= 95)
    goto <bb 225>;
  else
    goto <bb 226>;

<bb 225>:
  D.44856 = map->rm_pt;
  D.44925 = (int) D.44856;
  D.44928 = imp->ianacode;
  D.44929 = (int) D.44928;
  match = D.44925 == D.44929;
  goto <bb 233>;

<bb 226>:
  D.44927 = imp->iananame;
  D.44945 = strcasecmp (rm_encoding, D.44927);
  if (D.44945 == 0)
    goto <bb 227>;
  else
    goto <bb 230>;

<bb 227>:
  if (remote_codec_rate == codec_rate)
    goto <bb 229>;
  else
    goto <bb 228>;

<bb 228>:
  D.44948 = imp->actual_samples_per_second;
  if (D.44948 == fmtp_remote_codec_rate)
    goto <bb 229>;
  else
    goto <bb 230>;

<bb 229>:
  iftmp.93 = 1;
  goto <bb 231>;

<bb 230>:
  iftmp.93 = 0;

<bb 231>:
  match = (uint8_t) iftmp.93;
  if (fmtp_remote_codec_rate != 0)
    goto <bb 232>;
  else
    goto <bb 233>;

<bb 232>:
  remote_codec_rate = fmtp_remote_codec_rate;

<bb 233>:
  D.44951 = match != 0;
  D.44952 = bit_rate != 0;
  D.44953 = D.44951 && D.44952;
  if (D.44953 != 0)
    goto <bb 234>;
  else
    goto <bb 238>;

<bb 234>:
  D.44956 = map_bit_rate != 0;
  D.44957 = map_bit_rate != bit_rate;
  D.44958 = D.44956 && D.44957;
  if (D.44958 != 0)
    goto <bb 235>;
  else
    goto <bb 238>;

<bb 235>:
  D.44889 = map->rm_encoding;
  D.44961 = strcasecmp (D.44889, "ilbc");
  if (D.44961 != 0)
    goto <bb 236>;
  else
    goto <bb 238>;

<bb 236>:
  D.44889 = map->rm_encoding;
  D.44964 = strcasecmp (D.44889, "isac");
  if (D.44964 != 0)
    goto <bb 237>;
  else
    goto <bb 238>;

<bb 237>:
  match = 0;

<bb 238>:
  D.44951 = match != 0;
  D.44969 = remote_codec_rate != 0;
  D.44970 = D.44951 && D.44969;
  if (D.44970 != 0)
    goto <bb 239>;
  else
    goto <bb 243>;

<bb 239>:
  D.44973 = codec_rate != 0;
  D.44974 = remote_codec_rate != codec_rate;
  D.44975 = D.44973 && D.44974;
  if (D.44975 != 0)
    goto <bb 240>;
  else
    goto <bb 243>;

<bb 240>:
  D.44889 = map->rm_encoding;
  D.44978 = strcasecmp (D.44889, "pcma");
  if (D.44978 == 0)
    goto <bb 242>;
  else
    goto <bb 241>;

<bb 241>:
  D.44889 = map->rm_encoding;
  D.44980 = strcasecmp (D.44889, "pcmu");
  if (D.44980 == 0)
    goto <bb 242>;
  else
    goto <bb 243>;

<bb 242>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3405, session, 7, "sampling rates have to match for G.711\n");
  match = 0;

<bb 243>:
  if (match != 0)
    goto <bb 244>;
  else
    goto <bb 252>;

<bb 244>:
  if (scrooge != 0)
    goto <bb 245>;
  else
    goto <bb 246>;

<bb 245>:
  D.44927 = imp->iananame;
  D.44985 = imp->samples_per_second;
  D.44930 = imp->microseconds_per_packet;
  D.44931 = D.44930 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3411, session, 7, "Bah HUMBUG! Sticking with %s@%uh@%ui\n", D.44927, D.44985, D.44931);
  goto <bb 250>;

<bb 246>:
  D.44990 = ptime != 0;
  D.44991 = codec_ms != 0;
  D.44992 = D.44990 && D.44991;
  if (D.44992 != 0)
    goto <bb 247>;
  else
    goto <bb 248>;

<bb 247>:
  D.44994 = codec_ms * 1000;
  D.44930 = imp->microseconds_per_packet;
  if (D.44994 != D.44930)
    goto <bb 249>;
  else
    goto <bb 248>;

<bb 248>:
  if (remote_codec_rate != codec_rate)
    goto <bb 249>;
  else
    goto <bb 250>;

<bb 249>:
  match = 0;
  D.44927 = imp->iananame;
  D.44928 = imp->ianacode;
  D.44929 = (int) D.44928;
  D.44930 = imp->microseconds_per_packet;
  D.44931 = D.44930 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3418, session, 7, "Audio Codec Compare [%s:%d:%u:%d:%u] is saved as a near-match\n", D.44927, D.44929, codec_rate, D.44931, bit_rate);
  near_matches[nm_idx].codec_idx = i;
  remote_codec_rate.92 = (int) remote_codec_rate;
  near_matches[nm_idx].rate = remote_codec_rate.92;
  near_matches[nm_idx].imp = imp;
  near_matches[nm_idx].map = map;
  nm_idx = nm_idx + 1;
  // predicted unlikely by continue predictor.
  goto <bb 252>;

<bb 250>:
  matches[m_idx].codec_idx = i;
  codec_rate.94 = (int) codec_rate;
  matches[m_idx].rate = codec_rate.94;
  matches[m_idx].imp = imp;
  matches[m_idx].map = map;
  m_idx = m_idx + 1;
  D.44927 = imp->iananame;
  D.44928 = imp->ianacode;
  D.44929 = (int) D.44928;
  D.44930 = imp->microseconds_per_packet;
  D.44931 = D.44930 / 1000;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3437, session, 7, "Audio Codec Compare [%s:%d:%u:%d:%u] ++++ is saved as a match\n", D.44927, D.44929, codec_rate, D.44931, bit_rate);
  if (m_idx > 29)
    goto <bb 254>;
  else
    goto <bb 251>;

<bb 251>:
  match = 0;

<bb 252>:
  i = i + 1;

<bb 253>:
  D.44471 = smh->mparams;
  D.44997 = D.44471->num_codecs;
  D.44998 = D.44997 > i;
  D.44999 = i < total_codecs;
  D.45000 = D.44998 && D.44999;
  if (D.45000 != 0)
    goto <bb 220>;
  else
    goto <bb 254>;

<bb 254>:
  if (m_idx > 29)
    goto <bb 257>;
  else
    goto <bb 255>;

<bb 255>:
  map = map->rm_next;

<bb 256>:
  if (map != 0B)
    goto <bb 181>;
  else
    goto <bb 257>;

<bb 257>:
  D.45002 = smh->crypto_mode;
  D.45003 = D.45002 == 1;
  D.45004 = got_crypto <= 0;
  D.45005 = D.45003 && D.45004;
  if (D.45005 != 0)
    goto <bb 258>;
  else
    goto <bb 259>;

<bb 258>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3455, session, 4, "Crypto not negotiated but required.\n");
  match = 0;
  nm_idx = 0;
  m_idx = nm_idx;

<bb 259>:
  D.45008 = m_idx == 0;
  D.45009 = nm_idx != 0;
  D.45010 = D.45008 && D.45009;
  if (D.45010 != 0)
    goto <bb 260>;
  else
    goto <bb 272>;

<bb 260>:
  j = 0;
  goto <bb 271>;

<bb 261>:
  timp = 0B;
  D.45013 = near_matches[j].rate;
  near_rate = (uint32_t) D.45013;
  near_match = near_matches[j].imp;
  near_map = near_matches[j].map;
  D.45014 = near_match->iananame;
  if (near_rate == 0)
    goto <bb 262>;
  else
    goto <bb 263>;

<bb 262>:
  iftmp.95 = near_match->samples_per_second;
  goto <bb 264>;

<bb 263>:
  iftmp.95 = near_rate;

<bb 264>:
  switch_snprintf (&tmp, 80, "%s@%uh@%ui", D.45014, iftmp.95, codec_ms);
  prefs[0] = &tmp;
  num = switch_loadable_module_get_codecs_sorted (&search, 1, &prefs, 1);
  if (num != 0)
    goto <bb 265>;
  else
    goto <bb 266>;

<bb 265>:
  timp = search[0];
  goto <bb 267>;

<bb 266>:
  timp = near_match;

<bb 267>:
  if (maxptime == 0)
    goto <bb 269>;
  else
    goto <bb 268>;

<bb 268>:
  D.45025 = timp->microseconds_per_packet;
  D.45026 = D.45025 / 1000;
  if (D.45026 <= maxptime)
    goto <bb 269>;
  else
    goto <bb 270>;

<bb 269>:
  D.45027 = timp->iananame;
  D.45025 = timp->microseconds_per_packet;
  D.45026 = D.45025 / 1000;
  D.45028 = timp->actual_samples_per_second;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3488, session, 7, "Substituting codec %s@%ui@%uh\n", D.45027, D.45026, D.45028);
  match = 1;
  D.45029 = near_matches[j].codec_idx;
  matches[m_idx].codec_idx = D.45029;
  near_rate.96 = (int) near_rate;
  matches[m_idx].rate = near_rate.96;
  matches[m_idx].imp = timp;
  matches[m_idx].map = near_map;
  m_idx = m_idx + 1;
  goto <bb 272>;

<bb 270>:
  j = j + 1;

<bb 271>:
  if (j < nm_idx)
    goto <bb 261>;
  else
    goto <bb 272>;

<bb 272>:
  if (m_idx != 0)
    goto <bb 273>;
  else
    goto <bb 295>;

<bb 273>:
  if (greedy != 0)
    goto <bb 274>;
  else
    goto <bb 275>;

<bb 274>:
  greedy_sort (smh, &matches, m_idx, codec_array, total_codecs);

<bb 275>:
  match = 1;
  a_engine->codec_negotiated = 1;
  smh->num_negotiated_codecs = 0;
  j = 0;
  goto <bb 294>;

<bb 276>:
  D.45035 = matches[j].map;
  D.45036 = D.45035->rm_encoding;
  D.45035 = matches[j].map;
  D.45037 = D.45035->rm_fmtp;
  D.45035 = matches[j].map;
  D.45038 = D.45035->rm_pt;
  D.45039 = (uint32_t) D.45038;
  D.45040 = matches[j].imp;
  D.45041 = D.45040->samples_per_second;
  D.45040 = matches[j].imp;
  D.45042 = D.45040->microseconds_per_packet;
  D.45043 = D.45042 / 1000;
  D.45044 = (uint32_t) D.45043;
  pmap = switch_core_media_add_payload_map (session, 0, D.45036, D.45037, sdp_type, D.45039, D.45041, D.45044, 1);
  mimp = matches[j].imp;
  mmap = matches[j].map;
  if (j == 0)
    goto <bb 277>;
  else
    goto <bb 279>;

<bb 277>:
  a_engine->cur_payload_map = pmap;
  D.44750 = a_engine->cur_payload_map;
  D.44750->current = 1;
  D.44605 = a_engine->rtp_session;
  if (D.44605 != 0B)
    goto <bb 278>;
  else
    goto <bb 279>;

<bb 278>:
  D.44605 = a_engine->rtp_session;
  D.45049 = pmap->pt;
  switch_rtp_set_default_payload (D.44605, D.45049);

<bb 279>:
  D.45050 = mmap->rm_encoding;
  D.45051 = switch_core_perform_session_strdup (session, D.45050, "src/switch_core_media.c", &__func__, 3535);
  pmap->rm_encoding = D.45051;
  D.45052 = mimp->iananame;
  D.45053 = switch_core_perform_session_strdup (session, D.45052, "src/switch_core_media.c", &__func__, 3536);
  pmap->iananame = D.45053;
  D.45054 = mmap->rm_pt;
  D.45055 = (unsigned char) D.45054;
  pmap->recv_pt = D.45055;
  D.45056 = mimp->samples_per_second;
  pmap->rm_rate = D.45056;
  D.45056 = mimp->samples_per_second;
  pmap->adv_rm_rate = D.45056;
  D.45052 = mimp->iananame;
  D.45057 = strcasecmp (D.45052, "g722");
  if (D.45057 != 0)
    goto <bb 280>;
  else
    goto <bb 281>;

<bb 280>:
  D.45060 = mimp->actual_samples_per_second;
  pmap->rm_rate = D.45060;

<bb 281>:
  D.45061 = mimp->microseconds_per_packet;
  D.45062 = D.45061 / 1000;
  D.45063 = (uint32_t) D.45062;
  pmap->codec_ms = D.45063;
  D.45064 = mimp->bits_per_second;
  D.45065 = (uint32_t) D.45064;
  pmap->bitrate = D.45065;
  D.45067 = mmap->rm_params;
  if (D.45067 != 0B)
    goto <bb 282>;
  else
    goto <bb 283>;

<bb 282>:
  D.45067 = mmap->rm_params;
  iftmp.97 = atoi (D.45067);
  goto <bb 284>;

<bb 283>:
  iftmp.97 = 1;

<bb 284>:
  pmap->channels = iftmp.97;
  D.45050 = mmap->rm_encoding;
  D.45071 = strcasecmp (D.45050, "opus");
  if (D.45071 == 0)
    goto <bb 285>;
  else
    goto <bb 292>;

<bb 285>:
  D.45074 = pmap->channels;
  if (D.45074 == 1)
    goto <bb 286>;
  else
    goto <bb 287>;

<bb 286>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3549, session, 4, "Invalid SDP for opus.  Don\'t ask.. but it needs a /2\n");
  pmap->adv_channels = 1;
  goto <bb 288>;

<bb 287>:
  pmap->adv_channels = 2;

<bb 288>:
  D.45080 = mmap->rm_fmtp;
  D.45081 = _zstr (D.45080);
  if (D.45081 == 0)
    goto <bb 289>;
  else
    goto <bb 291>;

<bb 289>:
  D.45080 = mmap->rm_fmtp;
  D.45083 = switch_stristr ("stereo=1", D.45080);
  if (D.45083 != 0B)
    goto <bb 290>;
  else
    goto <bb 291>;

<bb 290>:
  pmap->channels = 2;
  goto <bb 293>;

<bb 291>:
  pmap->channels = 1;
  goto <bb 293>;

<bb 292>:
  D.45074 = pmap->channels;
  pmap->adv_channels = D.45074;

<bb 293>:
  D.45086 = connection->c_address;
  D.45087 = switch_core_perform_session_strdup (session, D.45086, "src/switch_core_media.c", &__func__, 3563);
  pmap->remote_sdp_ip = D.45087;
  D.44697 = m->m_port;
  D.45088 = (short unsigned int) D.44697;
  pmap->remote_sdp_port = D.45088;
  D.45080 = mmap->rm_fmtp;
  D.45089 = switch_core_perform_session_strdup (session, D.45080, "src/switch_core_media.c", &__func__, 3565);
  pmap->rm_fmtp = D.45089;
  D.45054 = mmap->rm_pt;
  D.45055 = (unsigned char) D.45054;
  pmap->agreed_pt = D.45055;
  D.44655 = smh->num_negotiated_codecs;
  smh->negotiated_codecs[D.44655] = mimp;
  D.45090 = D.44655 + 1;
  smh->num_negotiated_codecs = D.45090;
  D.45054 = mmap->rm_pt;
  D.45055 = (unsigned char) D.45054;
  pmap->recv_pt = D.45055;
  j = j + 1;

<bb 294>:
  if (j < m_idx)
    goto <bb 276>;
  else
    goto <bb 295>;

<bb 295>:
  if (match != 0)
    goto <bb 296>;
  else
    goto <bb 301>;

<bb 296>:
  D.44750 = a_engine->cur_payload_map;
  D.44762 = D.44750->remote_sdp_port;
  D.44767 = (int) D.44762;
  switch_snprintf (&tmp, 50, "%d", D.44767);
  D.44530 = session->channel;
  D.44750 = a_engine->cur_payload_map;
  D.44760 = D.44750->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.44530, "remote_media_ip", D.44760, 1);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "remote_media_port", &tmp, 1);
  D.44750 = a_engine->cur_payload_map;
  D.45093 = D.44750->recv_pt;
  D.45094 = (int) D.45093;
  switch_snprintf (&tmp, 50, "%d", D.45094);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "rtp_audio_recv_pt", &tmp, 1);
  D.45095 = &a_engine->read_codec;
  D.45096 = switch_core_codec_ready (D.45095);
  if (D.45096 != 0)
    goto <bb 297>;
  else
    goto <bb 298>;

<bb 297>:
  a_engine->reset_codec = 1;

<bb 298>:
  D.44471 = smh->mparams;
  D.45099 = D.44471->codec_flags;
  D.45100 = switch_core_media_set_codec (session, 0, D.45099);
  if (D.45100 == 0)
    goto <bb 299>;
  else
    goto <bb 300>;

<bb 299>:
  got_audio = 1;
  check_ice (smh, 0, sdp, m);
  goto <bb 301>;

<bb 300>:
  match = 0;

<bb 301>:
  if (best_te == 0)
    goto <bb 302>;
  else
    goto <bb 305>;

<bb 302>:
  D.45108 = switch_media_handle_test_media_flag (smh, 8);
  if (D.45108 != 0)
    goto <bb 304>;
  else
    goto <bb 303>;

<bb 303>:
  D.44530 = session->channel;
  D.45110 = switch_channel_test_flag (D.44530, 93);
  if (D.45110 != 0)
    goto <bb 304>;
  else
    goto <bb 305>;

<bb 304>:
  D.44471 = smh->mparams;
  D.45111 = D.44471->te;
  D.45112 = (int) D.45111;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3609, session, 7, "No 2833 in SDP. Liberal DTMF mode adding %d as telephone-event.\n", D.45112);
  D.44471 = smh->mparams;
  best_te = D.44471->te;

<bb 305>:
  if (best_te != 0)
    goto <bb 306>;
  else
    goto <bb 311>;

<bb 306>:
  D.45115 = switch_channel_direction (channel);
  if (D.45115 == 1)
    goto <bb 307>;
  else
    goto <bb 309>;

<bb 307>:
  D.44471 = smh->mparams;
  D.44471->te = best_te;
  te = D.44471->te;
  D.44857 = (int) best_te;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3617, session, 7, "Set 2833 dtmf send payload to %u\n", D.44857);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "dtmf_type", "rfc2833", 1);
  D.44471 = smh->mparams;
  D.44471->dtmf_type = 0;
  D.44605 = a_engine->rtp_session;
  if (D.44605 != 0B)
    goto <bb 308>;
  else
    goto <bb 397>;

<bb 308>:
  D.44605 = a_engine->rtp_session;
  switch_rtp_set_telephony_event (D.44605, best_te);
  D.44530 = session->channel;
  D.44857 = (int) best_te;
  switch_channel_set_variable_printf (D.44530, "rtp_2833_send_payload", "%d", D.44857);
  goto <bb 397>;

<bb 309>:
  D.44471 = smh->mparams;
  D.44471 = smh->mparams;
  D.44471->te = best_te;
  D.45111 = D.44471->te;
  D.44471->recv_te = D.45111;
  te = D.44471->recv_te;
  D.45121 = (int) te;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3626, session, 7, "Set 2833 dtmf send/recv payload to %u\n", D.45121);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "dtmf_type", "rfc2833", 1);
  D.44471 = smh->mparams;
  D.44471->dtmf_type = 0;
  D.44605 = a_engine->rtp_session;
  if (D.44605 != 0B)
    goto <bb 310>;
  else
    goto <bb 397>;

<bb 310>:
  D.44605 = a_engine->rtp_session;
  switch_rtp_set_telephony_event (D.44605, te);
  D.44530 = session->channel;
  D.45121 = (int) te;
  switch_channel_set_variable_printf (D.44530, "rtp_2833_send_payload", "%d", D.45121);
  D.44605 = a_engine->rtp_session;
  switch_rtp_set_telephony_recv_event (D.44605, te);
  D.44530 = session->channel;
  D.45121 = (int) te;
  switch_channel_set_variable_printf (D.44530, "rtp_2833_recv_payload", "%d", D.45121);
  goto <bb 397>;

<bb 311>:
  D.45125 = switch_channel_get_variable_dup (channel, "rtp_info_when_no_2833", 1, -1);
  D.45126 = switch_false (D.45125);
  if (D.45126 == 0)
    goto <bb 312>;
  else
    goto <bb 313>;

<bb 312>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3639, session, 7, "No 2833 in SDP.  Disable 2833 dtmf and switch to INFO\n");
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "dtmf_type", "info", 1);
  D.44471 = smh->mparams;
  D.44471->dtmf_type = 1;
  D.44471 = smh->mparams;
  D.44471 = smh->mparams;
  D.44471->te = 0;
  D.45111 = D.44471->te;
  D.44471->recv_te = D.45111;
  te = D.44471->recv_te;
  goto <bb 397>;

<bb 313>:
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "dtmf_type", "none", 1);
  D.44471 = smh->mparams;
  D.44471->dtmf_type = 2;
  D.44471 = smh->mparams;
  D.44471 = smh->mparams;
  D.44471->te = 0;
  D.45111 = D.44471->te;
  D.44471->recv_te = D.45111;
  te = D.44471->recv_te;
  goto <bb 397>;

<bb 314>:
  D.44681 = m->m_type;
  if (D.44681 == 3)
    goto <bb 315>;
  else
    goto <bb 397>;

<bb 315>:
  D.44697 = m->m_port;
  if (D.44697 != 0)
    goto <bb 316>;
  else
    goto <bb 397>;

<bb 316>:
  mimp = 0B;
  vmatch = 0;
  nm_idx = 0;
  m_idx = 0;
  memset (&matches, 0, 480);
  memset (&near_matches, 0, 480);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "video_possible", "true", 1);
  connection = sdp->sdp_connection;
  D.44546 = m->m_connections;
  if (D.44546 != 0B)
    goto <bb 317>;
  else
    goto <bb 318>;

<bb 317>:
  connection = m->m_connections;

<bb 318>:
  if (connection == 0B)
    goto <bb 319>;
  else
    goto <bb 320>;

<bb 319>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3669, session, 3, "Cannot find a c= line in the sdp at media or session level!\n");
  match = 0;
  goto <bb 399> (done);

<bb 320>:
  map = m->m_rtpmaps;
  goto <bb 379>;

<bb 321>:
  D.45138 = switch_rtp_has_dtls ();
  if (D.45138 != 0)
    goto <bb 322>;
  else
    goto <bb 329>;

<bb 322>:
  D.45141 = dtls_ok (session);
  if (D.45141 != 0)
    goto <bb 323>;
  else
    goto <bb 329>;

<bb 323>:
  attr = m->m_attributes;
  goto <bb 328>;

<bb 324>:
  D.44590 = attr->a_name;
  D.45144 = strcasecmp (D.44590, "fingerprint");
  if (D.45144 == 0)
    goto <bb 325>;
  else
    goto <bb 327>;

<bb 325>:
  D.44619 = attr->a_value;
  D.45147 = _zstr (D.44619);
  if (D.45147 == 0)
    goto <bb 326>;
  else
    goto <bb 327>;

<bb 326>:
  got_video_crypto = 1;

<bb 327>:
  attr = attr->a_next;

<bb 328>:
  if (attr != 0B)
    goto <bb 324>;
  else
    goto <bb 329>;

<bb 329>:
  attr = m->m_attributes;
  goto <bb 358>;

<bb 330>:
  D.44590 = attr->a_name;
  D.45152 = strcasecmp (D.44590, "framerate");
  if (D.45152 == 0)
    goto <bb 331>;
  else
    goto <bb 332>;

<bb 331>:
  D.44619 = attr->a_value;
  if (D.44619 != 0B)
    goto <bb 357>;
  else
    goto <bb 332>;

<bb 332>:
  D.44590 = attr->a_name;
  D.45155 = strcasecmp (D.44590, "rtcp-fb");
  if (D.45155 == 0)
    goto <bb 333>;
  else
    goto <bb 337>;

<bb 333>:
  D.44619 = attr->a_value;
  D.45158 = _zstr (D.44619);
  if (D.45158 == 0)
    goto <bb 334>;
  else
    goto <bb 357>;

<bb 334>:
  D.44619 = attr->a_value;
  D.45161 = switch_stristr ("fir", D.44619);
  if (D.45161 != 0B)
    goto <bb 335>;
  else
    goto <bb 336>;

<bb 335>:
  D.45164 = v_engine->fir;
  D.45165 = D.45164 + 1;
  v_engine->fir = D.45165;

<bb 336>:
  D.44471 = smh->mparams;
  D.44471->rtcp_video_interval_msec = "10000";
  goto <bb 357>;

<bb 337>:
  D.44590 = attr->a_name;
  D.45169 = strcasecmp (D.44590, "rtcp");
  if (D.45169 == 0)
    goto <bb 338>;
  else
    goto <bb 349>;

<bb 338>:
  D.44619 = attr->a_value;
  if (D.44619 != 0B)
    goto <bb 339>;
  else
    goto <bb 349>;

<bb 339>:
  __s2_len = 1;
  if (__s2_len <= 3)
    goto <bb 340>;
  else
    goto <bb 345>;

<bb 340>:
  __s1 = attr->a_value;
  D.45175 = *__s1;
  D.45176 = (int) D.45175;
  D.45177 = "1";
  D.45178 = MEM[(const unsigned char *)D.45177];
  D.45179 = (int) D.45178;
  __result = D.45176 - D.45179;
  D.45180 = __s2_len != 0;
  D.45181 = __result == 0;
  D.45182 = D.45180 && D.45181;
  if (D.45182 != 0)
    goto <bb 341>;
  else
    goto <bb 344>;

<bb 341>:
  D.45185 = __s1 + 1;
  D.45186 = *D.45185;
  D.45187 = (int) D.45186;
  D.45188 = &"1"[1];
  D.45189 = MEM[(const unsigned char *)D.45188];
  D.45190 = (int) D.45189;
  __result = D.45187 - D.45190;
  D.45191 = __s2_len > 1;
  D.45181 = __result == 0;
  D.45192 = D.45191 && D.45181;
  if (D.45192 != 0)
    goto <bb 342>;
  else
    goto <bb 344>;

<bb 342>:
  D.45195 = __s1 + 2;
  D.45196 = *D.45195;
  D.45197 = (int) D.45196;
  D.45198 = &"1"[2];
  D.45199 = MEM[(const unsigned char *)D.45198];
  D.45200 = (int) D.45199;
  __result = D.45197 - D.45200;
  D.45201 = __s2_len > 2;
  D.45181 = __result == 0;
  D.45202 = D.45201 && D.45181;
  if (D.45202 != 0)
    goto <bb 343>;
  else
    goto <bb 344>;

<bb 343>:
  D.45205 = __s1 + 3;
  D.45206 = *D.45205;
  D.45207 = (int) D.45206;
  D.45208 = &"1"[3];
  D.45209 = MEM[(const unsigned char *)D.45208];
  D.45210 = (int) D.45209;
  __result = D.45207 - D.45210;

<bb 344>:
  D.39088 = __result;
  iftmp.98 = D.39088;
  goto <bb 346>;

<bb 345>:
  D.44619 = attr->a_value;
  iftmp.98 = __builtin_strcmp (D.44619, "1");

<bb 346>:
  D.39089 = iftmp.98;
  if (D.39089 == 0)
    goto <bb 347>;
  else
    goto <bb 349>;

<bb 347>:
  D.44530 = session->channel;
  D.44619 = attr->a_value;
  switch_channel_set_variable_var_check (D.44530, "rtp_remote_video_rtcp_port", D.44619, 1);
  D.44619 = attr->a_value;
  D.45213 = atoi (D.44619);
  D.45214 = (short unsigned int) D.45213;
  v_engine->remote_rtcp_port = D.45214;
  D.44471 = smh->mparams;
  D.45215 = D.44471->rtcp_video_interval_msec;
  if (D.45215 == 0B)
    goto <bb 348>;
  else
    goto <bb 357>;

<bb 348>:
  D.44471 = smh->mparams;
  D.44471->rtcp_video_interval_msec = "5000";
  goto <bb 357>;

<bb 349>:
  if (got_video_crypto == 0)
    goto <bb 350>;
  else
    goto <bb 357>;

<bb 350>:
  D.44590 = attr->a_name;
  D.45220 = strcasecmp (D.44590, "crypto");
  if (D.45220 == 0)
    goto <bb 351>;
  else
    goto <bb 357>;

<bb 351>:
  D.44619 = attr->a_value;
  D.45223 = _zstr (D.44619);
  if (D.45223 == 0)
    goto <bb 352>;
  else
    goto <bb 357>;

<bb 352>:
  D.44471 = smh->mparams;
  D.44821 = D.44471->ndlb;
  D.44822 = D.44821 & 4;
  if (D.44822 == 0)
    goto <bb 353>;
  else
    goto <bb 356>;

<bb 353>:
  D.44530 = session->channel;
  D.45228 = switch_channel_get_variable_dup (D.44530, "rtp_allow_crypto_in_avp", 1, -1);
  D.45229 = switch_true (D.45228);
  if (D.45229 == 0)
    goto <bb 354>;
  else
    goto <bb 356>;

<bb 354>:
  D.44666 = m->m_proto;
  D.44829 = D.44666 != 257;
  D.44830 = got_webrtc == 0;
  D.44831 = D.44829 && D.44830;
  if (D.44831 != 0)
    goto <bb 355>;
  else
    goto <bb 356>;

<bb 355>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3711, session, 3, "a=crypto in RTP/AVP, refer to rfc3711\n");
  match = 0;
  goto <bb 399> (done);

<bb 356>:
  crypto = attr->a_value;
  crypto_tag = atoi (crypto);
  got_video_crypto = switch_core_session_check_incoming_crypto (session, "rtp_has_video_crypto", 1, crypto, crypto_tag, sdp_type);

<bb 357>:
  attr = attr->a_next;

<bb 358>:
  if (attr != 0B)
    goto <bb 330>;
  else
    goto <bb 359>;

<bb 359>:
  rm_encoding = map->rm_encoding;
  if (rm_encoding == 0B)
    goto <bb 360>;
  else
    goto <bb 361>;

<bb 360>:
  rm_encoding = "";

<bb 361>:
  i = 0;
  goto <bb 377>;

<bb 362>:
  i.99 = (unsigned int) i;
  D.45237 = i.99 * 4;
  D.45238 = codec_array + D.45237;
  imp = *D.45238;
  D.45239 = imp->codec_type;
  if (D.45239 != 1)
    goto <bb 363>;
  else
    goto <bb 364>;

<bb 363>:
  // predicted unlikely by continue predictor.
  goto <bb 376>;

<bb 364>:
  D.44530 = session->channel;
  D.45242 = switch_channel_direction (D.44530);
  if (D.45242 == 0)
    goto <bb 365>;
  else
    goto <bb 367>;

<bb 365>:
  D.44530 = session->channel;
  D.45245 = switch_channel_test_flag (D.44530, 114);
  if (D.45245 != 0)
    goto <bb 366>;
  else
    goto <bb 367>;

<bb 366>:
  // predicted unlikely by continue predictor.
  goto <bb 376>;

<bb 367>:
  D.45248 = map->rm_pt;
  D.45249 = (int) D.45248;
  D.45250 = imp->iananame;
  D.45251 = imp->ianacode;
  D.45252 = (int) D.45251;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3743, session, 7, "Video Codec Compare [%s:%d]/[%s:%d]\n", rm_encoding, D.45249, D.45250, D.45252);
  D.45256 = map->rm_encoding;
  D.45257 = _zstr (D.45256);
  if (D.45257 != 0)
    goto <bb 369>;
  else
    goto <bb 368>;

<bb 368>:
  D.44471 = smh->mparams;
  D.44821 = D.44471->ndlb;
  D.44937 = (int) D.44821;
  D.44938 = D.44937 & 1;
  D.44939 = (_Bool) D.44938;
  if (D.44939 != 0)
    goto <bb 369>;
  else
    goto <bb 371>;

<bb 369>:
  D.45248 = map->rm_pt;
  D.45249 = (int) D.45248;
  if (D.45249 <= 95)
    goto <bb 370>;
  else
    goto <bb 371>;

<bb 370>:
  D.45248 = map->rm_pt;
  D.45249 = (int) D.45248;
  D.45251 = imp->ianacode;
  D.45252 = (int) D.45251;
  vmatch = D.45249 == D.45252;
  goto <bb 372>;

<bb 371>:
  D.45250 = imp->iananame;
  D.45260 = strcasecmp (rm_encoding, D.45250);
  vmatch = D.45260 == 0;

<bb 372>:
  if (vmatch != 0)
    goto <bb 373>;
  else
    goto <bb 375>;

<bb 373>:
  D.45263 = map->rm_rate;
  D.45264 = imp->samples_per_second;
  if (D.45263 == D.45264)
    goto <bb 374>;
  else
    goto <bb 375>;

<bb 374>:
  matches[m_idx].imp = imp;
  matches[m_idx].map = map;
  D.45250 = imp->iananame;
  D.45251 = imp->ianacode;
  D.45252 = (int) D.45251;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3756, session, 7, "Video Codec Compare [%s:%d] +++ is saved as a match\n", D.45250, D.45252);
  m_idx = m_idx + 1;

<bb 375>:
  vmatch = 0;

<bb 376>:
  i = i + 1;

<bb 377>:
  if (i < total_codecs)
    goto <bb 362>;
  else
    goto <bb 378>;

<bb 378>:
  map = map->rm_next;

<bb 379>:
  if (map != 0B)
    goto <bb 321>;
  else
    goto <bb 380>;

<bb 380>:
  D.45002 = smh->crypto_mode;
  D.45003 = D.45002 == 1;
  D.45267 = got_video_crypto <= 0;
  D.45268 = D.45003 && D.45267;
  if (D.45268 != 0)
    goto <bb 381>;
  else
    goto <bb 382>;

<bb 381>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 3766, session, 4, "Crypto not negotiated but required.\n");
  vmatch = 0;
  m_idx = 0;

<bb 382>:
  if (m_idx != 0)
    goto <bb 383>;
  else
    goto <bb 397>;

<bb 383>:
  j = 0;
  if (greedy != 0)
    goto <bb 384>;
  else
    goto <bb 385>;

<bb 384>:
  greedy_sort (smh, &matches, m_idx, codec_array, total_codecs);

<bb 385>:
  vmatch = 1;
  v_engine->codec_negotiated = 1;
  j = 0;
  goto <bb 390>;

<bb 386>:
  D.45275 = matches[j].map;
  D.45276 = D.45275->rm_encoding;
  D.45275 = matches[j].map;
  D.45277 = D.45275->rm_fmtp;
  D.45275 = matches[j].map;
  D.45278 = D.45275->rm_pt;
  D.45279 = (uint32_t) D.45278;
  D.45280 = matches[j].imp;
  D.45281 = D.45280->samples_per_second;
  D.45280 = matches[j].imp;
  D.45282 = D.45280->microseconds_per_packet;
  D.45283 = D.45282 / 1000;
  D.45284 = (uint32_t) D.45283;
  pmap = switch_core_media_add_payload_map (session, 1, D.45276, D.45277, sdp_type, D.45279, D.45281, D.45284, 1);
  if (j == 0)
    goto <bb 387>;
  else
    goto <bb 389>;

<bb 387>:
  v_engine->cur_payload_map = pmap;
  D.45287 = v_engine->cur_payload_map;
  D.45287->current = 1;
  D.45288 = v_engine->rtp_session;
  if (D.45288 != 0B)
    goto <bb 388>;
  else
    goto <bb 389>;

<bb 388>:
  D.45288 = v_engine->rtp_session;
  D.45291 = pmap->pt;
  switch_rtp_set_default_payload (D.45288, D.45291);

<bb 389>:
  mimp = matches[j].imp;
  map = matches[j].map;
  D.45256 = map->rm_encoding;
  D.45292 = switch_core_perform_session_strdup (session, D.45256, "src/switch_core_media.c", &__func__, 3804);
  pmap->rm_encoding = D.45292;
  D.45248 = map->rm_pt;
  D.45293 = (unsigned char) D.45248;
  pmap->recv_pt = D.45293;
  D.45263 = map->rm_rate;
  pmap->rm_rate = D.45263;
  D.45294 = mimp->microseconds_per_packet;
  D.45295 = D.45294 / 1000;
  D.45296 = (uint32_t) D.45295;
  pmap->codec_ms = D.45296;
  D.45086 = connection->c_address;
  D.45297 = switch_core_perform_session_strdup (session, D.45086, "src/switch_core_media.c", &__func__, 3810);
  pmap->remote_sdp_ip = D.45297;
  D.44697 = m->m_port;
  D.45088 = (short unsigned int) D.44697;
  pmap->remote_sdp_port = D.45088;
  D.45298 = map->rm_fmtp;
  D.45299 = switch_core_perform_session_strdup (session, D.45298, "src/switch_core_media.c", &__func__, 3813);
  pmap->rm_fmtp = D.45299;
  D.45248 = map->rm_pt;
  D.45293 = (unsigned char) D.45248;
  pmap->agreed_pt = D.45293;
  j = j + 1;

<bb 390>:
  if (j < m_idx)
    goto <bb 386>;
  else
    goto <bb 391>;

<bb 391>:
  D.45287 = v_engine->cur_payload_map;
  D.45300 = D.45287->remote_sdp_port;
  D.45301 = (int) D.45300;
  switch_snprintf (&tmp, 50, "%d", D.45301);
  D.44530 = session->channel;
  D.45287 = v_engine->cur_payload_map;
  D.45302 = D.45287->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.44530, "remote_video_ip", D.45302, 1);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "remote_video_port", &tmp, 1);
  D.44530 = session->channel;
  D.45287 = v_engine->cur_payload_map;
  D.45303 = D.45287->rm_fmtp;
  switch_channel_set_variable_var_check (D.44530, "rtp_video_fmtp", D.45303, 1);
  D.45287 = v_engine->cur_payload_map;
  D.45304 = D.45287->agreed_pt;
  D.45305 = (int) D.45304;
  switch_snprintf (&tmp, 50, "%d", D.45305);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "rtp_video_pt", &tmp, 1);
  switch_core_media_check_video_codecs (session);
  D.45287 = v_engine->cur_payload_map;
  D.45306 = D.45287->recv_pt;
  D.45307 = (int) D.45306;
  switch_snprintf (&tmp, 50, "%d", D.45307);
  D.44530 = session->channel;
  switch_channel_set_variable_var_check (D.44530, "rtp_video_recv_pt", &tmp, 1);
  D.45308 = match == 0;
  D.45309 = vmatch != 0;
  D.45310 = D.45308 && D.45309;
  if (D.45310 != 0)
    goto <bb 392>;
  else
    goto <bb 393>;

<bb 392>:
  match = 1;

<bb 393>:
  D.45313 = &v_engine->read_codec;
  D.45314 = switch_core_codec_ready (D.45313);
  if (D.45314 != 0)
    goto <bb 394>;
  else
    goto <bb 395>;

<bb 394>:
  v_engine->reset_codec = 1;

<bb 395>:
  D.45317 = switch_core_media_set_video_codec (session, 0);
  if (D.45317 == 0)
    goto <bb 396>;
  else
    goto <bb 397>;

<bb 396>:
  check_ice (smh, 1, sdp, m);

<bb 397>:
  m = m->m_next;

<bb 398>:
  if (m != 0B)
    goto <bb 91>;
  else
    goto <bb 399> (done);

done:
  if (parser != 0B)
    goto <bb 400>;
  else
    goto <bb 401>;

<bb 400>:
  sdp_parser_free (parser);

<bb 401>:
  D.44471 = smh->mparams;
  D.44471->cng_pt = cng_pt;
  D.44470 = match;

<bb 402>:
  return D.44470;

}



;; Function switch_core_media_process_udptl (switch_core_media_process_udptl)

Scope blocks:

{ Scope block #0 
  struct switch_t38_options_t * t38_options; (unused)
  struct sdp_attribute_t * attr; (unused)
  static const char __func__[32] = "switch_core_media_process_udptl"; (unused)

}
Merging blocks 44 and 45
switch_core_media_process_udptl (struct switch_core_session_t * session, struct sdp_session_t * sdp, struct sdp_media_t * m)
{
  static const char __func__[32] = "switch_core_media_process_udptl";
  struct sdp_attribute_t * attr;
  struct switch_t38_options_t * t38_options;
  struct switch_t38_options_t * D.45418;
  char * D.45417;
  int D.45412;
  char * D.45411;
  int D.45408;
  unsigned int D.45405;
  int D.45404;
  int D.45401;
  unsigned int D.45398;
  int D.45397;
  int D.45394;
  char * D.45391;
  int D.45388;
  switch_bool_t D.45384;
  int D.45383;
  int D.45380;
  switch_bool_t D.45378;
  int D.45377;
  int D.45374;
  switch_bool_t D.45372;
  int D.45371;
  int D.45368;
  unsigned int D.45367;
  int D.45366;
  int D.45363;
  short unsigned int D.45360;
  int D.45359;
  const char * D.45357;
  int D.45355;
  const char * D.45354;
  char * D.45351;
  const char * D.45348;
  struct sdp_connection_t * D.45345;
  char * D.45342;
  const char * D.45340;
  struct sdp_connection_t * D.45338;
  char * D.45334;
  const char * D.45333;
  struct sdp_origin_t * D.45330;
  short unsigned int D.45329;
  long unsigned int D.45328;
  char * D.45327;
  char * D.45326;
  struct switch_channel_t * D.45323;

<bb 2>:
  D.45323 = session->channel;
  t38_options = switch_channel_get_private (D.45323, "t38_options");
  if (t38_options == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  t38_options = switch_core_perform_session_alloc (session, 60, "src/switch_core_media.c", &__func__, 369);
  t38_options->T38FaxVersion = 0;
  t38_options->T38MaxBitRate = 14400;
  D.45326 = switch_core_perform_session_strdup (session, "transferredTCF", "src/switch_core_media.c", &__func__, 374);
  t38_options->T38FaxRateManagement = D.45326;
  D.45327 = switch_core_perform_session_strdup (session, "t38UDPRedundancy", "src/switch_core_media.c", &__func__, 375);
  t38_options->T38FaxUdpEC = D.45327;
  t38_options->T38FaxMaxBuffer = 500;
  t38_options->T38FaxMaxDatagram = 500;

<bb 4>:
  D.45328 = m->m_port;
  D.45329 = (short unsigned int) D.45328;
  t38_options->remote_port = D.45329;
  D.45330 = sdp->sdp_origin;
  if (D.45330 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.45330 = sdp->sdp_origin;
  D.45333 = D.45330->o_username;
  D.45334 = switch_core_perform_session_strdup (session, D.45333, "src/switch_core_media.c", &__func__, 383);
  t38_options->sdp_o_line = D.45334;
  goto <bb 7>;

<bb 6>:
  t38_options->sdp_o_line = "unknown";

<bb 7>:
  D.45338 = m->m_connections;
  if (D.45338 != 0B)
    goto <bb 8>;
  else
    goto <bb 10>;

<bb 8>:
  D.45338 = m->m_connections;
  D.45340 = D.45338->c_address;
  if (D.45340 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.45338 = m->m_connections;
  D.45340 = D.45338->c_address;
  D.45342 = switch_core_perform_session_strdup (session, D.45340, "src/switch_core_media.c", &__func__, 389);
  t38_options->remote_ip = D.45342;
  goto <bb 14>;

<bb 10>:
  if (sdp != 0B)
    goto <bb 11>;
  else
    goto <bb 14>;

<bb 11>:
  D.45345 = sdp->sdp_connection;
  if (D.45345 != 0B)
    goto <bb 12>;
  else
    goto <bb 14>;

<bb 12>:
  D.45345 = sdp->sdp_connection;
  D.45348 = D.45345->c_address;
  if (D.45348 != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.45345 = sdp->sdp_connection;
  D.45348 = D.45345->c_address;
  D.45351 = switch_core_perform_session_strdup (session, D.45348, "src/switch_core_media.c", &__func__, 391);
  t38_options->remote_ip = D.45351;

<bb 14>:
  attr = m->m_attributes;
  goto <bb 43>;

<bb 15>:
  D.45354 = attr->a_name;
  D.45355 = strcasecmp (D.45354, "T38FaxVersion");
  if (D.45355 == 0)
    goto <bb 16>;
  else
    goto <bb 18>;

<bb 16>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.45357 = attr->a_value;
  D.45359 = atoi (D.45357);
  D.45360 = (short unsigned int) D.45359;
  t38_options->T38FaxVersion = D.45360;
  goto <bb 42>;

<bb 18>:
  D.45354 = attr->a_name;
  D.45363 = strcasecmp (D.45354, "T38MaxBitRate");
  if (D.45363 == 0)
    goto <bb 19>;
  else
    goto <bb 21>;

<bb 19>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  D.45357 = attr->a_value;
  D.45366 = atoi (D.45357);
  D.45367 = (unsigned int) D.45366;
  t38_options->T38MaxBitRate = D.45367;
  goto <bb 42>;

<bb 21>:
  D.45354 = attr->a_name;
  D.45368 = strcasecmp (D.45354, "T38FaxFillBitRemoval");
  if (D.45368 == 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.45357 = attr->a_value;
  D.45371 = switch_safe_atoi (D.45357, 1);
  D.45372 = (switch_bool_t) D.45371;
  t38_options->T38FaxFillBitRemoval = D.45372;
  goto <bb 42>;

<bb 23>:
  D.45354 = attr->a_name;
  D.45374 = strcasecmp (D.45354, "T38FaxTranscodingMMR");
  if (D.45374 == 0)
    goto <bb 24>;
  else
    goto <bb 25>;

<bb 24>:
  D.45357 = attr->a_value;
  D.45377 = switch_safe_atoi (D.45357, 1);
  D.45378 = (switch_bool_t) D.45377;
  t38_options->T38FaxTranscodingMMR = D.45378;
  goto <bb 42>;

<bb 25>:
  D.45354 = attr->a_name;
  D.45380 = strcasecmp (D.45354, "T38FaxTranscodingJBIG");
  if (D.45380 == 0)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  D.45357 = attr->a_value;
  D.45383 = switch_safe_atoi (D.45357, 1);
  D.45384 = (switch_bool_t) D.45383;
  t38_options->T38FaxTranscodingJBIG = D.45384;
  goto <bb 42>;

<bb 27>:
  D.45354 = attr->a_name;
  D.45388 = strcasecmp (D.45354, "T38FaxRateManagement");
  if (D.45388 == 0)
    goto <bb 28>;
  else
    goto <bb 30>;

<bb 28>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  D.45357 = attr->a_value;
  D.45391 = switch_core_perform_session_strdup (session, D.45357, "src/switch_core_media.c", &__func__, 406);
  t38_options->T38FaxRateManagement = D.45391;
  goto <bb 42>;

<bb 30>:
  D.45354 = attr->a_name;
  D.45394 = strcasecmp (D.45354, "T38FaxMaxBuffer");
  if (D.45394 == 0)
    goto <bb 31>;
  else
    goto <bb 33>;

<bb 31>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 32>;
  else
    goto <bb 33>;

<bb 32>:
  D.45357 = attr->a_value;
  D.45397 = atoi (D.45357);
  D.45398 = (unsigned int) D.45397;
  t38_options->T38FaxMaxBuffer = D.45398;
  goto <bb 42>;

<bb 33>:
  D.45354 = attr->a_name;
  D.45401 = strcasecmp (D.45354, "T38FaxMaxDatagram");
  if (D.45401 == 0)
    goto <bb 34>;
  else
    goto <bb 36>;

<bb 34>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 35>;
  else
    goto <bb 36>;

<bb 35>:
  D.45357 = attr->a_value;
  D.45404 = atoi (D.45357);
  D.45405 = (unsigned int) D.45404;
  t38_options->T38FaxMaxDatagram = D.45405;
  goto <bb 42>;

<bb 36>:
  D.45354 = attr->a_name;
  D.45408 = strcasecmp (D.45354, "T38FaxUdpEC");
  if (D.45408 == 0)
    goto <bb 37>;
  else
    goto <bb 39>;

<bb 37>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  D.45357 = attr->a_value;
  D.45411 = switch_core_perform_session_strdup (session, D.45357, "src/switch_core_media.c", &__func__, 412);
  t38_options->T38FaxUdpEC = D.45411;
  goto <bb 42>;

<bb 39>:
  D.45354 = attr->a_name;
  D.45412 = strcasecmp (D.45354, "T38VendorInfo");
  if (D.45412 == 0)
    goto <bb 40>;
  else
    goto <bb 42>;

<bb 40>:
  D.45357 = attr->a_value;
  if (D.45357 != 0B)
    goto <bb 41>;
  else
    goto <bb 42>;

<bb 41>:
  D.45357 = attr->a_value;
  D.45417 = switch_core_perform_session_strdup (session, D.45357, "src/switch_core_media.c", &__func__, 414);
  t38_options->T38VendorInfo = D.45417;

<bb 42>:
  attr = attr->a_next;

<bb 43>:
  if (attr != 0B)
    goto <bb 15>;
  else
    goto <bb 44>;

<bb 44>:
  D.45323 = session->channel;
  switch_channel_set_variable_var_check (D.45323, "has_t38", "true", 1);
  D.45323 = session->channel;
  switch_channel_set_private (D.45323, "t38_options", t38_options);
  D.45323 = session->channel;
  switch_channel_set_app_flag_key ("T38", D.45323, 2);
  D.45323 = session->channel;
  switch_channel_execute_on (D.45323, "sip_execute_on_image");
  D.45323 = session->channel;
  switch_channel_api_on (D.45323, "sip_api_on_image");
  D.45418 = t38_options;
  return D.45418;

}



;; Function switch_safe_atoi (switch_safe_atoi)

Scope blocks:

{ Scope block #0 

}
Merging blocks 5 and 6
switch_safe_atoi (const char * nptr, int dft)
{
  int iftmp.100;
  int D.45420;

<bb 2>:
  if (nptr != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  iftmp.100 = atoi (nptr);
  goto <bb 5>;

<bb 4>:
  iftmp.100 = dft;

<bb 5>:
  D.45420 = iftmp.100;
  return D.45420;

}



;; Function greedy_sort (greedy_sort)

Scope blocks:

{ Scope block #0 
  int j; (unused)
  int f; (unused)
  int g; (unused)
  struct matches mtmp[30]; (unused)

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)

  }

}
greedy_sort (struct switch_media_handle_t * smh, struct matches * matches, int m_idx, const struct switch_codec_implementation_t * * codec_array, int total_codecs)
{
  const struct switch_codec_implementation_t * imp;
  struct matches mtmp[30];
  int g;
  int f;
  int j;
  _Bool D.45443;
  _Bool D.45442;
  _Bool D.45441;
  int D.45440;
  struct switch_core_media_params_t * D.45439;
  struct matches * D.45438;
  unsigned int D.45437;
  unsigned int f.103;
  const struct switch_codec_implementation_t * D.45433;
  const struct switch_codec_implementation_t * * D.45432;
  unsigned int D.45431;
  unsigned int g.102;
  struct matches * D.45429;
  struct matches * D.45428;
  unsigned int D.45427;
  unsigned int j.101;

<bb 2>:
  j = 0;
  f = 0;
  mtmp = {};
  j = 0;
  goto <bb 4>;

<bb 3>:
  j.101 = (unsigned int) j;
  D.45427 = j.101 * 16;
  D.45428 = &mtmp + D.45427;
  j.101 = (unsigned int) j;
  D.45427 = j.101 * 16;
  D.45429 = matches + D.45427;
  *D.45428 = *D.45429;
  j = j + 1;

<bb 4>:
  if (j < m_idx)
    goto <bb 3>;
  else
    goto <bb 5>;

<bb 5>:
  g = 0;
  goto <bb 12>;

<bb 6>:
  g.102 = (unsigned int) g;
  D.45431 = g.102 * 4;
  D.45432 = codec_array + D.45431;
  imp = *D.45432;
  j = 0;
  goto <bb 10>;

<bb 7>:
  D.45433 = mtmp[j].imp;
  if (D.45433 == imp)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  f.103 = (unsigned int) f;
  D.45437 = f.103 * 16;
  D.45438 = matches + D.45437;
  j.101 = (unsigned int) j;
  D.45427 = j.101 * 16;
  D.45428 = &mtmp + D.45427;
  *D.45438 = *D.45428;
  f = f + 1;

<bb 9>:
  j = j + 1;

<bb 10>:
  if (j < m_idx)
    goto <bb 7>;
  else
    goto <bb 11>;

<bb 11>:
  g = g + 1;

<bb 12>:
  D.45439 = smh->mparams;
  D.45440 = D.45439->num_codecs;
  D.45441 = D.45440 > g;
  D.45442 = g < total_codecs;
  D.45443 = D.45441 && D.45442;
  if (D.45443 != 0)
    goto <bb 6>;
  else
    goto <bb 13>;

<bb 13>:
  return;

}



;; Function switch_core_codec_ready (switch_core_codec_ready)

Scope blocks:

{ Scope block #0 

}
Merging blocks 9 and 10
switch_core_codec_ready (struct switch_codec_t * codec)
{
  const struct switch_codec_implementation_t * D.45456;
  struct switch_codec_interface_t * D.45454;
  struct switch_mutex_t * D.45452;
  uint32_t D.45450;
  uint32_t D.45449;
  int iftmp.104;
  switch_bool_t D.45444;

<bb 2>:
  if (codec != 0B)
    goto <bb 3>;
  else
    goto <bb 8>;

<bb 3>:
  D.45449 = codec->flags;
  D.45450 = D.45449 & 256;
  if (D.45450 != 0)
    goto <bb 4>;
  else
    goto <bb 8>;

<bb 4>:
  D.45452 = codec->mutex;
  if (D.45452 != 0B)
    goto <bb 5>;
  else
    goto <bb 8>;

<bb 5>:
  D.45454 = codec->codec_interface;
  if (D.45454 != 0B)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 6>:
  D.45456 = codec->implementation;
  if (D.45456 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  iftmp.104 = 1;
  goto <bb 9>;

<bb 8>:
  iftmp.104 = 0;

<bb 9>:
  D.45444 = (switch_bool_t) iftmp.104;
  return D.45444;

}



;; Function check_ice (check_ice)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)
  struct sdp_attribute_t * attr; (unused)
  int i; (unused)
  int got_rtcp_mux; (unused)
  const char * val; (unused)
  static const char __func__[10] = "check_ice"; (unused)

  { Scope block #0 
    char * data; (unused)
    char * fields[15]; (unused)
    int argc; (unused)
    int j; (unused)
    int cid; (unused)

    { Scope block #0 
      char * p; (unused)

    }

  }

  { Scope block #0 
    char tmp[80]; (unused)

  }

  { Scope block #0 
    const char * rport; (unused)
    switch_port_t remote_rtcp_port; (unused)

    { Scope block #0 
      int interval; (unused)

    }

  }

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

}
Removing basic block 71
;; basic block 71, loop depth 0, count 0
;; prev block 70, next block 72
;; pred:      
;; succ:       72 (fallthru)
<bb 71>:
i = i + 1;


Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       216 (fallthru)
<bb 5>:
goto <bb 216>;


Removing basic block 9
;; basic block 9, loop depth 0, count 0
;; prev block 8, next block 10
;; pred:      
;; succ:       74 (fallthru)
<bb 9>:
goto <bb 74>;


Removing basic block 31
;; basic block 31, loop depth 0, count 0
;; prev block 30, next block 32
;; pred:      
;; succ:       73 (fallthru)
<bb 31>:
goto <bb 73>;


Merging blocks 45 and 72
Removing basic block 70
;; basic block 70, loop depth 0, count 0
;; prev block 69, next block 73
;; pred:      
;; succ:       73 (fallthru)
<bb 70>:


check_ice (struct switch_media_handle_t * smh, switch_media_type_t type, struct sdp_session_t * sdp, struct sdp_media_t * m)
{
  size_t __s2_len;
  size_t __s1_len;
  int interval;
  switch_port_t remote_rtcp_port;
  const char * rport;
  char tmp[80];
  char * p;
  int cid;
  int j;
  int argc;
  char * fields[15];
  char * data;
  static const char __func__[10] = "check_ice";
  const char * val;
  int got_rtcp_mux;
  int i;
  struct sdp_attribute_t * attr;
  struct switch_rtp_engine_t * engine;
  switch_call_direction_t D.45836;
  switch_core_media_ice_type_t iftmp.126;
  char * iftmp.125;
  char * iftmp.124;
  int D.38904;
  char * iftmp.123;
  unsigned int D.45813;
  unsigned int interval.122;
  switch_bool_t D.45810;
  int8_t D.45809;
  int D.45808;
  char * iftmp.121;
  int D.45801;
  int D.45800;
  _Bool D.45797;
  _Bool D.45796;
  _Bool D.45795;
  char[27] * iftmp.120;
  struct switch_core_media_params_t * D.45789;
  char * iftmp.119;
  char[25] * iftmp.118;
  struct ice_t * D.45776;
  switch_call_direction_t D.45772;
  switch_core_media_ice_type_t iftmp.117;
  char * D.45770;
  char * D.45769;
  char * iftmp.116;
  uint8_t D.45760;
  uint32_t D.45757;
  _Bool D.45754;
  _Bool D.45753;
  _Bool D.45752;
  char * D.45751;
  char * iftmp.115;
  char * D.45744;
  int D.45743;
  switch_port_t D.45740;
  char * D.45739;
  char * D.45738;
  int D.45737;
  char * iftmp.114;
  char * D.45732;
  switch_port_t D.45729;
  char * D.45726;
  int D.45725;
  char * D.45724;
  int D.45722;
  char * D.45721;
  uint8_t D.45716;
  int D.45715;
  char * iftmp.113;
  char * iftmp.112;
  int D.45694;
  switch_port_t D.45693;
  char * D.45692;
  char * iftmp.111;
  const void * restrict D.45687;
  unsigned int D.45686;
  unsigned int D.45685;
  const void * restrict D.45684;
  void * restrict D.45683;
  unsigned int D.45682;
  unsigned int D.45681;
  unsigned int D.45680;
  void * restrict D.45679;
  struct icand_t * D.45678;
  _Bool D.45675;
  _Bool D.45674;
  _Bool D.45673;
  char * iftmp.110;
  char * iftmp.109;
  char * iftmp.108;
  uint8_t D.45640;
  uint8_t D.45639;
  switch_bool_t D.45636;
  char * D.45635;
  switch_port_t D.45632;
  int D.45629;
  char * iftmp.107;
  uint8_t D.45622;
  uint8_t D.45621;
  switch_bool_t D.45618;
  char * D.45617;
  switch_port_t D.45614;
  int D.45611;
  uint8_t D.45606;
  uint8_t D.45605;
  char * D.45601;
  int D.45598;
  short unsigned int D.45596;
  int D.45595;
  int D.45592;
  char * D.45590;
  int D.45587;
  char * D.45585;
  char * D.45584;
  int D.45583;
  int D.45580;
  char * D.45579;
  short unsigned int D.45578;
  int D.45577;
  char * D.45576;
  uint32_t D.45575;
  long int D.45574;
  char * D.45573;
  char * D.45572;
  int D.45571;
  char * D.45570;
  char * D.45569;
  char * iftmp.106;
  char * iftmp.105;
  switch_bool_t D.45559;
  char * D.45558;
  int D.45556;
  int D.45553;
  char * D.45552;
  char * D.45551;
  char * D.45550;
  char * D.45549;
  int D.45548;
  char * D.45547;
  int D.45546;
  char * D.45545;
  int D.45544;
  unsigned int D.45540;
  const char * D.45537;
  int D.45536;
  int D.45533;
  int D.45530;
  switch_port_t D.45528;
  struct payload_map_t * D.45527;
  int D.45524;
  struct switch_rtp_t * D.45519;
  unsigned int D.45518;
  long int D.45517;
  int D.45514;
  uint32_t D.45512;
  char[192] * D.45509;
  char * D.45506;
  char * D.45505;
  int D.45503;
  int D.45501;
  int D.45499;
  int D.45497;
  char * D.45493;
  int D.45490;
  char * D.45488;
  int D.45485;
  char * D.45483;
  const char * D.45482;
  int D.45479;
  int D.45476;
  const char * D.45475;
  uint32_t D.45469;
  struct switch_channel_t * D.45468;
  struct switch_core_session_t * D.45467;
  int D.45464;
  int D.45461;
  unsigned int D.45460;
  struct switch_rtp_engine_t[2] * D.45459;

<bb 2>:
  D.45459 = &smh->engines;
  D.45460 = type * 11416;
  engine = D.45459 + D.45460;
  i = 0;
  got_rtcp_mux = 0;
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 != 0)
    goto <bb 3>;
  else
    goto <bb 5>;

<bb 3>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  D.45469 = switch_channel_test_flag (D.45468, 103);
  if (D.45469 == 0)
    goto <bb 210>;
  else
    goto <bb 5>;

<bb 5>:
  engine->ice_in.chosen[0] = 0;
  engine->ice_in.chosen[1] = 0;
  engine->ice_in.cand_idx = 0;
  if (m != 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  attr = m->m_attributes;
  goto <bb 68>;

<bb 7>:
  attr = sdp->sdp_attributes;
  goto <bb 68>;

<bb 8>:
  argc = 0;
  j = 0;
  cid = 0;
  D.45475 = attr->a_name;
  D.45476 = _zstr (D.45475);
  if (D.45476 != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  // predicted unlikely by continue predictor.
  goto <bb 67>;

<bb 10>:
  D.45475 = attr->a_name;
  D.45479 = strcasecmp (D.45475, "ice-ufrag");
  if (D.45479 == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.45467 = smh->session;
  D.45482 = attr->a_value;
  D.45483 = switch_core_perform_session_strdup (D.45467, D.45482, "src/switch_core_media.c", &__func__, 2503);
  engine->ice_in.ufrag = D.45483;
  goto <bb 67>;

<bb 12>:
  D.45475 = attr->a_name;
  D.45485 = strcasecmp (D.45475, "ice-pwd");
  if (D.45485 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.45467 = smh->session;
  D.45482 = attr->a_value;
  D.45488 = switch_core_perform_session_strdup (D.45467, D.45482, "src/switch_core_media.c", &__func__, 2505);
  engine->ice_in.pwd = D.45488;
  goto <bb 67>;

<bb 14>:
  D.45475 = attr->a_name;
  D.45490 = strcasecmp (D.45475, "ice-options");
  if (D.45490 == 0)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.45467 = smh->session;
  D.45482 = attr->a_value;
  D.45493 = switch_core_perform_session_strdup (D.45467, D.45482, "src/switch_core_media.c", &__func__, 2507);
  engine->ice_in.options = D.45493;
  goto <bb 67>;

<bb 16>:
  D.45497 = switch_rtp_has_dtls ();
  if (D.45497 != 0)
    goto <bb 17>;
  else
    goto <bb 23>;

<bb 17>:
  D.45467 = smh->session;
  D.45499 = dtls_ok (D.45467);
  if (D.45499 != 0)
    goto <bb 18>;
  else
    goto <bb 23>;

<bb 18>:
  D.45475 = attr->a_name;
  D.45501 = strcasecmp (D.45475, "fingerprint");
  if (D.45501 == 0)
    goto <bb 19>;
  else
    goto <bb 23>;

<bb 19>:
  D.45482 = attr->a_value;
  D.45503 = _zstr (D.45482);
  if (D.45503 == 0)
    goto <bb 20>;
  else
    goto <bb 23>;

<bb 20>:
  D.45467 = smh->session;
  D.45482 = attr->a_value;
  D.45505 = switch_core_perform_session_strdup (D.45467, D.45482, "src/switch_core_media.c", &__func__, 2512);
  engine->remote_dtls_fingerprint.type = D.45505;
  D.45506 = engine->remote_dtls_fingerprint.type;
  p = __builtin_strchr (D.45506, 32);
  if (p != 0B)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  *p = 0;
  p = p + 1;
  D.45509 = &engine->local_dtls_fingerprint.str;
  switch_copy_string (D.45509, p, 192);

<bb 22>:
  generate_local_fingerprint (smh, type);
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  switch_channel_set_flag_value (D.45468, 109, 1);
  goto <bb 67>;

<bb 23>:
  D.45512 = engine->remote_ssrc;
  if (D.45512 == 0)
    goto <bb 24>;
  else
    goto <bb 29>;

<bb 24>:
  D.45475 = attr->a_name;
  D.45514 = strcasecmp (D.45475, "ssrc");
  if (D.45514 == 0)
    goto <bb 25>;
  else
    goto <bb 29>;

<bb 25>:
  D.45482 = attr->a_value;
  if (D.45482 != 0B)
    goto <bb 26>;
  else
    goto <bb 29>;

<bb 26>:
  D.45482 = attr->a_value;
  D.45517 = atol (D.45482);
  D.45518 = (unsigned int) D.45517;
  engine->remote_ssrc = D.45518;
  D.45519 = engine->rtp_session;
  if (D.45519 != 0B)
    goto <bb 27>;
  else
    goto <bb 67>;

<bb 27>:
  D.45512 = engine->remote_ssrc;
  if (D.45512 != 0)
    goto <bb 28>;
  else
    goto <bb 67>;

<bb 28>:
  D.45519 = engine->rtp_session;
  D.45512 = engine->remote_ssrc;
  switch_rtp_set_remote_ssrc (D.45519, D.45512);
  goto <bb 67>;

<bb 29>:
  D.45475 = attr->a_name;
  D.45524 = strcasecmp (D.45475, "rtcp-mux");
  if (D.45524 == 0)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  engine->rtcp_mux = 1;
  D.45527 = engine->cur_payload_map;
  D.45528 = D.45527->remote_sdp_port;
  engine->remote_rtcp_port = D.45528;
  got_rtcp_mux = got_rtcp_mux + 1;
  goto <bb 67>;

<bb 31>:
  D.45475 = attr->a_name;
  D.45530 = strcasecmp (D.45475, "candidate");
  if (D.45530 == 0)
    goto <bb 32>;
  else
    goto <bb 67>;

<bb 32>:
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  switch_channel_set_flag_value (D.45468, 108, 1);
  D.45533 = engine->cand_acl_count;
  if (D.45533 == 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.45533 = engine->cand_acl_count;
  engine->cand_acl[D.45533] = "wan.auto";
  D.45536 = D.45533 + 1;
  engine->cand_acl_count = D.45536;
  D.45467 = smh->session;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2548, D.45467, 4, "NO candidate ACL defined, Defaulting to wan.auto\n");

<bb 34>:
  D.45482 = attr->a_value;
  D.45537 = switch_stristr (" udp ", D.45482);
  if (D.45537 == 0B)
    goto <bb 35>;
  else
    goto <bb 36>;

<bb 35>:
  // predicted unlikely by continue predictor.
  goto <bb 67>;

<bb 36>:
  D.45467 = smh->session;
  D.45482 = attr->a_value;
  data = switch_core_perform_session_strdup (D.45467, D.45482, "src/switch_core_media.c", &__func__, 2556);
  D.45540 = switch_separate_string (data, 32, &fields, 15);
  argc = (int) D.45540;
  if (argc <= 4)
    goto <bb 38>;
  else
    goto <bb 37>;

<bb 37>:
  D.45544 = engine->ice_in.cand_idx;
  if (D.45544 > 48)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  D.45467 = smh->session;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2561, D.45467, 4, "Invalid data\n");
  // predicted unlikely by continue predictor.
  goto <bb 67>;

<bb 39>:
  D.45545 = fields[1];
  D.45546 = atoi (D.45545);
  cid = D.45546 + -1;
  i = 0;
  goto <bb 41>;

<bb 40>:
  D.45467 = smh->session;
  D.45547 = fields[i];
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2569, D.45467, 101, "CAND %d [%s]\n", i, D.45547);
  i = i + 1;

<bb 41>:
  if (i < argc)
    goto <bb 40>;
  else
    goto <bb 42>;

<bb 42>:
  D.45467 = smh->session;
  D.45548 = cid + 1;
  D.45549 = fields[2];
  D.45550 = fields[7];
  D.45551 = fields[4];
  D.45552 = fields[5];
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2572, D.45467, 7, "Checking Candidate cid: %d proto: %s type: %s addr: %s:%s\n", D.45548, D.45549, D.45550, D.45551, D.45552);
  D.45544 = engine->ice_in.cand_idx;
  D.45553 = D.45544 + 1;
  engine->ice_in.cand_idx = D.45553;
  i = 0;
  D.45533 = engine->cand_acl_count;
  if (D.45533 > i)
    goto <bb 43>;
  else
    goto <bb 67>;

<bb 43>:
  D.45556 = engine->ice_in.chosen[cid];
  if (D.45556 == 0)
    goto <bb 44>;
  else
    goto <bb 49>;

<bb 44>:
  D.45551 = fields[4];
  D.45558 = engine->cand_acl[i];
  D.45559 = switch_check_network_list_ip_token (D.45551, D.45558, 0B);
  if (D.45559 != 0)
    goto <bb 45>;
  else
    goto <bb 49>;

<bb 45>:
  D.45544 = engine->ice_in.cand_idx;
  engine->ice_in.chosen[cid] = D.45544;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 46>;
  else
    goto <bb 47>;

<bb 46>:
  iftmp.105 = "video";
  goto <bb 48>;

<bb 47>:
  iftmp.105 = "audio";

<bb 48>:
  D.45548 = cid + 1;
  D.45549 = fields[2];
  D.45550 = fields[7];
  D.45551 = fields[4];
  D.45552 = fields[5];
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2581, D.45467, 5, "Choose %s Candidate cid: %d proto: %s type: %s addr: %s:%s\n", iftmp.105, D.45548, D.45549, D.45550, D.45551, D.45552);
  goto <bb 53>;

<bb 49>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 50>;
  else
    goto <bb 51>;

<bb 50>:
  iftmp.106 = "video";
  goto <bb 52>;

<bb 51>:
  iftmp.106 = "audio";

<bb 52>:
  D.45548 = cid + 1;
  D.45549 = fields[2];
  D.45550 = fields[7];
  D.45551 = fields[4];
  D.45552 = fields[5];
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2586, D.45467, 5, "Save %s Candidate cid: %d proto: %s type: %s addr: %s:%s\n", iftmp.106, D.45548, D.45549, D.45550, D.45551, D.45552);

<bb 53>:
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45569 = fields[0];
  D.45570 = switch_core_perform_session_strdup (D.45467, D.45569, "src/switch_core_media.c", &__func__, 2592);
  engine->ice_in.cands[D.45544][cid].foundation = D.45570;
  D.45544 = engine->ice_in.cand_idx;
  D.45545 = fields[1];
  D.45571 = atoi (D.45545);
  engine->ice_in.cands[D.45544][cid].component_id = D.45571;
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45549 = fields[2];
  D.45572 = switch_core_perform_session_strdup (D.45467, D.45549, "src/switch_core_media.c", &__func__, 2594);
  engine->ice_in.cands[D.45544][cid].transport = D.45572;
  D.45544 = engine->ice_in.cand_idx;
  D.45573 = fields[3];
  D.45574 = atol (D.45573);
  D.45575 = (uint32_t) D.45574;
  engine->ice_in.cands[D.45544][cid].priority = D.45575;
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45551 = fields[4];
  D.45576 = switch_core_perform_session_strdup (D.45467, D.45551, "src/switch_core_media.c", &__func__, 2596);
  engine->ice_in.cands[D.45544][cid].con_addr = D.45576;
  D.45544 = engine->ice_in.cand_idx;
  D.45552 = fields[5];
  D.45577 = atoi (D.45552);
  D.45578 = (short unsigned int) D.45577;
  engine->ice_in.cands[D.45544][cid].con_port = D.45578;
  j = 6;
  goto <bb 63>;

<bb 54>:
  D.45579 = fields[j];
  D.45580 = strcasecmp (D.45579, "typ");
  if (D.45580 == 0)
    goto <bb 55>;
  else
    goto <bb 56>;

<bb 55>:
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45583 = j + 1;
  D.45584 = fields[D.45583];
  D.45585 = switch_core_perform_session_strdup (D.45467, D.45584, "src/switch_core_media.c", &__func__, 2604);
  engine->ice_in.cands[D.45544][cid].cand_type = D.45585;
  goto <bb 62>;

<bb 56>:
  D.45579 = fields[j];
  D.45587 = strcasecmp (D.45579, "raddr");
  if (D.45587 == 0)
    goto <bb 57>;
  else
    goto <bb 58>;

<bb 57>:
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45583 = j + 1;
  D.45584 = fields[D.45583];
  D.45590 = switch_core_perform_session_strdup (D.45467, D.45584, "src/switch_core_media.c", &__func__, 2606);
  engine->ice_in.cands[D.45544][cid].raddr = D.45590;
  goto <bb 62>;

<bb 58>:
  D.45579 = fields[j];
  D.45592 = strcasecmp (D.45579, "rport");
  if (D.45592 == 0)
    goto <bb 59>;
  else
    goto <bb 60>;

<bb 59>:
  D.45544 = engine->ice_in.cand_idx;
  D.45583 = j + 1;
  D.45584 = fields[D.45583];
  D.45595 = atoi (D.45584);
  D.45596 = (short unsigned int) D.45595;
  engine->ice_in.cands[D.45544][cid].rport = D.45596;
  goto <bb 62>;

<bb 60>:
  D.45579 = fields[j];
  D.45598 = strcasecmp (D.45579, "generation");
  if (D.45598 == 0)
    goto <bb 61>;
  else
    goto <bb 62>;

<bb 61>:
  D.45544 = engine->ice_in.cand_idx;
  D.45467 = smh->session;
  D.45583 = j + 1;
  D.45584 = fields[D.45583];
  D.45601 = switch_core_perform_session_strdup (D.45467, D.45584, "src/switch_core_media.c", &__func__, 2610);
  engine->ice_in.cands[D.45544][cid].generation = D.45601;

<bb 62>:
  j = j + 2;

<bb 63>:
  if (j < argc)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  D.45583 = j + 1;
  D.45584 = fields[D.45583];
  if (D.45584 != 0B)
    goto <bb 54>;
  else
    goto <bb 65>;

<bb 65>:
  D.45556 = engine->ice_in.chosen[cid];
  if (D.45556 != 0)
    goto <bb 66>;
  else
    goto <bb 67>;

<bb 66>:
  D.45556 = engine->ice_in.chosen[cid];
  D.45605 = engine->ice_in.cands[D.45556][cid].ready;
  D.45606 = D.45605 + 1;
  engine->ice_in.cands[D.45556][cid].ready = D.45606;

<bb 67>:
  attr = attr->a_next;

<bb 68>:
  if (attr != 0B)
    goto <bb 8>;
  else
    goto <bb 69>;

<bb 69>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 71>;
  else
    goto <bb 70>;

<bb 70>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 71>;
  else
    goto <bb 92>;

<bb 71>:
  i = 0;
  goto <bb 89>;

<bb 72>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 73>;
  else
    goto <bb 80>;

<bb 73>:
  D.45611 = engine->ice_in.cands[i][0].component_id;
  if (D.45611 == 1)
    goto <bb 74>;
  else
    goto <bb 80>;

<bb 74>:
  D.45614 = engine->ice_in.cands[i][0].rport;
  if (D.45614 == 0)
    goto <bb 75>;
  else
    goto <bb 80>;

<bb 75>:
  D.45617 = engine->ice_in.cands[i][0].con_addr;
  D.45618 = switch_check_network_list_ip_token (D.45617, "localnet.auto", 0B);
  if (D.45618 != 0)
    goto <bb 76>;
  else
    goto <bb 80>;

<bb 76>:
  engine->ice_in.chosen[0] = i;
  D.45461 = engine->ice_in.chosen[0];
  D.45621 = engine->ice_in.cands[D.45461][0].ready;
  D.45622 = D.45621 + 1;
  engine->ice_in.cands[D.45461][0].ready = D.45622;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 77>;
  else
    goto <bb 78>;

<bb 77>:
  iftmp.107 = "video";
  goto <bb 79>;

<bb 78>:
  iftmp.107 = "audio";

<bb 79>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2636, D.45467, 5, "No %s RTP candidate found; defaulting to the first local one.\n", iftmp.107);

<bb 80>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 81>;
  else
    goto <bb 88>;

<bb 81>:
  D.45629 = engine->ice_in.cands[i][1].component_id;
  if (D.45629 == 2)
    goto <bb 82>;
  else
    goto <bb 88>;

<bb 82>:
  D.45632 = engine->ice_in.cands[i][1].rport;
  if (D.45632 == 0)
    goto <bb 83>;
  else
    goto <bb 88>;

<bb 83>:
  D.45635 = engine->ice_in.cands[i][1].con_addr;
  D.45636 = switch_check_network_list_ip_token (D.45635, "localnet.auto", 0B);
  if (D.45636 != 0)
    goto <bb 84>;
  else
    goto <bb 88>;

<bb 84>:
  engine->ice_in.chosen[1] = i;
  D.45464 = engine->ice_in.chosen[1];
  D.45639 = engine->ice_in.cands[D.45464][1].ready;
  D.45640 = D.45639 + 1;
  engine->ice_in.cands[D.45464][1].ready = D.45640;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 85>;
  else
    goto <bb 86>;

<bb 85>:
  iftmp.108 = "video";
  goto <bb 87>;

<bb 86>:
  iftmp.108 = "audio";

<bb 87>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2643, D.45467, 5, "No %s RTCP candidate found; defaulting to the first local one.\n", iftmp.108);

<bb 88>:
  i = i + 1;

<bb 89>:
  D.45544 = engine->ice_in.cand_idx;
  if (D.45544 >= i)
    goto <bb 90>;
  else
    goto <bb 92>;

<bb 90>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 72>;
  else
    goto <bb 91>;

<bb 91>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 72>;
  else
    goto <bb 92>;

<bb 92>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 94>;
  else
    goto <bb 93>;

<bb 93>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 94>;
  else
    goto <bb 113>;

<bb 94>:
  i = 0;
  goto <bb 110>;

<bb 95>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 96>;
  else
    goto <bb 102>;

<bb 96>:
  D.45611 = engine->ice_in.cands[i][0].component_id;
  if (D.45611 == 1)
    goto <bb 97>;
  else
    goto <bb 102>;

<bb 97>:
  D.45614 = engine->ice_in.cands[i][0].rport;
  if (D.45614 != 0)
    goto <bb 98>;
  else
    goto <bb 102>;

<bb 98>:
  engine->ice_in.chosen[0] = i;
  D.45461 = engine->ice_in.chosen[0];
  D.45621 = engine->ice_in.cands[D.45461][0].ready;
  D.45622 = D.45621 + 1;
  engine->ice_in.cands[D.45461][0].ready = D.45622;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 99>;
  else
    goto <bb 100>;

<bb 99>:
  iftmp.109 = "video";
  goto <bb 101>;

<bb 100>:
  iftmp.109 = "audio";

<bb 101>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2655, D.45467, 5, "No %s RTP candidate found; defaulting to the first srflx one.\n", iftmp.109);

<bb 102>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 103>;
  else
    goto <bb 109>;

<bb 103>:
  D.45629 = engine->ice_in.cands[i][1].component_id;
  if (D.45629 == 2)
    goto <bb 104>;
  else
    goto <bb 109>;

<bb 104>:
  D.45632 = engine->ice_in.cands[i][1].rport;
  if (D.45632 != 0)
    goto <bb 105>;
  else
    goto <bb 109>;

<bb 105>:
  engine->ice_in.chosen[1] = i;
  D.45464 = engine->ice_in.chosen[1];
  D.45639 = engine->ice_in.cands[D.45464][1].ready;
  D.45640 = D.45639 + 1;
  engine->ice_in.cands[D.45464][1].ready = D.45640;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 106>;
  else
    goto <bb 107>;

<bb 106>:
  iftmp.110 = "video";
  goto <bb 108>;

<bb 107>:
  iftmp.110 = "audio";

<bb 108>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2661, D.45467, 5, "No %s RTCP candidate found; defaulting to the first srflx one.\n", iftmp.110);

<bb 109>:
  i = i + 1;

<bb 110>:
  D.45544 = engine->ice_in.cand_idx;
  if (D.45544 >= i)
    goto <bb 111>;
  else
    goto <bb 113>;

<bb 111>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 95>;
  else
    goto <bb 112>;

<bb 112>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 95>;
  else
    goto <bb 113>;

<bb 113>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 != 0)
    goto <bb 114>;
  else
    goto <bb 119>;

<bb 114>:
  D.45464 = engine->ice_in.chosen[1];
  D.45673 = D.45464 == 0;
  D.45674 = got_rtcp_mux != 0;
  D.45675 = D.45673 && D.45674;
  if (D.45675 != 0)
    goto <bb 115>;
  else
    goto <bb 119>;

<bb 115>:
  D.45461 = engine->ice_in.chosen[0];
  engine->ice_in.chosen[1] = D.45461;
  D.45678 = &engine->ice_in.cands[0][0];
  D.45679 = (void * restrict) D.45678;
  D.45464 = engine->ice_in.chosen[1];
  D.45680 = (unsigned int) D.45464;
  D.45681 = D.45680 * 88;
  D.45682 = D.45681 + 44;
  D.45683 = D.45679 + D.45682;
  D.45678 = &engine->ice_in.cands[0][0];
  D.45684 = (const void * restrict) D.45678;
  D.45461 = engine->ice_in.chosen[0];
  D.45685 = (unsigned int) D.45461;
  D.45686 = D.45685 * 88;
  D.45687 = D.45684 + D.45686;
  memcpy (D.45683, D.45687, 44);
  D.45464 = engine->ice_in.chosen[1];
  D.45639 = engine->ice_in.cands[D.45464][1].ready;
  D.45640 = D.45639 + 1;
  engine->ice_in.cands[D.45464][1].ready = D.45640;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 116>;
  else
    goto <bb 117>;

<bb 116>:
  iftmp.111 = "video";
  goto <bb 118>;

<bb 117>:
  iftmp.111 = "audio";

<bb 118>:
  D.45464 = engine->ice_in.chosen[1];
  D.45692 = engine->ice_in.cands[D.45464][1].con_addr;
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  D.45694 = (int) D.45693;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2675, D.45467, 5, "No %s RTCP candidate found; defaulting to the same as RTP [%s:%d]\n", iftmp.111, D.45692, D.45694);

<bb 119>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 121>;
  else
    goto <bb 120>;

<bb 120>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 121>;
  else
    goto <bb 138>;

<bb 121>:
  i = 0;
  goto <bb 135>;

<bb 122>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 123>;
  else
    goto <bb 128>;

<bb 123>:
  D.45611 = engine->ice_in.cands[i][0].component_id;
  if (D.45611 == 1)
    goto <bb 124>;
  else
    goto <bb 128>;

<bb 124>:
  engine->ice_in.chosen[0] = i;
  D.45461 = engine->ice_in.chosen[0];
  D.45621 = engine->ice_in.cands[D.45461][0].ready;
  D.45622 = D.45621 + 1;
  engine->ice_in.cands[D.45461][0].ready = D.45622;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 125>;
  else
    goto <bb 126>;

<bb 125>:
  iftmp.112 = "video";
  goto <bb 127>;

<bb 126>:
  iftmp.112 = "audio";

<bb 127>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2686, D.45467, 5, "No %s RTP candidate found; defaulting to the first one.\n", iftmp.112);

<bb 128>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 129>;
  else
    goto <bb 134>;

<bb 129>:
  D.45629 = engine->ice_in.cands[i][1].component_id;
  if (D.45629 == 2)
    goto <bb 130>;
  else
    goto <bb 134>;

<bb 130>:
  engine->ice_in.chosen[1] = i;
  D.45464 = engine->ice_in.chosen[1];
  D.45639 = engine->ice_in.cands[D.45464][1].ready;
  D.45640 = D.45639 + 1;
  engine->ice_in.cands[D.45464][1].ready = D.45640;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 131>;
  else
    goto <bb 132>;

<bb 131>:
  iftmp.113 = "video";
  goto <bb 133>;

<bb 132>:
  iftmp.113 = "audio";

<bb 133>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2692, D.45467, 5, "No %s RTCP candidate found; defaulting to the first one.\n", iftmp.113);

<bb 134>:
  i = i + 1;

<bb 135>:
  D.45544 = engine->ice_in.cand_idx;
  if (D.45544 >= i)
    goto <bb 136>;
  else
    goto <bb 138>;

<bb 136>:
  D.45461 = engine->ice_in.chosen[0];
  if (D.45461 == 0)
    goto <bb 122>;
  else
    goto <bb 137>;

<bb 137>:
  D.45464 = engine->ice_in.chosen[1];
  if (D.45464 == 0)
    goto <bb 122>;
  else
    goto <bb 138>;

<bb 138>:
  i = 0;
  goto <bb 144>;

<bb 139>:
  D.45715 = engine->ice_in.chosen[i];
  D.45716 = engine->ice_in.cands[D.45715][i].ready;
  if (D.45716 != 0)
    goto <bb 140>;
  else
    goto <bb 143>;

<bb 140>:
  D.45721 = engine->ice_in.ufrag;
  D.45722 = _zstr (D.45721);
  if (D.45722 != 0)
    goto <bb 142>;
  else
    goto <bb 141>;

<bb 141>:
  D.45724 = engine->ice_in.pwd;
  D.45725 = _zstr (D.45724);
  if (D.45725 != 0)
    goto <bb 142>;
  else
    goto <bb 143>;

<bb 142>:
  D.45715 = engine->ice_in.chosen[i];
  engine->ice_in.cands[D.45715][i].ready = 0;

<bb 143>:
  i = i + 1;

<bb 144>:
  if (i <= 1)
    goto <bb 139>;
  else
    goto <bb 145>;

<bb 145>:
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  if (D.45726 != 0B)
    goto <bb 146>;
  else
    goto <bb 153>;

<bb 146>:
  D.45461 = engine->ice_in.chosen[0];
  D.45729 = engine->ice_in.cands[D.45461][0].con_port;
  if (D.45729 != 0)
    goto <bb 147>;
  else
    goto <bb 153>;

<bb 147>:
  tmp = "";
  D.45527 = engine->cur_payload_map;
  D.45467 = smh->session;
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  D.45732 = switch_core_perform_session_strdup (D.45467, D.45726, "src/switch_core_media.c", &__func__, 2709);
  D.45527->remote_sdp_ip = D.45732;
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 148>;
  else
    goto <bb 149>;

<bb 148>:
  iftmp.114 = "video";
  goto <bb 150>;

<bb 149>:
  iftmp.114 = "audio";

<bb 150>:
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  D.45461 = engine->ice_in.chosen[0];
  D.45729 = engine->ice_in.cands[D.45461][0].con_port;
  D.45737 = (int) D.45729;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2710, D.45467, 5, "setting remote %s ice addr to %s:%d based on candidate\n", iftmp.114, D.45726, D.45737);
  D.45461 = engine->ice_in.chosen[0];
  D.45621 = engine->ice_in.cands[D.45461][0].ready;
  D.45622 = D.45621 + 1;
  engine->ice_in.cands[D.45461][0].ready = D.45622;
  D.45461 = engine->ice_in.chosen[0];
  D.45729 = engine->ice_in.cands[D.45461][0].con_port;
  engine->remote_rtp_ice_port = D.45729;
  D.45467 = smh->session;
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  D.45738 = switch_core_perform_session_strdup (D.45467, D.45726, "src/switch_core_media.c", &__func__, 2716);
  engine->remote_rtp_ice_addr = D.45738;
  D.45527 = engine->cur_payload_map;
  D.45467 = smh->session;
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  D.45739 = switch_core_perform_session_strdup (D.45467, D.45726, "src/switch_core_media.c", &__func__, 2718);
  D.45527->remote_sdp_ip = D.45739;
  D.45527 = engine->cur_payload_map;
  D.45461 = engine->ice_in.chosen[0];
  D.45729 = engine->ice_in.cands[D.45461][0].con_port;
  D.45527->remote_sdp_port = D.45729;
  D.45740 = engine->remote_rtcp_port;
  if (D.45740 != 0)
    goto <bb 151>;
  else
    goto <bb 152>;

<bb 151>:
  D.45527 = engine->cur_payload_map;
  D.45528 = D.45527->remote_sdp_port;
  engine->remote_rtcp_port = D.45528;

<bb 152>:
  D.45527 = engine->cur_payload_map;
  D.45528 = D.45527->remote_sdp_port;
  D.45743 = (int) D.45528;
  switch_snprintf (&tmp, 80, "%d", D.45743);
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  D.45527 = engine->cur_payload_map;
  D.45744 = D.45527->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.45468, "remote_media_ip", D.45744, 1);
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  switch_channel_set_variable_var_check (D.45468, "remote_media_port", &tmp, 1);

<bb 153>:
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  if (D.45693 != 0)
    goto <bb 154>;
  else
    goto <bb 158>;

<bb 154>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 155>;
  else
    goto <bb 156>;

<bb 155>:
  iftmp.115 = "video";
  goto <bb 157>;

<bb 156>:
  iftmp.115 = "audio";

<bb 157>:
  D.45464 = engine->ice_in.chosen[1];
  D.45692 = engine->ice_in.cands[D.45464][1].con_addr;
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  D.45694 = (int) D.45693;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2730, D.45467, 5, "setting remote rtcp %s addr to %s:%d based on candidate\n", iftmp.115, D.45692, D.45694);
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  engine->remote_rtcp_ice_port = D.45693;
  D.45467 = smh->session;
  D.45464 = engine->ice_in.chosen[1];
  D.45692 = engine->ice_in.cands[D.45464][1].con_addr;
  D.45751 = switch_core_perform_session_strdup (D.45467, D.45692, "src/switch_core_media.c", &__func__, 2734);
  engine->remote_rtcp_ice_addr = D.45751;
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  engine->remote_rtcp_port = D.45693;

<bb 158>:
  D.45752 = m != 0B;
  D.45753 = got_rtcp_mux == 0;
  D.45754 = D.45752 && D.45753;
  if (D.45754 != 0)
    goto <bb 159>;
  else
    goto <bb 160>;

<bb 159>:
  engine->rtcp_mux = -1;

<bb 160>:
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  D.45757 = switch_channel_test_flag (D.45468, 103);
  if (D.45757 != 0)
    goto <bb 161>;
  else
    goto <bb 210>;

<bb 161>:
  D.45519 = engine->rtp_session;
  D.45760 = switch_rtp_ready (D.45519);
  if (D.45760 != 0)
    goto <bb 162>;
  else
    goto <bb 170>;

<bb 162>:
  D.45461 = engine->ice_in.chosen[0];
  D.45621 = engine->ice_in.cands[D.45461][0].ready;
  if (D.45621 != 0)
    goto <bb 163>;
  else
    goto <bb 170>;

<bb 163>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 164>;
  else
    goto <bb 165>;

<bb 164>:
  iftmp.116 = "video";
  goto <bb 166>;

<bb 165>:
  iftmp.116 = "audio";

<bb 166>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2749, D.45467, 6, "RE-Activating %s ICE\n", iftmp.116);
  D.45519 = engine->rtp_session;
  D.45721 = engine->ice_in.ufrag;
  D.45769 = engine->ice_out.ufrag;
  D.45770 = engine->ice_out.pwd;
  D.45724 = engine->ice_in.pwd;
  D.45467 = smh->session;
  D.45772 = switch_ice_direction (D.45467);
  if (D.45772 == 1)
    goto <bb 167>;
  else
    goto <bb 168>;

<bb 167>:
  iftmp.117 = 2;
  goto <bb 169>;

<bb 168>:
  iftmp.117 = 6;

<bb 169>:
  D.45776 = &engine->ice_in;
  switch_rtp_activate_ice (D.45519, D.45721, D.45769, D.45770, D.45724, 0, iftmp.117, D.45776);

<bb 170>:
  D.45519 = engine->rtp_session;
  if (D.45519 != 0B)
    goto <bb 171>;
  else
    goto <bb 195>;

<bb 171>:
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  if (type == 1)
    goto <bb 172>;
  else
    goto <bb 173>;

<bb 172>:
  iftmp.118 = "rtcp_video_interval_msec";
  goto <bb 174>;

<bb 173>:
  iftmp.118 = "rtcp_audio_interval_msec";

<bb 174>:
  val = switch_channel_get_variable_dup (D.45468, iftmp.118, 1, -1);
  if (val != 0B)
    goto <bb 179>;
  else
    goto <bb 175>;

<bb 175>:
  if (type == 1)
    goto <bb 176>;
  else
    goto <bb 177>;

<bb 176>:
  D.45789 = smh->mparams;
  iftmp.119 = D.45789->rtcp_video_interval_msec;
  goto <bb 178>;

<bb 177>:
  D.45789 = smh->mparams;
  iftmp.119 = D.45789->rtcp_audio_interval_msec;

<bb 178>:
  val = iftmp.119;
  if (val != 0B)
    goto <bb 179>;
  else
    goto <bb 195>;

<bb 179>:
  D.45467 = smh->session;
  D.45468 = D.45467->channel;
  if (type == 1)
    goto <bb 180>;
  else
    goto <bb 181>;

<bb 180>:
  iftmp.120 = "rtp_remote_video_rtcp_port";
  goto <bb 182>;

<bb 181>:
  iftmp.120 = "rtp_remote_audio_rtcp_port";

<bb 182>:
  rport = switch_channel_get_variable_dup (D.45468, iftmp.120, 1, -1);
  remote_rtcp_port = engine->remote_rtcp_port;
  D.45795 = remote_rtcp_port == 0;
  D.45796 = rport != 0B;
  D.45797 = D.45795 && D.45796;
  if (D.45797 != 0)
    goto <bb 183>;
  else
    goto <bb 184>;

<bb 183>:
  D.45800 = atoi (rport);
  remote_rtcp_port = (switch_port_t) D.45800;

<bb 184>:
  D.45801 = strcasecmp (val, "passthru");
  if (D.45801 == 0)
    goto <bb 185>;
  else
    goto <bb 189>;

<bb 185>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 186>;
  else
    goto <bb 187>;

<bb 186>:
  iftmp.121 = "video";
  goto <bb 188>;

<bb 187>:
  iftmp.121 = "audio";

<bb 188>:
  D.45808 = (int) remote_rtcp_port;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2787, D.45467, 6, "Activating %s RTCP PASSTHRU PORT %d\n", iftmp.121, D.45808);
  D.45519 = engine->rtp_session;
  D.45809 = engine->rtcp_mux;
  D.45810 = D.45809 > 0;
  switch_rtp_activate_rtcp (D.45519, -1, remote_rtcp_port, D.45810);
  goto <bb 195>;

<bb 189>:
  interval = atoi (val);
  interval.122 = (unsigned int) interval;
  D.45813 = interval.122 + 4294967196;
  if (D.45813 > 499900)
    goto <bb 190>;
  else
    goto <bb 191>;

<bb 190>:
  D.45467 = smh->session;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2793, D.45467, 3, "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);
  interval = 10000;

<bb 191>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 192>;
  else
    goto <bb 193>;

<bb 192>:
  iftmp.123 = "video";
  goto <bb 194>;

<bb 193>:
  iftmp.123 = "audio";

<bb 194>:
  D.45808 = (int) remote_rtcp_port;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2798, D.45467, 6, "Activating %s RTCP PORT %d\n", iftmp.123, D.45808);
  D.45519 = engine->rtp_session;
  D.45809 = engine->rtcp_mux;
  D.45810 = D.45809 > 0;
  switch_rtp_activate_rtcp (D.45519, interval, remote_rtcp_port, D.45810);

<bb 195>:
  D.45464 = engine->ice_in.chosen[1];
  D.45639 = engine->ice_in.cands[D.45464][1].ready;
  if (D.45639 != 0)
    goto <bb 196>;
  else
    goto <bb 210>;

<bb 196>:
  D.45809 = engine->rtcp_mux;
  if (D.45809 > 0)
    goto <bb 197>;
  else
    goto <bb 203>;

<bb 197>:
  D.45464 = engine->ice_in.chosen[1];
  D.45692 = engine->ice_in.cands[D.45464][1].con_addr;
  D.45461 = engine->ice_in.chosen[0];
  D.45726 = engine->ice_in.cands[D.45461][0].con_addr;
  D.38904 = __builtin_strcmp (D.45692, D.45726);
  if (D.38904 == 0)
    goto <bb 198>;
  else
    goto <bb 203>;

<bb 198>:
  D.45464 = engine->ice_in.chosen[1];
  D.45693 = engine->ice_in.cands[D.45464][1].con_port;
  D.45461 = engine->ice_in.chosen[0];
  D.45729 = engine->ice_in.cands[D.45461][0].con_port;
  if (D.45693 == D.45729)
    goto <bb 199>;
  else
    goto <bb 203>;

<bb 199>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 200>;
  else
    goto <bb 201>;

<bb 200>:
  iftmp.124 = "video";
  goto <bb 202>;

<bb 201>:
  iftmp.124 = "audio";

<bb 202>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2806, D.45467, 6, "Skipping %s RTCP ICE (Same as RTP)\n", iftmp.124);
  goto <bb 210>;

<bb 203>:
  D.45467 = smh->session;
  if (type == 1)
    goto <bb 204>;
  else
    goto <bb 205>;

<bb 204>:
  iftmp.125 = "video";
  goto <bb 206>;

<bb 205>:
  iftmp.125 = "audio";

<bb 206>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2808, D.45467, 6, "Activating %s RTCP ICE\n", iftmp.125);
  D.45519 = engine->rtp_session;
  D.45721 = engine->ice_in.ufrag;
  D.45769 = engine->ice_out.ufrag;
  D.45770 = engine->ice_out.pwd;
  D.45724 = engine->ice_in.pwd;
  D.45467 = smh->session;
  D.45836 = switch_ice_direction (D.45467);
  if (D.45836 == 1)
    goto <bb 207>;
  else
    goto <bb 208>;

<bb 207>:
  iftmp.126 = 2;
  goto <bb 209>;

<bb 208>:
  iftmp.126 = 6;

<bb 209>:
  D.45776 = &engine->ice_in;
  switch_rtp_activate_ice (D.45519, D.45721, D.45769, D.45770, D.45724, 1, iftmp.126, D.45776);

<bb 210>:
  return;

}



;; Function switch_core_session_set_ice (switch_core_session_set_ice)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[28] = "switch_core_session_set_ice"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       7 (fallthru)
<bb 5>:
goto <bb 7>;


switch_core_session_set_ice (struct switch_core_session_t * session)
{
  static const char __PRETTY_FUNCTION__[28] = "switch_core_session_set_ice";
  struct switch_media_handle_t * smh;
  struct switch_core_media_params_t * D.45846;
  struct switch_channel_t * D.45845;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2840, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

<bb 5>:
  D.45845 = session->channel;
  switch_channel_set_flag_value (D.45845, 110, 1);
  D.45845 = session->channel;
  switch_channel_set_flag_value (D.45845, 106, 1);
  D.45845 = session->channel;
  switch_channel_set_flag_value (D.45845, 108, 1);
  D.45846 = smh->mparams;
  D.45846->rtcp_audio_interval_msec = "10000";
  D.45846 = smh->mparams;
  D.45846->rtcp_video_interval_msec = "10000";

<bb 6>:
  return;

}



;; Function switch_ice_direction (switch_ice_direction)

Scope blocks:

{ Scope block #0 
  switch_call_direction_t r; (unused)

}
Merging blocks 8 and 9
switch_ice_direction (struct switch_core_session_t * session)
{
  switch_call_direction_t r;
  switch_call_direction_t D.45860;
  uint32_t D.45857;
  uint32_t D.45856;
  uint32_t D.45854;
  uint32_t D.45849;
  struct switch_channel_t * D.45848;

<bb 2>:
  D.45848 = session->channel;
  r = switch_channel_direction (D.45848);
  D.45848 = session->channel;
  D.45849 = switch_channel_test_flag (D.45848, 112);
  if (D.45849 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  r = r == 0;

<bb 4>:
  D.45848 = session->channel;
  D.45854 = switch_channel_test_flag (D.45848, 103);
  if (D.45854 != 0)
    goto <bb 6>;
  else
    goto <bb 5>;

<bb 5>:
  D.45848 = session->channel;
  D.45856 = switch_channel_test_flag (D.45848, 84);
  if (D.45856 != 0)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 6>:
  D.45848 = session->channel;
  D.45857 = switch_channel_test_flag (D.45848, 106);
  if (D.45857 != 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  r = 1;

<bb 8>:
  D.45860 = r;
  return D.45860;

}



;; Function switch_core_media_check_video_codecs (switch_core_media_check_video_codecs)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_check_video_codecs"; (unused)

  { Scope block #0 
    int i; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       18 (fallthru)
<bb 5>:
goto <bb 18>;


switch_core_media_check_video_codecs (struct switch_core_session_t * session)
{
  int i;
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_check_video_codecs";
  struct switch_media_handle_t * smh;
  int D.45885;
  int D.45884;
  uint32_t D.45881;
  switch_call_direction_t D.45878;
  const switch_codec_type_t D.45875;
  const struct switch_codec_implementation_t * D.45874;
  uint32_t D.45871;
  struct switch_channel_t * D.45870;
  int D.45867;
  struct switch_core_media_params_t * D.45866;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2400, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 17>;
  else
    goto <bb 5>;

<bb 5>:
  D.45866 = smh->mparams;
  D.45867 = D.45866->num_codecs;
  if (D.45867 != 0)
    goto <bb 6>;
  else
    goto <bb 17>;

<bb 6>:
  D.45870 = session->channel;
  D.45871 = switch_channel_test_flag (D.45870, 98);
  if (D.45871 == 0)
    goto <bb 7>;
  else
    goto <bb 17>;

<bb 7>:
  smh->video_count = 0;
  i = 0;
  goto <bb 14>;

<bb 8>:
  D.45874 = smh->codecs[i];
  D.45875 = D.45874->codec_type;
  if (D.45875 == 1)
    goto <bb 9>;
  else
    goto <bb 13>;

<bb 9>:
  D.45870 = session->channel;
  D.45878 = switch_channel_direction (D.45870);
  if (D.45878 == 0)
    goto <bb 10>;
  else
    goto <bb 12>;

<bb 10>:
  D.45870 = session->channel;
  D.45881 = switch_channel_test_flag (D.45870, 114);
  if (D.45881 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  // predicted unlikely by continue predictor.
  goto <bb 13>;

<bb 12>:
  D.45884 = smh->video_count;
  D.45885 = D.45884 + 1;
  smh->video_count = D.45885;

<bb 13>:
  i = i + 1;

<bb 14>:
  D.45866 = smh->mparams;
  D.45867 = D.45866->num_codecs;
  if (D.45867 > i)
    goto <bb 8>;
  else
    goto <bb 15>;

<bb 15>:
  D.45884 = smh->video_count;
  if (D.45884 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.45870 = session->channel;
  switch_channel_set_flag_value (D.45870, 98, 1);

<bb 17>:
  return;

}



;; Function switch_core_media_add_ice_acl (switch_core_media_add_ice_acl)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_add_ice_acl"; (unused)
  static const char __func__[30] = "switch_core_media_add_ice_acl"; (unused)

}
switch_core_media_add_ice_acl (struct switch_core_session_t * session, switch_media_type_t type, const char * acl_name)
{
  static const char __func__[30] = "switch_core_media_add_ice_acl";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_add_ice_acl";
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  char * D.45900;
  int D.45899;
  int D.45896;
  unsigned int D.45895;
  struct switch_rtp_engine_t[2] * D.45894;
  switch_status_t D.45893;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2379, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.45893 = 1;
  goto <bb 9>;

<bb 6>:
  D.45894 = &smh->engines;
  D.45895 = type * 11416;
  engine = D.45894 + D.45895;
  D.45896 = engine->cand_acl_count;
  if (D.45896 <= 24)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.45896 = engine->cand_acl_count;
  D.45900 = switch_core_perform_session_strdup (session, acl_name, "src/switch_core_media.c", &__func__, 2388);
  engine->cand_acl[D.45896] = D.45900;
  D.45899 = D.45896 + 1;
  engine->cand_acl_count = D.45899;
  D.45893 = 0;
  goto <bb 9>;

<bb 8>:
  D.45893 = 1;

<bb 9>:
  return D.45893;

}



;; Function switch_core_media_set_codec (switch_core_media_set_codec)

Scope blocks:

{ Scope block #0 
  switch_status_t status; (unused)
  int resetting; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_set_codec"; (unused)
  static const char __func__[28] = "switch_core_media_set_codec"; (unused)
  void end = <<< error >>>; (unused)

}
switch_core_media_set_codec (struct switch_core_session_t * session, int force, uint32_t codec_flags)
{
  static const char __func__[28] = "switch_core_media_set_codec";
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_set_codec";
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  int resetting;
  switch_status_t status;
  switch_payload_t D.45986;
  uint8_t D.45983;
  char * D.45982;
  char * D.45981;
  switch_payload_t D.45978;
  int D.45977;
  char * D.45976;
  switch_bool_t D.45973;
  switch_status_t D.45970;
  uint32_t D.45969;
  uint32_t D.45968;
  uint8_t D.45963;
  struct switch_rtp_t * D.45962;
  const struct switch_codec_implementation_t * D.45959;
  const struct switch_codec_implementation_t * D.45956;
  switch_status_t D.45953;
  struct switch_memory_pool_t * D.45952;
  switch_status_t D.45949;
  struct switch_memory_pool_t * D.45948;
  uint32_t D.45947;
  uint32_t D.45946;
  int D.45945;
  int D.45944;
  char * D.45943;
  struct switch_codec_t * D.45942;
  switch_interval_time_t D.45941;
  int D.45940;
  struct switch_channel_t * D.45939;
  struct switch_audio_resampler_t * * D.45938;
  struct switch_audio_resampler_t * D.45935;
  struct switch_audio_resampler_t * * D.45934;
  struct switch_mutex_t * D.45933;
  struct switch_audio_resampler_t * D.45930;
  long unsigned int D.45929;
  uint32_t D.45928;
  uint32_t D.45926;
  unsigned int D.45925;
  unsigned int D.45924;
  int D.45923;
  int D.45921;
  char * D.45920;
  switch_bool_t D.45912;
  struct switch_codec_t * D.45911;
  char * D.45908;
  struct payload_map_t * D.45907;
  switch_status_t D.45906;

<bb 2>:
  status = 0;
  resetting = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2215, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.45906 = 1;
  goto <bb 42>;

<bb 6>:
  a_engine = &smh->engines;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  if (D.45908 == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2223, session, 7, "No audio codec available\n");
  status = 1;
  goto <bb 39> (end);

<bb 8>:
  D.45911 = &a_engine->read_codec;
  D.45912 = switch_core_codec_ready (D.45911);
  if (D.45912 != 0)
    goto <bb 9>;
  else
    goto <bb 20>;

<bb 9>:
  if (force == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  status = 0;
  goto <bb 39> (end);

<bb 11>:
  D.45920 = a_engine->read_impl.iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45921 = strcasecmp (D.45920, D.45908);
  if (D.45921 != 0)
    goto <bb 14>;
  else
    goto <bb 12>;

<bb 12>:
  D.45923 = a_engine->read_impl.microseconds_per_packet;
  D.45924 = (unsigned int) D.45923;
  D.45925 = D.45924 / 1000;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  if (D.45925 != D.45926)
    goto <bb 14>;
  else
    goto <bb 13>;

<bb 13>:
  D.45928 = a_engine->read_impl.samples_per_second;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  if (D.45928 != D.45929)
    goto <bb 14>;
  else
    goto <bb 19>;

<bb 14>:
  D.45930 = session->read_resampler;
  if (D.45930 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.45933 = session->resample_mutex;
  switch_mutex_lock (D.45933);
  D.45934 = &session->read_resampler;
  switch_resample_destroy (D.45934);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2238, session, 5, "Deactivating read resampler\n");
  D.45933 = session->resample_mutex;
  switch_mutex_unlock (D.45933);

<bb 16>:
  D.45935 = session->write_resampler;
  if (D.45935 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.45933 = session->resample_mutex;
  switch_mutex_lock (D.45933);
  D.45938 = &session->write_resampler;
  switch_resample_destroy (D.45938);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2245, session, 5, "Deactivating write resampler\n");
  D.45933 = session->resample_mutex;
  switch_mutex_unlock (D.45933);

<bb 18>:
  switch_core_session_reset (session, 0, 0);
  D.45939 = session->channel;
  switch_channel_perform_audio_sync (D.45939, "src/switch_core_media.c", &__func__, 2250);
  D.45920 = a_engine->read_impl.iananame;
  D.45923 = a_engine->read_impl.microseconds_per_packet;
  D.45940 = D.45923 / 1000;
  D.45928 = a_engine->read_impl.samples_per_second;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2252, session, 7, "Changing Codec from %s@%dms@%dhz to %s@%dms@%luhz\n", D.45920, D.45940, D.45928, D.45908, D.45926, D.45929);
  D.45923 = a_engine->read_impl.microseconds_per_packet;
  D.45941 = (switch_interval_time_t) D.45923;
  switch_sleep (D.45941);
  switch_core_session_lock_codec_write (session);
  switch_core_session_lock_codec_read (session);
  resetting = 1;
  D.45923 = a_engine->read_impl.microseconds_per_packet;
  D.45941 = (switch_interval_time_t) D.45923;
  switch_sleep (D.45941);
  D.45911 = &a_engine->read_codec;
  switch_core_codec_destroy (D.45911);
  D.45942 = &a_engine->write_codec;
  switch_core_codec_destroy (D.45942);
  D.45939 = session->channel;
  switch_channel_perform_audio_sync (D.45939, "src/switch_core_media.c", &__func__, 2269);
  goto <bb 20>;

<bb 19>:
  D.45920 = a_engine->read_impl.iananame;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2271, session, 7, "Already using %s\n", D.45920);
  status = 0;
  goto <bb 39> (end);

<bb 20>:
  D.45911 = &a_engine->read_codec;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45943 = D.45907->rm_fmtp;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  D.45944 = (int) D.45926;
  D.45907 = a_engine->cur_payload_map;
  D.45945 = D.45907->channels;
  D.45907 = a_engine->cur_payload_map;
  D.45946 = D.45907->bitrate;
  D.45947 = codec_flags | 3;
  D.45948 = switch_core_session_get_pool (session);
  D.45949 = switch_core_codec_init_with_bitrate (D.45911, D.45908, D.45943, D.45929, D.45944, D.45945, D.45946, D.45947, 0B, D.45948);
  if (D.45949 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2285, session, 3, "Can\'t load codec?\n");
  D.45939 = session->channel;
  switch_channel_perform_hangup (D.45939, "src/switch_core_media.c", &__func__, 2286, 88);
  status = 1;
  goto <bb 39> (end);

<bb 22>:
  a_engine->read_codec.session = session;
  D.45942 = &a_engine->write_codec;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45943 = D.45907->rm_fmtp;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  D.45944 = (int) D.45926;
  D.45907 = a_engine->cur_payload_map;
  D.45945 = D.45907->channels;
  D.45907 = a_engine->cur_payload_map;
  D.45946 = D.45907->bitrate;
  D.45947 = codec_flags | 3;
  D.45952 = switch_core_session_get_pool (session);
  D.45953 = switch_core_codec_init_with_bitrate (D.45942, D.45908, D.45943, D.45929, D.45944, D.45945, D.45946, D.45947, 0B, D.45952);
  if (D.45953 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2302, session, 3, "Can\'t load codec?\n");
  D.45939 = session->channel;
  switch_channel_perform_hangup (D.45939, "src/switch_core_media.c", &__func__, 2303, 88);
  status = 1;
  goto <bb 39> (end);

<bb 24>:
  a_engine->write_codec.session = session;
  D.45939 = session->channel;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  switch_channel_set_variable_var_check (D.45939, "rtp_use_codec_name", D.45908, 1);
  D.45939 = session->channel;
  D.45907 = a_engine->cur_payload_map;
  D.45943 = D.45907->rm_fmtp;
  switch_channel_set_variable_var_check (D.45939, "rtp_use_codec_fmtp", D.45943, 1);
  D.45939 = session->channel;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  switch_channel_set_variable_printf (D.45939, "rtp_use_codec_rate", "%d", D.45929);
  D.45939 = session->channel;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  switch_channel_set_variable_printf (D.45939, "rtp_use_codec_ptime", "%d", D.45926);
  D.45939 = session->channel;
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  switch_channel_set_variable_printf (D.45939, "rtp_last_audio_codec_string", "%s@%dh@%di", D.45908, D.45929, D.45926);
  D.45956 = a_engine->read_codec.implementation;
  if (D.45956 == 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  __assert_fail ("a_engine->read_codec.implementation", "src/switch_core_media.c", 2316, &__PRETTY_FUNCTION__);

<bb 26>:
  D.45959 = a_engine->write_codec.implementation;
  if (D.45959 == 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  __assert_fail ("a_engine->write_codec.implementation", "src/switch_core_media.c", 2317, &__PRETTY_FUNCTION__);

<bb 28>:
  D.45956 = a_engine->read_codec.implementation;
  a_engine->read_impl = *D.45956;
  D.45959 = a_engine->write_codec.implementation;
  a_engine->write_impl = *D.45959;
  D.45956 = a_engine->read_codec.implementation;
  switch_core_session_set_read_impl (session, D.45956);
  D.45959 = a_engine->write_codec.implementation;
  switch_core_session_set_write_impl (session, D.45959);
  D.45962 = a_engine->rtp_session;
  D.45963 = switch_rtp_ready (D.45962);
  if (D.45963 != 0)
    goto <bb 29>;
  else
    goto <bb 33>;

<bb 29>:
  D.45956 = a_engine->read_codec.implementation;
  if (D.45956 == 0B)
    goto <bb 30>;
  else
    goto <bb 31>;

<bb 30>:
  __assert_fail ("a_engine->read_codec.implementation", "src/switch_core_media.c", 2326, &__PRETTY_FUNCTION__);

<bb 31>:
  D.45962 = a_engine->rtp_session;
  D.45923 = a_engine->read_impl.microseconds_per_packet;
  D.45968 = (uint32_t) D.45923;
  D.45969 = a_engine->read_impl.samples_per_packet;
  D.45970 = switch_rtp_change_interval (D.45962, D.45968, D.45969);
  if (D.45970 != 0)
    goto <bb 32>;
  else
    goto <bb 33>;

<bb 32>:
  D.45939 = session->channel;
  switch_channel_perform_hangup (D.45939, "src/switch_core_media.c", &__func__, 2331, 27);
  status = 1;
  goto <bb 39> (end);

<bb 33>:
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  a_engine->read_frame.rate = D.45929;
  D.45911 = &a_engine->read_codec;
  D.45973 = switch_core_codec_ready (D.45911);
  if (D.45973 == 0)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2339, session, 3, "Can\'t load codec?\n");
  status = 1;
  goto <bb 39> (end);

<bb 35>:
  D.45939 = session->channel;
  D.45976 = switch_channel_get_name (D.45939);
  D.45907 = a_engine->cur_payload_map;
  D.45908 = D.45907->iananame;
  D.45907 = a_engine->cur_payload_map;
  D.45929 = D.45907->rm_rate;
  D.45907 = a_engine->cur_payload_map;
  D.45926 = D.45907->codec_ms;
  D.45969 = a_engine->read_impl.samples_per_packet;
  D.45977 = a_engine->read_impl.bits_per_second;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2343, session, 7, "Set Codec %s %s/%ld %d ms %d samples %d bits\n", D.45976, D.45908, D.45929, D.45926, D.45969, D.45977);
  D.45911 = &a_engine->read_codec;
  a_engine->read_frame.codec = D.45911;
  D.45907 = a_engine->cur_payload_map;
  D.45978 = D.45907->agreed_pt;
  a_engine->write_codec.agreed_pt = D.45978;
  D.45907 = a_engine->cur_payload_map;
  D.45978 = D.45907->agreed_pt;
  a_engine->read_codec.agreed_pt = D.45978;
  if (force != 2)
    goto <bb 36>;
  else
    goto <bb 37>;

<bb 36>:
  D.45911 = &a_engine->read_codec;
  switch_core_session_set_real_read_codec (session, D.45911);
  D.45942 = &a_engine->write_codec;
  switch_core_session_set_write_codec (session, D.45942);

<bb 37>:
  D.45907 = a_engine->cur_payload_map;
  D.45981 = a_engine->write_codec.fmtp_out;
  D.45982 = switch_core_perform_session_strdup (session, D.45981, "src/switch_core_media.c", &__func__, 2357);
  D.45907->fmtp_out = D.45982;
  D.45962 = a_engine->rtp_session;
  D.45983 = switch_rtp_ready (D.45962);
  if (D.45983 != 0)
    goto <bb 38>;
  else
    goto <bb 39> (end);

<bb 38>:
  D.45962 = a_engine->rtp_session;
  D.45907 = a_engine->cur_payload_map;
  D.45986 = D.45907->pt;
  switch_rtp_set_default_payload (D.45962, D.45986);

end:
  if (resetting != 0)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  switch_core_session_unlock_codec_write (session);
  switch_core_session_unlock_codec_read (session);

<bb 41>:
  D.45906 = status;

<bb 42>:
  return D.45906;

}



;; Function switch_core_media_set_video_codec (switch_core_media_set_video_codec)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_set_video_codec"; (unused)
  static const char __func__[34] = "switch_core_media_set_video_codec"; (unused)

  { Scope block #0 
    struct switch_core_session_message_t msg; (unused)

  }

}
switch_core_media_set_video_codec (struct switch_core_session_t * session, int force)
{
  struct switch_core_session_message_t msg;
  static const char __func__[34] = "switch_core_media_set_video_codec";
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_set_video_codec";
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  uint8_t D.46034;
  struct switch_rtp_t * D.46033;
  switch_payload_t D.46032;
  char * D.46031;
  char * D.46030;
  uint32_t D.46029;
  char * D.46028;
  struct switch_channel_t * D.46027;
  switch_status_t D.46024;
  struct switch_memory_pool_t * D.46023;
  switch_status_t D.46020;
  struct switch_memory_pool_t * D.46019;
  char * D.46018;
  struct switch_codec_t * D.46017;
  long unsigned int D.46016;
  const uint32_t D.46015;
  int D.46013;
  char * D.46012;
  struct payload_map_t * D.46011;
  char * const D.46010;
  switch_bool_t D.46002;
  struct switch_codec_t * D.46001;
  const struct switch_codec_implementation_t * D.45998;
  uint8_t D.45995;
  switch_status_t D.45994;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2109, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.45994 = 1;
  goto <bb 23>;

<bb 6>:
  v_engine = &smh->engines[1];
  D.45995 = v_engine->codec_negotiated;
  if (D.45995 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.45994 = 1;
  goto <bb 23>;

<bb 8>:
  D.45998 = v_engine->read_codec.implementation;
  if (D.45998 != 0B)
    goto <bb 9>;
  else
    goto <bb 16>;

<bb 9>:
  D.46001 = &v_engine->read_codec;
  D.46002 = switch_core_codec_ready (D.46001);
  if (D.46002 != 0)
    goto <bb 10>;
  else
    goto <bb 16>;

<bb 10>:
  if (force == 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.45994 = 0;
  goto <bb 23>;

<bb 12>:
  D.45998 = v_engine->read_codec.implementation;
  D.46010 = D.45998->iananame;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  D.46013 = strcasecmp (D.46010, D.46012);
  if (D.46013 != 0)
    goto <bb 14>;
  else
    goto <bb 13>;

<bb 13>:
  D.45998 = v_engine->read_codec.implementation;
  D.46015 = D.45998->samples_per_second;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  if (D.46015 != D.46016)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.45998 = v_engine->read_codec.implementation;
  D.46010 = D.45998->iananame;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2128, session, 7, "Changing Codec from %s to %s\n", D.46010, D.46012);
  D.46001 = &v_engine->read_codec;
  switch_core_codec_destroy (D.46001);
  D.46017 = &v_engine->write_codec;
  switch_core_codec_destroy (D.46017);
  goto <bb 16>;

<bb 15>:
  D.45998 = v_engine->read_codec.implementation;
  D.46010 = D.45998->iananame;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2133, session, 7, "Already using %s\n", D.46010);
  D.45994 = 0;
  goto <bb 23>;

<bb 16>:
  D.46001 = &v_engine->read_codec;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  D.46011 = v_engine->cur_payload_map;
  D.46018 = D.46011->rm_fmtp;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  D.46019 = switch_core_session_get_pool (session);
  D.46020 = switch_core_codec_init_with_bitrate (D.46001, D.46012, D.46018, D.46016, 0, 1, 0, 3, 0B, D.46019);
  if (D.46020 != 0)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2149, session, 3, "Can\'t load codec?\n");
  D.45994 = 1;
  goto <bb 23>;

<bb 18>:
  D.46017 = &v_engine->write_codec;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  D.46011 = v_engine->cur_payload_map;
  D.46018 = D.46011->rm_fmtp;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  D.46023 = switch_core_session_get_pool (session);
  D.46024 = switch_core_codec_init_with_bitrate (D.46017, D.46012, D.46018, D.46016, 0, 1, 0, 3, 0B, D.46023);
  if (D.46024 != 0)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2160, session, 3, "Can\'t load codec?\n");
  D.45994 = 1;
  goto <bb 23>;

<bb 20>:
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  v_engine->read_frame.rate = D.46016;
  D.46027 = session->channel;
  D.46028 = switch_channel_get_name (D.46027);
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  D.46011 = v_engine->cur_payload_map;
  D.46029 = D.46011->codec_ms;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 2164, session, 7, "Set VIDEO Codec %s %s/%ld %d ms\n", D.46028, D.46012, D.46016, D.46029);
  D.46001 = &v_engine->read_codec;
  v_engine->read_frame.codec = D.46001;
  D.46030 = v_engine->write_codec.fmtp_out;
  D.46031 = switch_core_perform_session_strdup (session, D.46030, "src/switch_core_media.c", &__func__, 2169);
  v_engine->write_codec.fmtp_out = D.46031;
  D.46011 = v_engine->cur_payload_map;
  D.46032 = D.46011->agreed_pt;
  v_engine->write_codec.agreed_pt = D.46032;
  D.46011 = v_engine->cur_payload_map;
  D.46032 = D.46011->agreed_pt;
  v_engine->read_codec.agreed_pt = D.46032;
  D.46001 = &v_engine->read_codec;
  switch_core_session_set_video_read_codec (session, D.46001);
  D.46017 = &v_engine->write_codec;
  switch_core_session_set_video_write_codec (session, D.46017);
  D.46027 = session->channel;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  switch_channel_set_variable_printf (D.46027, "rtp_last_video_codec_string", "%s@%dh", D.46012, D.46016);
  D.46033 = v_engine->rtp_session;
  D.46034 = switch_rtp_ready (D.46033);
  if (D.46034 != 0)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  msg = {};
  msg.from = "src/switch_core_media.c";
  msg.message_id = 17;
  D.46033 = v_engine->rtp_session;
  D.46011 = v_engine->cur_payload_map;
  D.46032 = D.46011->agreed_pt;
  switch_rtp_set_default_payload (D.46033, D.46032);
  switch_core_session_perform_receive_message (session, &msg, "src/switch_core_media.c", &__func__, 2191);

<bb 22>:
  D.46027 = session->channel;
  D.46011 = v_engine->cur_payload_map;
  D.46012 = D.46011->rm_encoding;
  switch_channel_set_variable_var_check (D.46027, "rtp_use_video_codec_name", D.46012, 1);
  D.46027 = session->channel;
  D.46011 = v_engine->cur_payload_map;
  D.46018 = D.46011->rm_fmtp;
  switch_channel_set_variable_var_check (D.46027, "rtp_use_video_codec_fmtp", D.46018, 1);
  D.46027 = session->channel;
  D.46011 = v_engine->cur_payload_map;
  D.46016 = D.46011->rm_rate;
  switch_channel_set_variable_printf (D.46027, "rtp_use_video_codec_rate", "%d", D.46016);
  D.46027 = session->channel;
  switch_channel_set_variable_printf (D.46027, "rtp_use_video_codec_ptime", "%d", 0);
  D.45994 = 0;

<bb 23>:
  return D.45994;

}



;; Function switch_core_media_get_offered_pt (switch_core_media_get_offered_pt)

Scope blocks:

{ Scope block #0 
  int i; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_get_offered_pt"; (unused)

  { Scope block #0 
    const struct switch_codec_implementation_t * imp; (unused)

  }

}
switch_core_media_get_offered_pt (struct switch_core_session_t * session, const struct switch_codec_implementation_t * mimp, switch_payload_t * pt)
{
  const struct switch_codec_implementation_t * imp;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_get_offered_pt";
  struct switch_media_handle_t * smh;
  int i;
  int D.46055;
  struct switch_core_media_params_t * D.46054;
  switch_payload_t D.46053;
  const uint32_t D.46050;
  const uint32_t D.46049;
  int D.46046;
  char * const D.46045;
  char * const D.46044;
  switch_status_t D.46043;

<bb 2>:
  i = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 2081, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 6>;
  else
    goto <bb 5>;

<bb 5>:
  if (mimp == 0B)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.46043 = 1;
  goto <bb 14>;

<bb 7>:
  i = 0;
  goto <bb 12>;

<bb 8>:
  imp = smh->codecs[i];
  D.46044 = imp->iananame;
  D.46045 = mimp->iananame;
  D.46046 = strcasecmp (D.46044, D.46045);
  if (D.46046 == 0)
    goto <bb 9>;
  else
    goto <bb 11>;

<bb 9>:
  D.46049 = imp->actual_samples_per_second;
  D.46050 = mimp->actual_samples_per_second;
  if (D.46049 == D.46050)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.46053 = smh->ianacodes[i];
  *pt = D.46053;
  D.46043 = 0;
  goto <bb 14>;

<bb 11>:
  i = i + 1;

<bb 12>:
  D.46054 = smh->mparams;
  D.46055 = D.46054->num_codecs;
  if (D.46055 > i)
    goto <bb 8>;
  else
    goto <bb 13>;

<bb 13>:
  D.46043 = 1;

<bb 14>:
  return D.46043;

}



;; Function switch_core_media_copy_t38_options (switch_core_media_copy_t38_options)

Scope blocks:

{ Scope block #0 
  struct switch_channel_t * channel; (unused)
  struct switch_t38_options_t * local_t38_options; (unused)
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_copy_t38_options"; (unused)
  static const char __func__[35] = "switch_core_media_copy_t38_options"; (unused)

}
switch_core_media_copy_t38_options (struct switch_t38_options_t * t38_options, struct switch_core_session_t * session)
{
  static const char __func__[35] = "switch_core_media_copy_t38_options";
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_copy_t38_options";
  struct switch_t38_options_t * local_t38_options;
  struct switch_channel_t * channel;
  uint16_t D.46075;
  char * D.46074;
  const char * D.46073;
  char * D.46072;
  const char * D.46071;
  char * D.46070;
  const char * D.46069;
  uint32_t D.46068;
  uint32_t D.46067;
  char * D.46066;
  const char * D.46065;
  switch_bool_t D.46064;
  switch_bool_t D.46063;
  switch_bool_t D.46062;
  uint32_t D.46061;

<bb 2>:
  channel = switch_core_session_get_channel (session);
  local_t38_options = switch_channel_get_private (channel, "t38_options");
  if (t38_options == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("t38_options", "src/switch_core_media.c", 2052, &__PRETTY_FUNCTION__);

<bb 4>:
  if (local_t38_options == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  local_t38_options = switch_core_perform_session_alloc (session, 60, "src/switch_core_media.c", &__func__, 2055);

<bb 6>:
  D.46061 = t38_options->T38MaxBitRate;
  local_t38_options->T38MaxBitRate = D.46061;
  D.46062 = t38_options->T38FaxFillBitRemoval;
  local_t38_options->T38FaxFillBitRemoval = D.46062;
  D.46063 = t38_options->T38FaxTranscodingMMR;
  local_t38_options->T38FaxTranscodingMMR = D.46063;
  D.46064 = t38_options->T38FaxTranscodingJBIG;
  local_t38_options->T38FaxTranscodingJBIG = D.46064;
  D.46065 = t38_options->T38FaxRateManagement;
  D.46066 = switch_core_perform_session_strdup (session, D.46065, "src/switch_core_media.c", &__func__, 2062);
  local_t38_options->T38FaxRateManagement = D.46066;
  D.46067 = t38_options->T38FaxMaxBuffer;
  local_t38_options->T38FaxMaxBuffer = D.46067;
  D.46068 = t38_options->T38FaxMaxDatagram;
  local_t38_options->T38FaxMaxDatagram = D.46068;
  D.46069 = t38_options->T38FaxUdpEC;
  D.46070 = switch_core_perform_session_strdup (session, D.46069, "src/switch_core_media.c", &__func__, 2065);
  local_t38_options->T38FaxUdpEC = D.46070;
  D.46071 = t38_options->T38VendorInfo;
  D.46072 = switch_core_perform_session_strdup (session, D.46071, "src/switch_core_media.c", &__func__, 2066);
  local_t38_options->T38VendorInfo = D.46072;
  D.46073 = t38_options->remote_ip;
  D.46074 = switch_core_perform_session_strdup (session, D.46073, "src/switch_core_media.c", &__func__, 2067);
  local_t38_options->remote_ip = D.46074;
  D.46075 = t38_options->remote_port;
  local_t38_options->remote_port = D.46075;
  switch_channel_set_private (channel, "t38_options", local_t38_options);
  return;

}



;; Function switch_core_media_write_frame (switch_core_media_write_frame)

Scope blocks:

{ Scope block #0 
  switch_status_t status; (unused)
  int bytes; (unused)
  int samples; (unused)
  int frames; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_write_frame"; (unused)

}
switch_core_media_write_frame (struct switch_core_session_t * session, struct switch_frame_t * frame, switch_io_flag_t flags, int stream_id, switch_media_type_t type)
{
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_write_frame";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  int frames;
  int samples;
  int bytes;
  switch_status_t status;
  int D.46120;
  uint32_t D.46119;
  uint32_t samples.128;
  uint32_t D.46117;
  uint32_t D.46116;
  uint32_t frames.127;
  uint32_t D.46114;
  int D.46112;
  uint32_t D.46111;
  uint32_t D.46108;
  unsigned int D.46105;
  unsigned int D.46104;
  switch_bool_t D.46103;
  switch_bool_t D.46099;
  struct switch_codec_t * D.46098;
  uint8_t D.46094;
  struct switch_rtp_t * D.46093;
  const struct switch_codec_implementation_t * D.46091;
  int D.46087;
  struct switch_channel_t * D.46086;
  unsigned int D.46085;
  struct switch_rtp_engine_t[2] * D.46084;
  switch_core_media_flag_t D.46081;
  switch_status_t D.46080;

<bb 2>:
  status = 0;
  bytes = 0;
  samples = 0;
  frames = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 1996, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.46080 = 1;
  goto <bb 28>;

<bb 6>:
  D.46081 = smh->media_flags[0];
  if (D.46081 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.46080 = 1;
  goto <bb 28>;

<bb 8>:
  D.46084 = &smh->engines;
  D.46085 = type * 11416;
  engine = D.46084 + D.46085;
  goto <bb 12>;

<bb 9>:
  D.46086 = session->channel;
  D.46087 = switch_channel_test_ready (D.46086, 1, 0);
  if (D.46087 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  switch_sleep (10000);
  goto <bb 12>;

<bb 11>:
  D.46080 = 9;
  goto <bb 28>;

<bb 12>:
  D.46091 = engine->read_codec.implementation;
  if (D.46091 == 0B)
    goto <bb 9>;
  else
    goto <bb 13>;

<bb 13>:
  D.46093 = engine->rtp_session;
  D.46094 = switch_rtp_ready (D.46093);
  if (D.46094 == 0)
    goto <bb 9>;
  else
    goto <bb 14>;

<bb 14>:
  D.46091 = engine->read_codec.implementation;
  if (D.46091 == 0B)
    goto <bb 16>;
  else
    goto <bb 15>;

<bb 15>:
  D.46098 = &engine->read_codec;
  D.46099 = switch_core_codec_ready (D.46098);
  if (D.46099 == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.46080 = 9;
  goto <bb 28>;

<bb 17>:
  D.46091 = engine->read_codec.implementation;
  if (D.46091 == 0B)
    goto <bb 19>;
  else
    goto <bb 18>;

<bb 18>:
  D.46098 = &engine->read_codec;
  D.46103 = switch_core_codec_ready (D.46098);
  if (D.46103 == 0)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  D.46080 = 1;
  goto <bb 28>;

<bb 20>:
  D.46104 = BIT_FIELD_REF <*frame, 32, 480>;
  D.46105 = D.46104 & 33;
  if (D.46105 == 0)
    goto <bb 21>;
  else
    goto <bb 25>;

<bb 21>:
  D.46108 = engine->read_impl.encoded_bytes_per_packet;
  if (D.46108 != 0)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  D.46108 = engine->read_impl.encoded_bytes_per_packet;
  bytes = (int) D.46108;
  D.46111 = frame->datalen;
  D.46112 = (int) D.46111;
  frames = D.46112 / bytes;
  goto <bb 24>;

<bb 23>:
  frames = 1;

<bb 24>:
  D.46114 = engine->read_impl.samples_per_packet;
  frames.127 = (uint32_t) frames;
  D.46116 = D.46114 * frames.127;
  samples = (int) D.46116;

<bb 25>:
  D.46117 = engine->timestamp_send;
  samples.128 = (uint32_t) samples;
  D.46119 = D.46117 + samples.128;
  engine->timestamp_send = D.46119;
  D.46093 = engine->rtp_session;
  D.46120 = switch_rtp_write_frame (D.46093, frame);
  if (D.46120 < 0)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  status = 1;

<bb 27>:
  D.46080 = status;

<bb 28>:
  return D.46080;

}



;; Function switch_core_media_read_frame (switch_core_media_read_frame)

Scope blocks:

{ Scope block #0 
  struct switch_rtcp_frame_t rtcp_frame; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  switch_status_t status; (unused)
  struct switch_media_handle_t * smh; (unused)
  int do_cng; (unused)
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_read_frame"; (unused)
  static const char __func__[29] = "switch_core_media_read_frame"; (unused)
  void end = <<< error >>>; (unused)
  void skip = <<< error >>>; (unused)

  { Scope block #0 
    const char * val; (unused)
    int rtp_timeout_sec; (unused)
    int rtp_hold_timeout_sec; (unused)

    { Scope block #0 
      int v; (unused)

    }

    { Scope block #0 
      int v; (unused)

    }

  }

  { Scope block #0 
    struct switch_event_t * event; (unused)

    { Scope block #0 
      char value[30]; (unused)
      char header[50]; (unused)
      int i; (unused)
      char * uuid; (unused)

    }

  }

  { Scope block #0 
    struct switch_dtmf_t dtmf; (unused)

  }

  { Scope block #0 
    uint32_t bytes; (unused)
    int frames; (unused)

    { Scope block #0 
      uint32_t codec_ms; (unused)

    }

    { Scope block #0 
      struct payload_map_t * pmap; (unused)

    }

  }

}
Removing basic block 23
;; basic block 23, loop depth 0, count 0
;; prev block 22, next block 24
;; pred:      
;; succ:       115 (fallthru)
<bb 23>:
goto <bb 115>;


Removing basic block 29
;; basic block 29, loop depth 0, count 0
;; prev block 28, next block 30
;; pred:      
;; succ:       120 (fallthru)
<bb 29>:
goto <bb 120> (end);


Removing basic block 87
;; basic block 87, loop depth 0, count 0
;; prev block 86, next block 88
;; pred:      
;; succ:       89 (fallthru)
<bb 87>:
goto <bb 89>;


Removing basic block 114
;; basic block 114, loop depth 0, count 0
;; prev block 113, next block 115
;; pred:      
;; succ:       117 (fallthru)
<bb 114>:
goto <bb 117>;


switch_core_media_read_frame (struct switch_core_session_t * session, struct switch_frame_t * * frame, switch_io_flag_t flags, int stream_id, switch_media_type_t type)
{
  struct payload_map_t * pmap;
  uint32_t codec_ms;
  int frames;
  uint32_t bytes;
  struct switch_dtmf_t dtmf;
  char * uuid;
  int i;
  char header[50];
  char value[30];
  struct switch_event_t * event;
  int v;
  int v;
  int rtp_hold_timeout_sec;
  int rtp_timeout_sec;
  const char * val;
  static const char __func__[29] = "switch_core_media_read_frame";
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_read_frame";
  int do_cng;
  struct switch_media_handle_t * smh;
  switch_status_t status;
  struct switch_rtp_engine_t * engine;
  struct switch_rtcp_frame_t rtcp_frame;
  uint32_t D.46362;
  uint32_t frames.134;
  uint32_t D.46360;
  int D.46355;
  switch_payload_t D.46354;
  char * D.46353;
  uint8_t D.46350;
  switch_payload_t D.46347;
  struct switch_mutex_t * D.46346;
  int D.46345;
  int D.46344;
  switch_payload_t D.46341;
  switch_payload_t D.46338;
  switch_payload_t D.46335;
  switch_payload_t D.46333;
  switch_payload_t D.46331;
  switch_payload_t D.46330;
  switch_payload_t D.46328;
  struct switch_core_media_params_t * D.46327;
  uint8_t D.46324;
  int D.46317;
  int codec_ms.133;
  uint32_t D.46309;
  struct payload_map_t * D.46308;
  uint32_t D.46305;
  uint32_t D.46304;
  uint32_t D.46299;
  uint32_t D.46298;
  uint32_t D.46296;
  uint32_t D.46293;
  switch_size_t D.46292;
  switch_size_t D.46289;
  uint32_t D.46285;
  uint32_t D.46279;
  uint32_t D.46276;
  switch_core_media_flag_t D.46273;
  switch_bool_t D.46272;
  switch_frame_flag_t D.46266;
  uint32_t D.46263;
  switch_size_t D.46260;
  switch_frame_flag_t D.46257;
  switch_frame_flag_t D.46256;
  int D.46255;
  uint16_t D.46254;
  uint32_t D.46253;
  const char * restrict D.46252;
  uint32_t D.46251;
  const char * restrict D.46250;
  uint32_t D.46249;
  const char * restrict D.46248;
  uint32_t D.46247;
  const char * restrict D.46246;
  uint32_t D.46245;
  const char * restrict D.46244;
  int D.46243;
  uint8_t D.46242;
  const char * restrict D.46241;
  uint32_t D.46240;
  const char * restrict D.46239;
  switch_time_t D.46238;
  const char * restrict D.46237;
  uint32_t D.46236;
  switch_size_t D.46235;
  const char * restrict D.46234;
  uint32_t D.46233;
  uint32_t D.46232;
  uint32_t D.46231;
  uint32_t D.46230;
  uint32_t D.46229;
  const char * restrict D.46228;
  uint32_t D.46227;
  const char * restrict D.46226;
  char * D.46225;
  struct switch_event_t * event.132;
  switch_status_t D.46219;
  switch_status_t D.46216;
  uint32_t D.46213;
  uint32_t D.46212;
  uint32_t rtp_hold_timeout_sec.131;
  uint32_t D.46206;
  uint32_t D.46205;
  uint32_t D.46204;
  uint32_t D.46203;
  uint32_t rtp_timeout_sec.130;
  uint32_t D.46201;
  switch_status_t D.46188;
  uint8_t D.46182;
  uint8_t D.46179;
  uint32_t D.46178;
  void * D.46177;
  uint32_t D.46176;
  switch_frame_flag_t D.46175;
  switch_frame_flag_t D.46174;
  struct switch_frame_t * D.46173;
  const char * D.46170;
  _Bool D.46165;
  _Bool D.46164;
  _Bool D.46163;
  struct switch_frame_t * D.46162;
  char * iftmp.129;
  char * D.46157;
  switch_status_t D.46154;
  struct switch_mutex_t * D.46151;
  uint32_t D.46150;
  uint8_t D.46148;
  switch_channel_state_t D.46146;
  struct switch_channel_t * D.46145;
  struct switch_rtp_t * D.46140;
  switch_bool_t D.46139;
  struct switch_codec_t * D.46138;
  const struct switch_codec_implementation_t * D.46136;
  unsigned int D.46133;
  struct switch_rtp_engine_t[2] * D.46132;
  switch_core_media_flag_t D.46129;
  switch_status_t D.46128;

<bb 2>:
  do_cng = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 1623, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.46128 = 1;
  goto <bb 119>;

<bb 6>:
  D.46129 = smh->media_flags[0];
  if (D.46129 == 0)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.46128 = 1;
  goto <bb 119>;

<bb 8>:
  D.46132 = &smh->engines;
  D.46133 = type * 11416;
  engine = D.46132 + D.46133;
  engine->read_frame.datalen = 0;
  D.46136 = engine->read_codec.implementation;
  if (D.46136 == 0B)
    goto <bb 10>;
  else
    goto <bb 9>;

<bb 9>:
  D.46138 = &engine->read_codec;
  D.46139 = switch_core_codec_ready (D.46138);
  if (D.46139 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.46128 = 1;
  goto <bb 119>;

<bb 11>:
  D.46140 = engine->rtp_session;
  if (D.46140 == 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  __assert_fail ("engine->rtp_session != ((void *)0)", "src/switch_core_media.c", 1641, &__PRETTY_FUNCTION__);

<bb 13>:
  engine->read_frame.datalen = 0;
  D.46145 = session->channel;
  D.46146 = switch_channel_get_state (D.46145);
  if (D.46146 > 9)
    goto <bb 16>;
  else
    goto <bb 14>;

<bb 14>:
  D.46140 = engine->rtp_session;
  D.46148 = switch_rtp_ready (D.46140);
  if (D.46148 == 0)
    goto <bb 16>;
  else
    goto <bb 15>;

<bb 15>:
  D.46145 = session->channel;
  D.46150 = switch_channel_test_flag (D.46145, 45);
  if (D.46150 != 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.46128 = 1;
  goto <bb 119>;

<bb 17>:
  D.46151 = engine->read_mutex[type];
  if (D.46151 != 0B)
    goto <bb 18>;
  else
    goto <bb 111>;

<bb 18>:
  D.46151 = engine->read_mutex[type];
  D.46154 = switch_mutex_trylock (D.46151);
  if (D.46154 != 0)
    goto <bb 19>;
  else
    goto <bb 111>;

<bb 19>:
  D.46145 = session->channel;
  D.46157 = switch_channel_get_name (D.46145);
  if (type == 1)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  iftmp.129 = "video";
  goto <bb 22>;

<bb 21>:
  iftmp.129 = "audio";

<bb 22>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1650, session, 101, "%s is already being read for %s\n", D.46157, iftmp.129);
  D.46128 = 10;
  goto <bb 119>;

<bb 23>:
  engine->read_frame.flags = 0;
  D.46140 = engine->rtp_session;
  D.46162 = &engine->read_frame;
  status = switch_rtp_zerocopy_read_frame (D.46140, D.46162, flags);
  D.46163 = status != 0;
  D.46164 = status != 11;
  D.46165 = D.46163 && D.46164;
  if (D.46165 != 0)
    goto <bb 24>;
  else
    goto <bb 28>;

<bb 24>:
  if (status == 2)
    goto <bb 25>;
  else
    goto <bb 116> (end);

<bb 25>:
  D.46145 = session->channel;
  D.46170 = switch_channel_get_variable_dup (D.46145, "execute_on_media_timeout", 1, -1);
  if (D.46170 != 0B)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  D.46162 = &engine->read_frame;
  *frame = D.46162;
  D.46173 = *frame;
  D.46173 = *frame;
  D.46174 = D.46173->flags;
  D.46175 = D.46174 | 1;
  D.46173->flags = D.46175;
  D.46173 = *frame;
  D.46176 = engine->read_impl.encoded_bytes_per_packet;
  D.46173->datalen = D.46176;
  D.46173 = *frame;
  D.46177 = D.46173->data;
  D.46173 = *frame;
  D.46178 = D.46173->datalen;
  memset (D.46177, 0, D.46178);
  D.46145 = session->channel;
  switch_channel_execute_on (D.46145, "execute_on_media_timeout");
  status = 0;
  goto <bb 116> (end);

<bb 27>:
  D.46145 = session->channel;
  switch_channel_perform_hangup (D.46145, "src/switch_core_media.c", &__func__, 1674, 604);
  goto <bb 116> (end);

<bb 28>:
  D.46179 = engine->reset_codec;
  if (D.46179 != 0)
    goto <bb 29>;
  else
    goto <bb 46>;

<bb 29>:
  rtp_timeout_sec = 0;
  rtp_hold_timeout_sec = 0;
  engine->reset_codec = 0;
  D.46140 = engine->rtp_session;
  D.46182 = switch_rtp_ready (D.46140);
  if (D.46182 != 0)
    goto <bb 30>;
  else
    goto <bb 45>;

<bb 30>:
  if (type == 1)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  switch_core_media_set_video_codec (session, 1);
  goto <bb 34>;

<bb 32>:
  D.46188 = switch_core_media_set_codec (session, 1, 0);
  if (D.46188 != 0)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  *frame = 0B;
  status = 9;
  goto <bb 116> (end);

<bb 34>:
  D.46145 = session->channel;
  val = switch_channel_get_variable_dup (D.46145, "rtp_timeout_sec", 1, -1);
  if (val != 0B)
    goto <bb 35>;
  else
    goto <bb 37>;

<bb 35>:
  v = atoi (val);
  if (v >= 0)
    goto <bb 36>;
  else
    goto <bb 37>;

<bb 36>:
  rtp_timeout_sec = v;

<bb 37>:
  D.46145 = session->channel;
  val = switch_channel_get_variable_dup (D.46145, "rtp_hold_timeout_sec", 1, -1);
  if (val != 0B)
    goto <bb 38>;
  else
    goto <bb 40>;

<bb 38>:
  v = atoi (val);
  if (v >= 0)
    goto <bb 39>;
  else
    goto <bb 40>;

<bb 39>:
  rtp_hold_timeout_sec = v;

<bb 40>:
  if (rtp_timeout_sec != 0)
    goto <bb 41>;
  else
    goto <bb 43>;

<bb 41>:
  D.46201 = engine->read_impl.samples_per_second;
  rtp_timeout_sec.130 = (uint32_t) rtp_timeout_sec;
  D.46203 = D.46201 * rtp_timeout_sec.130;
  D.46204 = engine->read_impl.samples_per_packet;
  D.46205 = D.46203 / D.46204;
  engine->max_missed_packets = D.46205;
  D.46140 = engine->rtp_session;
  D.46206 = engine->max_missed_packets;
  switch_rtp_set_max_missed_packets (D.46140, D.46206);
  if (rtp_hold_timeout_sec == 0)
    goto <bb 42>;
  else
    goto <bb 43>;

<bb 42>:
  rtp_hold_timeout_sec = rtp_timeout_sec * 10;

<bb 43>:
  if (rtp_hold_timeout_sec != 0)
    goto <bb 44>;
  else
    goto <bb 45>;

<bb 44>:
  D.46201 = engine->read_impl.samples_per_second;
  rtp_hold_timeout_sec.131 = (uint32_t) rtp_hold_timeout_sec;
  D.46212 = D.46201 * rtp_hold_timeout_sec.131;
  D.46204 = engine->read_impl.samples_per_packet;
  D.46213 = D.46212 / D.46204;
  engine->max_missed_hold_packets = D.46213;

<bb 45>:
  engine->check_frames = 0;
  engine->last_ts = 0;
  do_cng = 1;

<bb 46>:
  if (do_cng != 0)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  D.46162 = &engine->read_frame;
  *frame = D.46162;
  D.46173 = *frame;
  D.46173 = *frame;
  D.46174 = D.46173->flags;
  D.46175 = D.46174 | 1;
  D.46173->flags = D.46175;
  D.46173 = *frame;
  D.46176 = engine->read_impl.encoded_bytes_per_packet;
  D.46173->datalen = D.46176;
  D.46173 = *frame;
  D.46177 = D.46173->data;
  D.46173 = *frame;
  D.46178 = D.46173->datalen;
  memset (D.46177, 0, D.46178);
  status = 0;
  goto <bb 116> (end);

<bb 48>:
  D.46140 = engine->rtp_session;
  D.46216 = switch_rtcp_zerocopy_read_frame (D.46140, &rtcp_frame);
  if (D.46216 == 0)
    goto <bb 49>;
  else
    goto <bb 56>;

<bb 49>:
  D.46219 = switch_event_create_subclass_detailed ("src/switch_core_media.c", &__func__, 1747, &event, 71, 0B);
  if (D.46219 == 0)
    goto <bb 50>;
  else
    goto <bb 56>;

<bb 50>:
  uuid = switch_core_session_get_uuid (session);
  if (uuid != 0B)
    goto <bb 51>;
  else
    goto <bb 52>;

<bb 51>:
  event.132 = event;
  D.46225 = switch_core_session_get_uuid (session);
  switch_event_add_header_string (event.132, 1, "Unique-ID", D.46225);

<bb 52>:
  D.46226 = (const char * restrict) &"%.8x"[0];
  D.46227 = rtcp_frame.ssrc;
  snprintf (&value, 30, D.46226, D.46227);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "SSRC", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46229 = rtcp_frame.ntp_msw;
  snprintf (&value, 30, D.46228, D.46229);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "NTP-Most-Significant-Word", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46230 = rtcp_frame.ntp_lsw;
  snprintf (&value, 30, D.46228, D.46230);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "NTP-Least-Significant-Word", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46231 = rtcp_frame.timestamp;
  snprintf (&value, 30, D.46228, D.46231);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "RTP-Timestamp", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46232 = rtcp_frame.packet_count;
  snprintf (&value, 30, D.46228, D.46232);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "Sender-Packet-Count", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46233 = rtcp_frame.octect_count;
  snprintf (&value, 30, D.46228, D.46233);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "Octect-Packet-Count", &value);
  D.46234 = (const char * restrict) &"%d"[0];
  D.46235 = engine->read_frame.timestamp;
  snprintf (&value, 30, D.46234, D.46235);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "Last-RTP-Timestamp", &value);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46236 = engine->read_frame.rate;
  snprintf (&value, 30, D.46228, D.46236);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "RTP-Rate", &value);
  D.46237 = (const char * restrict) &"%lld"[0];
  D.46238 = switch_time_now ();
  snprintf (&value, 30, D.46237, D.46238);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, "Capture-Time", &value);
  i = 0;
  goto <bb 54>;

<bb 53>:
  D.46239 = (const char * restrict) &"Source%u-SSRC"[0];
  snprintf (&header, 50, D.46239, i);
  D.46226 = (const char * restrict) &"%.8x"[0];
  D.46240 = rtcp_frame.reports[i].ssrc;
  snprintf (&value, 30, D.46226, D.46240);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46241 = (const char * restrict) &"Source%u-Fraction"[0];
  snprintf (&header, 50, D.46241, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46242 = rtcp_frame.reports[i].fraction;
  D.46243 = (int) D.46242;
  snprintf (&value, 30, D.46228, D.46243);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46244 = (const char * restrict) &"Source%u-Lost"[0];
  snprintf (&header, 50, D.46244, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46245 = rtcp_frame.reports[i].lost;
  snprintf (&value, 30, D.46228, D.46245);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46246 = (const char * restrict) &"Source%u-Highest-Sequence-Number-Received"[0];
  snprintf (&header, 50, D.46246, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46247 = rtcp_frame.reports[i].highest_sequence_number_received;
  snprintf (&value, 30, D.46228, D.46247);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46248 = (const char * restrict) &"Source%u-Jitter"[0];
  snprintf (&header, 50, D.46248, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46249 = rtcp_frame.reports[i].jitter;
  snprintf (&value, 30, D.46228, D.46249);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46250 = (const char * restrict) &"Source%u-LSR"[0];
  snprintf (&header, 50, D.46250, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46251 = rtcp_frame.reports[i].lsr;
  snprintf (&value, 30, D.46228, D.46251);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  D.46252 = (const char * restrict) &"Source%u-DLSR"[0];
  snprintf (&header, 50, D.46252, i);
  D.46228 = (const char * restrict) &"%u"[0];
  D.46253 = rtcp_frame.reports[i].dlsr;
  snprintf (&value, 30, D.46228, D.46253);
  event.132 = event;
  switch_event_add_header_string (event.132, 1, &header, &value);
  i = i + 1;

<bb 54>:
  D.46254 = rtcp_frame.report_count;
  D.46255 = (int) D.46254;
  if (D.46255 > i)
    goto <bb 53>;
  else
    goto <bb 55>;

<bb 55>:
  switch_event_fire_detailed ("src/switch_core_media.c", &__func__, 1809, &event, 0B);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1810, session, 110, "Dispatched RTCP event\n");

<bb 56>:
  D.46256 = engine->read_frame.flags;
  D.46257 = D.46256 & 32;
  if (D.46257 != 0)
    goto <bb 57>;
  else
    goto <bb 58>;

<bb 57>:
  D.46162 = &engine->read_frame;
  *frame = D.46162;
  status = 0;
  goto <bb 116> (end);

<bb 58>:
  D.46140 = engine->rtp_session;
  D.46260 = switch_rtp_has_dtmf (D.46140);
  if (D.46260 != 0)
    goto <bb 59>;
  else
    goto <bb 60>;

<bb 59>:
  dtmf = {};
  D.46140 = engine->rtp_session;
  switch_rtp_dequeue_dtmf (D.46140, &dtmf);
  D.46145 = session->channel;
  switch_channel_queue_dtmf (D.46145, &dtmf);

<bb 60>:
  D.46263 = engine->read_frame.datalen;
  if (D.46263 != 0)
    goto <bb 61>;
  else
    goto <bb 111>;

<bb 61>:
  bytes = 0;
  frames = 1;
  D.46256 = engine->read_frame.flags;
  D.46266 = D.46256 & 1;
  if (D.46266 == 0)
    goto <bb 62>;
  else
    goto <bb 113>;

<bb 62>:
  D.46136 = engine->read_codec.implementation;
  if (D.46136 == 0B)
    goto <bb 64>;
  else
    goto <bb 63>;

<bb 63>:
  D.46138 = &engine->read_codec;
  D.46272 = switch_core_codec_ready (D.46138);
  if (D.46272 == 0)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  *frame = 0B;
  status = 9;
  goto <bb 116> (end);

<bb 65>:
  D.46273 = smh->media_flags[2];
  if (D.46273 != 0)
    goto <bb 66>;
  else
    goto <bb 88>;

<bb 66>:
  D.46276 = engine->check_frames;
  if (D.46276 <= 49)
    goto <bb 67>;
  else
    goto <bb 88>;

<bb 67>:
  D.46276 = engine->check_frames;
  D.46279 = D.46276 + 1;
  engine->check_frames = D.46279;
  D.46176 = engine->read_impl.encoded_bytes_per_packet;
  if (D.46176 == 0)
    goto <bb 68>;
  else
    goto <bb 69>;

<bb 68>:
  engine->check_frames = 50;
  goto <bb 107> (skip);

<bb 69>:
  D.46273 = smh->media_flags[2];
  if (D.46273 != 0)
    goto <bb 70>;
  else
    goto <bb 87>;

<bb 70>:
  D.46263 = engine->read_frame.datalen;
  D.46285 = D.46263 % 10;
  if (D.46285 == 0)
    goto <bb 71>;
  else
    goto <bb 87>;

<bb 71>:
  D.46289 = engine->last_ts;
  if (D.46289 != 0)
    goto <bb 72>;
  else
    goto <bb 85>;

<bb 72>:
  D.46263 = engine->read_frame.datalen;
  D.46176 = engine->read_impl.encoded_bytes_per_packet;
  if (D.46263 != D.46176)
    goto <bb 73>;
  else
    goto <bb 85>;

<bb 73>:
  D.46235 = engine->read_frame.timestamp;
  D.46289 = engine->last_ts;
  D.46292 = D.46235 - D.46289;
  D.46201 = engine->read_impl.samples_per_second;
  D.46293 = D.46201 / 1000;
  codec_ms = D.46292 / D.46293;
  D.46296 = codec_ms % 10;
  if (D.46296 != 0)
    goto <bb 75>;
  else
    goto <bb 74>;

<bb 74>:
  D.46204 = engine->read_impl.samples_per_packet;
  D.46298 = D.46204 * 10;
  if (D.46298 < codec_ms)
    goto <bb 75>;
  else
    goto <bb 76>;

<bb 75>:
  engine->last_ts = 0;
  goto <bb 107> (skip);

<bb 76>:
  D.46299 = engine->last_codec_ms;
  if (D.46299 != 0)
    goto <bb 77>;
  else
    goto <bb 79>;

<bb 77>:
  D.46299 = engine->last_codec_ms;
  if (D.46299 == codec_ms)
    goto <bb 78>;
  else
    goto <bb 79>;

<bb 78>:
  D.46304 = engine->mismatch_count;
  D.46305 = D.46304 + 1;
  engine->mismatch_count = D.46305;

<bb 79>:
  engine->last_codec_ms = codec_ms;
  D.46304 = engine->mismatch_count;
  if (D.46304 > 5)
    goto <bb 80>;
  else
    goto <bb 86>;

<bb 80>:
  D.46308 = engine->cur_payload_map;
  D.46309 = D.46308->codec_ms;
  if (D.46309 != codec_ms)
    goto <bb 81>;
  else
    goto <bb 86>;

<bb 81>:
  if (codec_ms > 120)
    goto <bb 82>;
  else
    goto <bb 83>;

<bb 82>:
  codec_ms.133 = (int) codec_ms;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1871, session, 4, "Your phone is trying to send timestamps that suggest an increment of %dms per packet\nThat seems hard to believe so I am going to go on ahead and um ignore that, mmkay?\n", codec_ms.133);
  engine->check_frames = 50;
  goto <bb 107> (skip);

<bb 83>:
  engine->read_frame.datalen = 0;
  D.46308 = engine->cur_payload_map;
  D.46309 = D.46308->codec_ms;
  if (D.46309 != codec_ms)
    goto <bb 84>;
  else
    goto <bb 86>;

<bb 84>:
  D.46308 = engine->cur_payload_map;
  D.46309 = D.46308->codec_ms;
  D.46317 = (int) D.46309;
  codec_ms.133 = (int) codec_ms;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1882, session, 4, "Asynchronous PTIME not supported, changing our end from %d to %d\n", D.46317, codec_ms.133);
  D.46145 = session->channel;
  D.46308 = engine->cur_payload_map;
  D.46309 = D.46308->codec_ms;
  D.46317 = (int) D.46309;
  codec_ms.133 = (int) codec_ms;
  switch_channel_set_variable_printf (D.46145, "rtp_h_X-Broken-PTIME", "Adv=%d;Sent=%d", D.46317, codec_ms.133);
  D.46308 = engine->cur_payload_map;
  D.46308->codec_ms = codec_ms;
  engine->reset_codec = 2;
  goto <bb 86>;

<bb 85>:
  engine->mismatch_count = 0;

<bb 86>:
  D.46235 = engine->read_frame.timestamp;
  engine->last_ts = D.46235;
  goto <bb 88>;

<bb 87>:
  engine->mismatch_count = 0;
  engine->last_ts = 0;

<bb 88>:
  D.46179 = engine->reset_codec;
  if (D.46179 == 0)
    goto <bb 89>;
  else
    goto <bb 107> (skip);

<bb 89>:
  D.46324 = engine->codec_negotiated;
  if (D.46324 != 0)
    goto <bb 90>;
  else
    goto <bb 107> (skip);

<bb 90>:
  D.46327 = smh->mparams;
  D.46328 = D.46327->cng_pt;
  if (D.46328 == 0)
    goto <bb 92>;
  else
    goto <bb 91>;

<bb 91>:
  D.46330 = engine->read_frame.payload;
  D.46327 = smh->mparams;
  D.46328 = D.46327->cng_pt;
  if (D.46330 != D.46328)
    goto <bb 92>;
  else
    goto <bb 107> (skip);

<bb 92>:
  D.46327 = smh->mparams;
  D.46331 = D.46327->recv_te;
  if (D.46331 == 0)
    goto <bb 94>;
  else
    goto <bb 93>;

<bb 93>:
  D.46330 = engine->read_frame.payload;
  D.46327 = smh->mparams;
  D.46331 = D.46327->recv_te;
  if (D.46330 != D.46331)
    goto <bb 94>;
  else
    goto <bb 107> (skip);

<bb 94>:
  D.46327 = smh->mparams;
  D.46333 = D.46327->te;
  if (D.46333 == 0)
    goto <bb 96>;
  else
    goto <bb 95>;

<bb 95>:
  D.46330 = engine->read_frame.payload;
  D.46327 = smh->mparams;
  D.46333 = D.46327->te;
  if (D.46330 != D.46333)
    goto <bb 96>;
  else
    goto <bb 107> (skip);

<bb 96>:
  D.46330 = engine->read_frame.payload;
  D.46308 = engine->cur_payload_map;
  D.46335 = D.46308->recv_pt;
  if (D.46330 != D.46335)
    goto <bb 97>;
  else
    goto <bb 107> (skip);

<bb 97>:
  D.46330 = engine->read_frame.payload;
  D.46308 = engine->cur_payload_map;
  D.46338 = D.46308->agreed_pt;
  if (D.46330 != D.46338)
    goto <bb 98>;
  else
    goto <bb 107> (skip);

<bb 98>:
  D.46330 = engine->read_frame.payload;
  D.46308 = engine->cur_payload_map;
  D.46341 = D.46308->pt;
  if (D.46330 != D.46341)
    goto <bb 99>;
  else
    goto <bb 107> (skip);

<bb 99>:
  D.46330 = engine->read_frame.payload;
  D.46344 = (int) D.46330;
  D.46308 = engine->cur_payload_map;
  D.46338 = D.46308->agreed_pt;
  D.46345 = (int) D.46338;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1926, session, 7, "alternate payload received (received %d, expecting %d)\n", D.46344, D.46345);
  D.46346 = smh->sdp_mutex;
  switch_mutex_lock (D.46346);
  pmap = engine->payload_map;
  goto <bb 104>;

<bb 100>:
  D.46330 = engine->read_frame.payload;
  D.46347 = pmap->recv_pt;
  if (D.46330 == D.46347)
    goto <bb 101>;
  else
    goto <bb 103>;

<bb 101>:
  D.46350 = pmap->negotiated;
  if (D.46350 != 0)
    goto <bb 102>;
  else
    goto <bb 103>;

<bb 102>:
  engine->cur_payload_map = pmap;
  D.46308 = engine->cur_payload_map;
  D.46308->current = 1;
  D.46353 = pmap->iananame;
  D.46354 = pmap->pt;
  D.46355 = (int) D.46354;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1937, session, 4, "Changing current codec to %s (payload type %d).\n", D.46353, D.46355);
  engine->reset_codec = 1;
  goto <bb 105>;

<bb 103>:
  pmap = pmap->next;

<bb 104>:
  if (pmap != 0B)
    goto <bb 100>;
  else
    goto <bb 105>;

<bb 105>:
  D.46346 = smh->sdp_mutex;
  switch_mutex_unlock (D.46346);
  D.46179 = engine->reset_codec;
  if (D.46179 == 0)
    goto <bb 106>;
  else
    goto <bb 107> (skip);

<bb 106>:
  D.46330 = engine->read_frame.payload;
  D.46344 = (int) D.46330;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1949, session, 4, "Could not change to payload type %d, ignoring...\n", D.46344);

skip:
  bytes = engine->read_impl.encoded_bytes_per_packet;
  if (bytes != 0)
    goto <bb 108>;
  else
    goto <bb 109>;

<bb 108>:
  D.46263 = engine->read_frame.datalen;
  D.46360 = D.46263 / bytes;
  frames = (int) D.46360;

<bb 109>:
  D.46204 = engine->read_impl.samples_per_packet;
  frames.134 = (uint32_t) frames;
  D.46362 = D.46204 * frames.134;
  engine->read_frame.samples = D.46362;
  D.46263 = engine->read_frame.datalen;
  if (D.46263 == 0)
    goto <bb 110>;
  else
    goto <bb 113>;

<bb 110>:
  // predicted unlikely by continue predictor.

<bb 111>:
  D.46129 = smh->media_flags[0];
  if (D.46129 != 0)
    goto <bb 112>;
  else
    goto <bb 113>;

<bb 112>:
  D.46263 = engine->read_frame.datalen;
  if (D.46263 == 0)
    goto <bb 23>;
  else
    goto <bb 113>;

<bb 113>:
  D.46263 = engine->read_frame.datalen;
  if (D.46263 == 0)
    goto <bb 114>;
  else
    goto <bb 115>;

<bb 114>:
  *frame = 0B;

<bb 115>:
  D.46162 = &engine->read_frame;
  *frame = D.46162;
  status = 0;

end:
  D.46151 = engine->read_mutex[type];
  if (D.46151 != 0B)
    goto <bb 117>;
  else
    goto <bb 118>;

<bb 117>:
  D.46151 = engine->read_mutex[type];
  switch_mutex_unlock (D.46151);

<bb 118>:
  D.46128 = status;

<bb 119>:
  return D.46128;

}



;; Function switch_core_media_prepare_codecs (switch_core_media_prepare_codecs)

Scope blocks:

{ Scope block #0 
  const char * abs; (unused)
  const char * codec_string; (unused)
  const char * ocodec; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_prepare_codecs"; (unused)
  void ready = <<< error >>>; (unused)
  static const char __func__[33] = "switch_core_media_prepare_codecs"; (unused)

  { Scope block #0 
    char * tmp_codec_string; (unused)

  }

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       32 (fallthru)
<bb 5>:
goto <bb 32>;


Removing basic block 9
;; basic block 9, loop depth 0, count 0
;; prev block 8, next block 10
;; pred:      
;; succ:       32 (fallthru)
<bb 9>:
goto <bb 32>;


Removing basic block 13
;; basic block 13, loop depth 0, count 0
;; prev block 12, next block 14
;; pred:      
;; succ:       32 (fallthru)
<bb 13>:
goto <bb 32>;


switch_core_media_prepare_codecs (struct switch_core_session_t * session, switch_bool_t force)
{
  char * tmp_codec_string;
  static const char __func__[33] = "switch_core_media_prepare_codecs";
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_prepare_codecs";
  struct switch_media_handle_t * smh;
  const char * ocodec;
  const char * codec_string;
  const char * abs;
  int D.46419;
  int D.46417;
  int D.46416;
  const struct switch_codec_implementation_t *[50] * D.46415;
  int D.46414;
  unsigned int D.46413;
  char *[50] * D.46412;
  switch_core_media_flag_t D.46407;
  const char D.46398;
  struct switch_core_session_t * D.46389;
  int D.46386;
  struct switch_core_media_params_t * D.46385;
  uint32_t D.46382;
  uint32_t D.46380;
  struct switch_channel_t * D.46379;

<bb 2>:
  codec_string = 0B;
  ocodec = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 1555, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 29>;
  else
    goto <bb 5>;

<bb 5>:
  if (force == 0)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 6>:
  D.46379 = session->channel;
  D.46380 = switch_channel_test_flag (D.46379, 15);
  if (D.46380 != 0)
    goto <bb 29>;
  else
    goto <bb 7>;

<bb 7>:
  D.46379 = session->channel;
  D.46382 = switch_channel_test_flag (D.46379, 29);
  if (D.46382 != 0)
    goto <bb 29>;
  else
    goto <bb 8>;

<bb 8>:
  if (force != 0)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.46385 = smh->mparams;
  D.46385->num_codecs = 0;

<bb 10>:
  D.46385 = smh->mparams;
  D.46386 = D.46385->num_codecs;
  if (D.46386 != 0)
    goto <bb 29>;
  else
    goto <bb 11>;

<bb 11>:
  smh->payload_space = 0;
  D.46389 = smh->session;
  if (D.46389 == 0B)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  __assert_fail ("smh->session != ((void *)0)", "src/switch_core_media.c", 1575, &__PRETTY_FUNCTION__);

<bb 13>:
  D.46379 = session->channel;
  abs = switch_channel_get_variable_dup (D.46379, "absolute_codec_string", 1, -1);
  if (abs != 0B)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  codec_string = abs;
  goto <bb 26> (ready);

<bb 15>:
  D.46379 = session->channel;
  codec_string = switch_channel_get_variable_dup (D.46379, "codec_string", 1, -1);
  if (codec_string == 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.46389 = smh->session;
  codec_string = switch_core_media_get_codec_string (D.46389);

<bb 17>:
  if (codec_string != 0B)
    goto <bb 18>;
  else
    goto <bb 20>;

<bb 18>:
  D.46398 = *codec_string;
  if (D.46398 == 61)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  codec_string = codec_string + 1;
  goto <bb 26> (ready);

<bb 20>:
  D.46379 = session->channel;
  ocodec = switch_channel_get_variable_dup (D.46379, "originator_codec", 1, -1);
  if (ocodec != 0B)
    goto <bb 21>;
  else
    goto <bb 26> (ready);

<bb 21>:
  if (codec_string == 0B)
    goto <bb 23>;
  else
    goto <bb 22>;

<bb 22>:
  D.46407 = smh->media_flags[1];
  if (D.46407 != 0)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  codec_string = ocodec;
  goto <bb 26> (ready);

<bb 24>:
  D.46389 = smh->session;
  codec_string = switch_core_session_sprintf (D.46389, "%s,%s", ocodec, codec_string);
  if (codec_string == 0B)
    goto <bb 25>;
  else
    goto <bb 26> (ready);

<bb 25>:
  codec_string = ocodec;

ready:
  if (codec_string != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  D.46389 = smh->session;
  tmp_codec_string = switch_core_perform_session_strdup (D.46389, codec_string, "src/switch_core_media.c", &__func__, 1603);
  D.46379 = session->channel;
  switch_channel_set_variable_var_check (D.46379, "rtp_use_codec_string", codec_string, 1);
  D.46412 = &smh->codec_order;
  D.46413 = switch_separate_string (tmp_codec_string, 44, D.46412, 50);
  D.46414 = (int) D.46413;
  smh->codec_order_last = D.46414;
  D.46385 = smh->mparams;
  D.46415 = &smh->codecs;
  D.46412 = &smh->codec_order;
  D.46416 = smh->codec_order_last;
  D.46417 = switch_loadable_module_get_codecs_sorted (D.46415, 50, D.46412, D.46416);
  D.46385->num_codecs = D.46417;
  goto <bb 29>;

<bb 28>:
  D.46385 = smh->mparams;
  D.46415 = &smh->codecs;
  D.46419 = switch_loadable_module_get_codecs (D.46415, 50);
  D.46385->num_codecs = D.46419;

<bb 29>:
  return;

}



;; Function switch_core_media_get_mparams (switch_core_media_get_mparams)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_get_mparams"; (unused)

}
Merging blocks 4 and 5
switch_core_media_get_mparams (struct switch_media_handle_t * smh)
{
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_get_mparams";
  struct switch_core_media_params_t * D.46423;

<bb 2>:
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 1545, &__PRETTY_FUNCTION__);

<bb 4>:
  D.46423 = smh->mparams;
  return D.46423;

}



;; Function switch_core_session_clear_media_handle (switch_core_session_clear_media_handle)

Scope blocks:

{ Scope block #0 

}
switch_core_session_clear_media_handle (struct switch_core_session_t * session)
{
  switch_status_t D.46428;
  struct switch_media_handle_t * D.46425;

<bb 2>:
  D.46425 = session->media_handle;
  if (D.46425 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.46428 = 1;
  goto <bb 5>;

<bb 4>:
  D.46428 = 0;

<bb 5>:
  return D.46428;

}



;; Function switch_core_session_get_media_handle (switch_core_session_get_media_handle)

Scope blocks:

{ Scope block #0 

}
switch_core_session_get_media_handle (struct switch_core_session_t * session)
{
  struct switch_media_handle_t * D.46433;
  switch_status_t D.46430;

<bb 2>:
  D.46430 = switch_core_session_media_handle_ready (session);
  if (D.46430 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.46433 = session->media_handle;
  goto <bb 5>;

<bb 4>:
  D.46433 = 0B;

<bb 5>:
  return D.46433;

}



;; Function switch_core_session_media_handle_ready (switch_core_session_media_handle_ready)

Scope blocks:

{ Scope block #0 

}
switch_core_session_media_handle_ready (struct switch_core_session_t * session)
{
  switch_status_t D.46444;
  _Bool D.46441;
  int D.46440;
  int D.46439;
  smh_flag_t D.46438;
  struct switch_media_handle_t * D.46435;

<bb 2>:
  D.46435 = session->media_handle;
  if (D.46435 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

<bb 3>:
  D.46435 = session->media_handle;
  D.46438 = D.46435->flags;
  D.46439 = (int) D.46438;
  D.46440 = D.46439 & 1;
  D.46441 = (_Bool) D.46440;
  if (D.46441 != 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  D.46444 = 0;
  goto <bb 6>;

<bb 5>:
  D.46444 = 1;

<bb 6>:
  return D.46444;

}



;; Function switch_media_handle_test_media_flag (switch_media_handle_test_media_flag)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_test_media_flag"; (unused)

}
Merging blocks 4 and 5
switch_media_handle_test_media_flag (struct switch_media_handle_t * smh, switch_core_media_flag_t flag)
{
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_test_media_flag";
  switch_core_media_flag_t D.46449;
  int32_t D.46448;

<bb 2>:
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 1510, &__PRETTY_FUNCTION__);

<bb 4>:
  D.46449 = smh->media_flags[flag];
  D.46448 = (int32_t) D.46449;
  return D.46448;

}



;; Function switch_media_handle_clear_media_flag (switch_media_handle_clear_media_flag)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[37] = "switch_media_handle_clear_media_flag"; (unused)

}
switch_media_handle_clear_media_flag (struct switch_media_handle_t * smh, switch_core_media_flag_t flag)
{
  static const char __PRETTY_FUNCTION__[37] = "switch_media_handle_clear_media_flag";

<bb 2>:
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 1503, &__PRETTY_FUNCTION__);

<bb 4>:
  smh->media_flags[flag] = 0;
  return;

}



;; Function switch_media_handle_set_media_flags (switch_media_handle_set_media_flags)

Scope blocks:

{ Scope block #0 
  int i; (unused)
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_set_media_flags"; (unused)

}
switch_media_handle_set_media_flags (struct switch_media_handle_t * smh, switch_core_media_flag_t * flags)
{
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_set_media_flags";
  int i;
  switch_core_media_flag_t D.46458;
  switch_core_media_flag_t * D.46457;
  unsigned int D.46456;
  unsigned int i.135;

<bb 2>:
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 1491, &__PRETTY_FUNCTION__);

<bb 4>:
  i = 0;
  goto <bb 8>;

<bb 5>:
  i.135 = (unsigned int) i;
  D.46456 = i.135 * 4;
  D.46457 = flags + D.46456;
  D.46458 = *D.46457;
  if (D.46458 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  i.135 = (unsigned int) i;
  D.46456 = i.135 * 4;
  D.46457 = flags + D.46456;
  D.46458 = *D.46457;
  smh->media_flags[i] = D.46458;

<bb 7>:
  i = i + 1;

<bb 8>:
  if (i <= 16)
    goto <bb 5>;
  else
    goto <bb 9>;

<bb 9>:
  return;

}



;; Function switch_media_handle_set_media_flag (switch_media_handle_set_media_flag)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[35] = "switch_media_handle_set_media_flag"; (unused)

}
switch_media_handle_set_media_flag (struct switch_media_handle_t * smh, switch_core_media_flag_t flag)
{
  static const char __PRETTY_FUNCTION__[35] = "switch_media_handle_set_media_flag";

<bb 2>:
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 1482, &__PRETTY_FUNCTION__);

<bb 4>:
  smh->media_flags[flag] = 1;
  return;

}



;; Function switch_media_handle_create (switch_media_handle_create)

Scope blocks:

{ Scope block #0 
  switch_status_t status; (unused)
  struct switch_media_handle_t * smh; (unused)
  int i; (unused)
  static const char __func__[27] = "switch_media_handle_create"; (unused)

}
Merging blocks 15 and 16
switch_media_handle_create (struct switch_media_handle_t * * smhp, struct switch_core_session_t * session, struct switch_core_media_params_t * params)
{
  static const char __func__[27] = "switch_media_handle_create";
  int i;
  struct switch_media_handle_t * smh;
  switch_status_t status;
  switch_status_t D.46497;
  struct switch_channel_t * D.46496;
  struct payload_map_t * D.46495;
  struct payload_map_t * D.46494;
  void * D.46493;
  struct payload_map_t * D.46492;
  struct payload_map_t * D.46491;
  void * D.46490;
  struct switch_memory_pool_t * D.46489;
  unsigned int D.46488;
  unsigned int D.46487;
  unsigned int D.46486;
  time_t D.46485;
  unsigned int D.46484;
  struct switch_rtp_engine_t * D.46483;
  unsigned int D.46482;
  unsigned int D.46481;
  time_t D.46480;
  unsigned int D.46479;
  struct switch_rtp_engine_t[2] * D.46478;
  struct switch_memory_pool_t * D.46477;
  struct switch_mutex_t * * D.46476;
  struct switch_memory_pool_t * D.46475;
  struct switch_mutex_t * * D.46474;
  switch_rtp_crypto_key_type_t i.136;
  unsigned int D.46472;
  smh_flag_t D.46471;
  struct switch_media_handle_t * D.46468;
  void * D.46467;
  int D.46464;
  char * D.46463;

<bb 2>:
  status = 1;
  smh = 0B;
  *smhp = 0B;
  D.46463 = params->sdp_username;
  D.46464 = _zstr (D.46463);
  if (D.46464 != 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  params->sdp_username = "FreeSWITCH";

<bb 4>:
  D.46467 = switch_core_perform_session_alloc (session, 23856, "src/switch_core_media.c", &__func__, 1426);
  session->media_handle = D.46467;
  D.46468 = session->media_handle;
  if (D.46468 != 0B)
    goto <bb 5>;
  else
    goto <bb 15>;

<bb 5>:
  D.46468 = session->media_handle;
  D.46468->session = session;
  D.46468 = session->media_handle;
  *smhp = D.46468;
  D.46468 = session->media_handle;
  D.46468 = session->media_handle;
  D.46471 = D.46468->flags;
  D.46472 = D.46471 | 1;
  D.46468->flags = D.46472;
  D.46468 = session->media_handle;
  D.46468->media_flags[0] = 1;
  D.46468 = session->media_handle;
  D.46468->engines[0].read_frame.buflen = 16384;
  D.46468 = session->media_handle;
  D.46468->engines[0].type = 0;
  D.46468 = session->media_handle;
  D.46468->engines[0].crypto_type = 9;
  i = 0;
  goto <bb 7>;

<bb 6>:
  D.46468 = session->media_handle;
  i.136 = (switch_rtp_crypto_key_type_t) i;
  D.46468->engines[0].ssec[i].crypto_type = i.136;
  i = i + 1;

<bb 7>:
  if (i <= 8)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 8>:
  D.46468 = session->media_handle;
  D.46468->engines[1].read_frame.buflen = 16384;
  D.46468 = session->media_handle;
  D.46468->engines[1].type = 1;
  D.46468 = session->media_handle;
  D.46468->engines[1].crypto_type = 9;
  i = 0;
  goto <bb 10>;

<bb 9>:
  D.46468 = session->media_handle;
  i.136 = (switch_rtp_crypto_key_type_t) i;
  D.46468->engines[1].ssec[i].crypto_type = i.136;
  i = i + 1;

<bb 10>:
  if (i <= 8)
    goto <bb 9>;
  else
    goto <bb 11>;

<bb 11>:
  D.46468 = session->media_handle;
  D.46468->mparams = params;
  i = 0;
  goto <bb 13>;

<bb 12>:
  D.46468 = session->media_handle;
  D.46468->crypto_suite_order[i] = 9;
  i = i + 1;

<bb 13>:
  if (i <= 9)
    goto <bb 12>;
  else
    goto <bb 14>;

<bb 14>:
  D.46468 = session->media_handle;
  D.46474 = &D.46468->mutex;
  D.46475 = switch_core_session_get_pool (session);
  switch_mutex_init (D.46474, 1, D.46475);
  D.46468 = session->media_handle;
  D.46476 = &D.46468->sdp_mutex;
  D.46477 = switch_core_session_get_pool (session);
  switch_mutex_init (D.46476, 1, D.46477);
  D.46468 = session->media_handle;
  D.46468 = session->media_handle;
  D.46478 = &D.46468->engines;
  D.46479 = (unsigned int) D.46478;
  D.46480 = time (0B);
  D.46481 = (unsigned int) D.46480;
  D.46482 = D.46479 + D.46481;
  D.46468->engines[0].ssrc = D.46482;
  D.46468 = session->media_handle;
  D.46468 = session->media_handle;
  D.46483 = &D.46468->engines[1];
  D.46484 = (unsigned int) D.46483;
  D.46485 = time (0B);
  D.46486 = (unsigned int) D.46485;
  D.46487 = D.46486 / 2;
  D.46488 = D.46484 + D.46487;
  D.46468->engines[1].ssrc = D.46488;
  D.46468 = session->media_handle;
  D.46489 = session->pool;
  D.46490 = switch_core_perform_alloc (D.46489, 84, "src/switch_core_media.c", &__func__, 1464);
  D.46468->engines[0].payload_map = D.46490;
  D.46468 = session->media_handle;
  D.46468 = session->media_handle;
  D.46491 = D.46468->engines[0].payload_map;
  D.46468->engines[0].cur_payload_map = D.46491;
  D.46468 = session->media_handle;
  D.46492 = D.46468->engines[0].cur_payload_map;
  D.46492->current = 1;
  D.46468 = session->media_handle;
  D.46489 = session->pool;
  D.46493 = switch_core_perform_alloc (D.46489, 84, "src/switch_core_media.c", &__func__, 1467);
  D.46468->engines[1].payload_map = D.46493;
  D.46468 = session->media_handle;
  D.46468 = session->media_handle;
  D.46494 = D.46468->engines[1].payload_map;
  D.46468->engines[1].cur_payload_map = D.46494;
  D.46468 = session->media_handle;
  D.46495 = D.46468->engines[1].cur_payload_map;
  D.46495->current = 1;
  D.46496 = session->channel;
  switch_channel_set_flag_value (D.46496, 111, 1);
  status = 0;

<bb 15>:
  D.46497 = status;
  return D.46497;

}



;; Function switch_media_handle_destroy (switch_media_handle_destroy)

Scope blocks:

{ Scope block #0 
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_rtp_engine_t * v_engine; (unused)
  static const char __PRETTY_FUNCTION__[28] = "switch_media_handle_destroy"; (unused)

}
Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       15 (fallthru)
<bb 5>:
goto <bb 15>;


switch_media_handle_destroy (struct switch_core_session_t * session)
{
  static const char __PRETTY_FUNCTION__[28] = "switch_media_handle_destroy";
  struct switch_rtp_engine_t * v_engine;
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  switch_bool_t D.46516;
  struct switch_codec_t * D.46515;
  switch_bool_t D.46512;
  struct switch_codec_t * D.46511;
  switch_bool_t D.46508;
  struct switch_codec_t * D.46507;
  switch_bool_t D.46504;
  struct switch_codec_t * D.46503;

<bb 2>:
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 1378, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 14>;
  else
    goto <bb 5>;

<bb 5>:
  a_engine = &smh->engines;
  v_engine = &smh->engines[1];
  D.46503 = &a_engine->read_codec;
  D.46504 = switch_core_codec_ready (D.46503);
  if (D.46504 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.46503 = &a_engine->read_codec;
  switch_core_codec_destroy (D.46503);

<bb 7>:
  D.46507 = &a_engine->write_codec;
  D.46508 = switch_core_codec_ready (D.46507);
  if (D.46508 != 0)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.46507 = &a_engine->write_codec;
  switch_core_codec_destroy (D.46507);

<bb 9>:
  D.46511 = &v_engine->read_codec;
  D.46512 = switch_core_codec_ready (D.46511);
  if (D.46512 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.46511 = &v_engine->read_codec;
  switch_core_codec_destroy (D.46511);

<bb 11>:
  D.46515 = &v_engine->write_codec;
  D.46516 = switch_core_codec_ready (D.46515);
  if (D.46516 != 0)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  D.46515 = &v_engine->write_codec;
  switch_core_codec_destroy (D.46515);

<bb 13>:
  switch_core_session_unset_read_codec (session);
  switch_core_session_unset_write_codec (session);
  switch_core_media_deactivate_rtp (session);

<bb 14>:
  return;

}



;; Function switch_core_media_set_stats (switch_core_media_set_stats)

Scope blocks:

{ Scope block #0 

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       5 (fallthru)
<bb 3>:
goto <bb 5>;


switch_core_media_set_stats (struct switch_core_session_t * session)
{
  struct switch_media_handle_t * D.46520;

<bb 2>:
  D.46520 = session->media_handle;
  if (D.46520 == 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

<bb 3>:
  set_stats (session, 0, "audio");
  set_stats (session, 1, "video");

<bb 4>:
  return;

}



;; Function set_stats (set_stats)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_stats_t * stats; (unused)
  struct switch_channel_t * channel; (unused)
  char var_name[256]; (unused)
  char var_val[35]; (unused)

}
set_stats (struct switch_core_session_t * session, switch_media_type_t type, const char * prefix)
{
  char var_val[35];
  char var_name[256];
  struct switch_channel_t * channel;
  struct switch_rtp_stats_t * stats;
  uint32_t D.46662;
  const char * iftmp.163;
  uint32_t D.46657;
  const char * iftmp.162;
  switch_size_t D.46652;
  const char * iftmp.161;
  switch_size_t D.46647;
  const char * iftmp.160;
  switch_size_t D.46642;
  const char * iftmp.159;
  switch_size_t D.46637;
  const char * iftmp.158;
  switch_size_t D.46632;
  const char * iftmp.157;
  switch_size_t D.46627;
  const char * iftmp.156;
  switch_size_t D.46622;
  const char * iftmp.155;
  double D.46617;
  const char * iftmp.154;
  double D.46612;
  const char * iftmp.153;
  switch_size_t D.46607;
  const char * iftmp.152;
  double D.46602;
  const char * iftmp.151;
  double D.46597;
  const char * iftmp.150;
  double D.46592;
  const char * iftmp.149;
  double D.46587;
  const char * iftmp.148;
  double D.46582;
  const char * iftmp.147;
  switch_size_t D.46577;
  const char * iftmp.146;
  switch_size_t D.46572;
  const char * iftmp.145;
  switch_size_t D.46567;
  const char * iftmp.144;
  switch_size_t D.46562;
  const char * iftmp.143;
  switch_size_t D.46557;
  const char * iftmp.142;
  switch_size_t D.46552;
  const char * iftmp.141;
  switch_size_t D.46547;
  const char * iftmp.140;
  switch_size_t D.46542;
  const char * iftmp.139;
  switch_size_t D.46537;
  const char * iftmp.138;
  switch_size_t D.46532;
  const char * iftmp.137;
  double D.46527;
  double D.46526;

<bb 2>:
  stats = switch_core_media_get_stats (session, type, 0B);
  channel = switch_core_session_get_channel (session);
  var_name = "";
  var_val = "";
  if (stats != 0B)
    goto <bb 3>;
  else
    goto <bb 85>;

<bb 3>:
  D.46526 = stats->inbound.variance;
  D.46527 = sqrt (D.46526);
  stats->inbound.std_deviation = D.46527;
  if (prefix != 0B)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  iftmp.137 = prefix;
  goto <bb 6>;

<bb 5>:
  iftmp.137 = "";

<bb 6>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.137, "in_raw_bytes");
  D.46532 = stats->inbound.raw_bytes;
  switch_snprintf (&var_val, 35, "%d", D.46532);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  iftmp.138 = prefix;
  goto <bb 9>;

<bb 8>:
  iftmp.138 = "";

<bb 9>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.138, "in_media_bytes");
  D.46537 = stats->inbound.media_bytes;
  switch_snprintf (&var_val, 35, "%d", D.46537);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  iftmp.139 = prefix;
  goto <bb 12>;

<bb 11>:
  iftmp.139 = "";

<bb 12>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.139, "in_packet_count");
  D.46542 = stats->inbound.packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46542);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  iftmp.140 = prefix;
  goto <bb 15>;

<bb 14>:
  iftmp.140 = "";

<bb 15>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.140, "in_media_packet_count");
  D.46547 = stats->inbound.media_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46547);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  iftmp.141 = prefix;
  goto <bb 18>;

<bb 17>:
  iftmp.141 = "";

<bb 18>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.141, "in_skip_packet_count");
  D.46552 = stats->inbound.skip_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46552);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  iftmp.142 = prefix;
  goto <bb 21>;

<bb 20>:
  iftmp.142 = "";

<bb 21>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.142, "in_jitter_packet_count");
  D.46557 = stats->inbound.jb_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46557);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 22>;
  else
    goto <bb 23>;

<bb 22>:
  iftmp.143 = prefix;
  goto <bb 24>;

<bb 23>:
  iftmp.143 = "";

<bb 24>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.143, "in_dtmf_packet_count");
  D.46562 = stats->inbound.dtmf_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46562);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  iftmp.144 = prefix;
  goto <bb 27>;

<bb 26>:
  iftmp.144 = "";

<bb 27>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.144, "in_cng_packet_count");
  D.46567 = stats->inbound.cng_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46567);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 28>;
  else
    goto <bb 29>;

<bb 28>:
  iftmp.145 = prefix;
  goto <bb 30>;

<bb 29>:
  iftmp.145 = "";

<bb 30>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.145, "in_flush_packet_count");
  D.46572 = stats->inbound.flush_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46572);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  iftmp.146 = prefix;
  goto <bb 33>;

<bb 32>:
  iftmp.146 = "";

<bb 33>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.146, "in_largest_jb_size");
  D.46577 = stats->inbound.largest_jb_size;
  switch_snprintf (&var_val, 35, "%d", D.46577);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  iftmp.147 = prefix;
  goto <bb 36>;

<bb 35>:
  iftmp.147 = "";

<bb 36>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.147, "in_jitter_min_variance");
  D.46582 = stats->inbound.min_variance;
  switch_snprintf (&var_val, 35, "%0.2f", D.46582);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  iftmp.148 = prefix;
  goto <bb 39>;

<bb 38>:
  iftmp.148 = "";

<bb 39>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.148, "in_jitter_max_variance");
  D.46587 = stats->inbound.max_variance;
  switch_snprintf (&var_val, 35, "%0.2f", D.46587);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 40>;
  else
    goto <bb 41>;

<bb 40>:
  iftmp.149 = prefix;
  goto <bb 42>;

<bb 41>:
  iftmp.149 = "";

<bb 42>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.149, "in_jitter_loss_rate");
  D.46592 = stats->inbound.lossrate;
  switch_snprintf (&var_val, 35, "%0.2f", D.46592);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 43>;
  else
    goto <bb 44>;

<bb 43>:
  iftmp.150 = prefix;
  goto <bb 45>;

<bb 44>:
  iftmp.150 = "";

<bb 45>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.150, "in_jitter_burst_rate");
  D.46597 = stats->inbound.burstrate;
  switch_snprintf (&var_val, 35, "%0.2f", D.46597);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 46>;
  else
    goto <bb 47>;

<bb 46>:
  iftmp.151 = prefix;
  goto <bb 48>;

<bb 47>:
  iftmp.151 = "";

<bb 48>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.151, "in_mean_interval");
  D.46602 = stats->inbound.mean_interval;
  switch_snprintf (&var_val, 35, "%0.2f", D.46602);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 49>;
  else
    goto <bb 50>;

<bb 49>:
  iftmp.152 = prefix;
  goto <bb 51>;

<bb 50>:
  iftmp.152 = "";

<bb 51>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.152, "in_flaw_total");
  D.46607 = stats->inbound.flaws;
  switch_snprintf (&var_val, 35, "%d", D.46607);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 52>;
  else
    goto <bb 53>;

<bb 52>:
  iftmp.153 = prefix;
  goto <bb 54>;

<bb 53>:
  iftmp.153 = "";

<bb 54>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.153, "in_quality_percentage");
  D.46612 = stats->inbound.R;
  switch_snprintf (&var_val, 35, "%0.2f", D.46612);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 55>;
  else
    goto <bb 56>;

<bb 55>:
  iftmp.154 = prefix;
  goto <bb 57>;

<bb 56>:
  iftmp.154 = "";

<bb 57>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.154, "in_mos");
  D.46617 = stats->inbound.mos;
  switch_snprintf (&var_val, 35, "%0.2f", D.46617);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 58>;
  else
    goto <bb 59>;

<bb 58>:
  iftmp.155 = prefix;
  goto <bb 60>;

<bb 59>:
  iftmp.155 = "";

<bb 60>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.155, "out_raw_bytes");
  D.46622 = stats->outbound.raw_bytes;
  switch_snprintf (&var_val, 35, "%d", D.46622);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 61>;
  else
    goto <bb 62>;

<bb 61>:
  iftmp.156 = prefix;
  goto <bb 63>;

<bb 62>:
  iftmp.156 = "";

<bb 63>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.156, "out_media_bytes");
  D.46627 = stats->outbound.media_bytes;
  switch_snprintf (&var_val, 35, "%d", D.46627);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 64>;
  else
    goto <bb 65>;

<bb 64>:
  iftmp.157 = prefix;
  goto <bb 66>;

<bb 65>:
  iftmp.157 = "";

<bb 66>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.157, "out_packet_count");
  D.46632 = stats->outbound.packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46632);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 67>;
  else
    goto <bb 68>;

<bb 67>:
  iftmp.158 = prefix;
  goto <bb 69>;

<bb 68>:
  iftmp.158 = "";

<bb 69>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.158, "out_media_packet_count");
  D.46637 = stats->outbound.media_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46637);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 70>;
  else
    goto <bb 71>;

<bb 70>:
  iftmp.159 = prefix;
  goto <bb 72>;

<bb 71>:
  iftmp.159 = "";

<bb 72>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.159, "out_skip_packet_count");
  D.46642 = stats->outbound.skip_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46642);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 73>;
  else
    goto <bb 74>;

<bb 73>:
  iftmp.160 = prefix;
  goto <bb 75>;

<bb 74>:
  iftmp.160 = "";

<bb 75>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.160, "out_dtmf_packet_count");
  D.46647 = stats->outbound.dtmf_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46647);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 76>;
  else
    goto <bb 77>;

<bb 76>:
  iftmp.161 = prefix;
  goto <bb 78>;

<bb 77>:
  iftmp.161 = "";

<bb 78>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.161, "out_cng_packet_count");
  D.46652 = stats->outbound.cng_packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46652);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 79>;
  else
    goto <bb 80>;

<bb 79>:
  iftmp.162 = prefix;
  goto <bb 81>;

<bb 80>:
  iftmp.162 = "";

<bb 81>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.162, "rtcp_packet_count");
  D.46657 = stats->rtcp.packet_count;
  switch_snprintf (&var_val, 35, "%d", D.46657);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);
  if (prefix != 0B)
    goto <bb 82>;
  else
    goto <bb 83>;

<bb 82>:
  iftmp.163 = prefix;
  goto <bb 84>;

<bb 83>:
  iftmp.163 = "";

<bb 84>:
  switch_snprintf (&var_name, 256, "rtp_%s_%s", iftmp.163, "rtcp_octet_count");
  D.46662 = stats->rtcp.octet_count;
  switch_snprintf (&var_val, 35, "%d", D.46662);
  switch_channel_set_variable_var_check (channel, &var_name, &var_val, 1);

<bb 85>:
  return;

}



;; Function switch_core_session_check_outgoing_crypto (switch_core_session_check_outgoing_crypto)

Scope blocks:

{ Scope block #0 
  struct switch_channel_t * channel; (unused)
  struct switch_media_handle_t * smh; (unused)
  int i; (unused)

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       11 (fallthru)
<bb 3>:
goto <bb 11>;


Removing basic block 5
;; basic block 5, loop depth 0, count 0
;; prev block 4, next block 6
;; pred:      
;; succ:       11 (fallthru)
<bb 5>:
goto <bb 11>;


Removing basic block 7
;; basic block 7, loop depth 0, count 0
;; prev block 6, next block 8
;; pred:      
;; succ:       11 (fallthru)
<bb 7>:
goto <bb 11>;


switch_core_session_check_outgoing_crypto (struct switch_core_session_t * session)
{
  int i;
  struct switch_media_handle_t * smh;
  struct switch_channel_t * channel;
  switch_rtp_crypto_key_type_t D.46672;
  struct switch_media_handle_t * D.46671;
  switch_rtp_crypto_mode_t D.46668;
  switch_status_t D.46663;

<bb 2>:
  channel = switch_core_session_get_channel (session);
  D.46663 = switch_core_session_media_handle_ready (session);
  if (D.46663 != 0)
    goto <bb 8>;
  else
    goto <bb 3>;

<bb 3>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 8>;
  else
    goto <bb 4>;

<bb 4>:
  D.46668 = smh->crypto_mode;
  if (D.46668 > 1)
    goto <bb 8>;
  else
    goto <bb 5>;

<bb 5>:
  switch_channel_set_flag_value (channel, 92, 1);
  i = 0;
  goto <bb 7>;

<bb 6>:
  D.46671 = session->media_handle;
  D.46672 = smh->crypto_suite_order[i];
  switch_core_media_build_crypto (D.46671, 0, 0, D.46672, 0, 0);
  D.46671 = session->media_handle;
  D.46672 = smh->crypto_suite_order[i];
  switch_core_media_build_crypto (D.46671, 1, 0, D.46672, 0, 0);
  i = i + 1;

<bb 7>:
  D.46672 = smh->crypto_suite_order[i];
  if (D.46672 != 9)
    goto <bb 6>;
  else
    goto <bb 8>;

<bb 8>:
  return;

}



;; Function switch_core_media_build_crypto (switch_core_media_build_crypto)

Scope blocks:

{ Scope block #0 
  unsigned char b64_key[512]; (unused)
  unsigned char * key; (unused)
  const char * val; (unused)
  struct switch_channel_t * channel; (unused)
  char * p; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_build_crypto"; (unused)
  static const char __func__[31] = "switch_core_media_build_crypto"; (unused)

}
switch_core_media_build_crypto (struct switch_media_handle_t * smh, switch_media_type_t type, int index, switch_rtp_crypto_key_type_t ctype, switch_rtp_crypto_direction_t direction, int force)
{
  static const char __func__[31] = "switch_core_media_build_crypto";
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_build_crypto";
  struct switch_rtp_engine_t * engine;
  char * p;
  struct switch_channel_t * channel;
  const char * val;
  unsigned char * key;
  unsigned char b64_key[512];
  int D.46717;
  unsigned int D.46714;
  switch_core_media_NDLB_t D.46713;
  struct switch_core_media_params_t * D.46712;
  char * iftmp.165;
  char * iftmp.164;
  char * D.46700;
  struct switch_channel_t * D.46699;
  char * D.46698;
  char * D.46697;
  unsigned int D.46696;
  char D.46692;
  switch_size_t D.46690;
  uint32_t D.46689;
  int D.46688;
  switch_status_t D.46684;
  unsigned char D.46681;
  unsigned int D.46678;
  struct switch_rtp_engine_t[2] * D.46677;
  struct switch_core_session_t * D.46676;

<bb 2>:
  b64_key = "";
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("smh", "src/switch_core_media.c", 869, &__PRETTY_FUNCTION__);

<bb 4>:
  D.46676 = smh->session;
  channel = switch_core_session_get_channel (D.46676);
  D.46677 = &smh->engines;
  D.46678 = type * 11416;
  engine = D.46677 + D.46678;
  if (force == 0)
    goto <bb 5>;
  else
    goto <bb 7>;

<bb 5>:
  D.46681 = engine->ssec[ctype].local_raw_key[0];
  if (D.46681 != 0)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  D.46684 = 0;
  goto <bb 29>;

<bb 7>:
  if (direction == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  key = &engine->ssec[ctype].local_raw_key;
  goto <bb 10>;

<bb 9>:
  key = &engine->ssec[ctype].remote_raw_key;

<bb 10>:
  D.46688 = SUITES[ctype].keylen;
  D.46689 = (uint32_t) D.46688;
  switch_rtp_get_random (key, D.46689);
  D.46688 = SUITES[ctype].keylen;
  D.46690 = (switch_size_t) D.46688;
  switch_b64_encode (key, D.46690, &b64_key, 512);
  p = strrchr (&b64_key, 61);
  goto <bb 12>;

<bb 11>:
  *p = 0;
  p = p + -1;

<bb 12>:
  if (p != 0B)
    goto <bb 13>;
  else
    goto <bb 15>;

<bb 13>:
  D.46692 = *p;
  if (D.46692 != 0)
    goto <bb 14>;
  else
    goto <bb 15>;

<bb 14>:
  D.46692 = *p;
  if (D.46692 == 61)
    goto <bb 11>;
  else
    goto <bb 15>;

<bb 15>:
  if (index == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  D.46696 = ctype + 1;
  index = (int) D.46696;

<bb 17>:
  D.46676 = smh->session;
  D.46697 = SUITES[ctype].name;
  D.46698 = switch_core_session_sprintf (D.46676, "%d %s inline:%s", index, D.46697, &b64_key);
  engine->ssec[ctype].local_crypto_key = D.46698;
  D.46676 = smh->session;
  D.46699 = D.46676->channel;
  D.46700 = engine->ssec[ctype].local_crypto_key;
  if (type == 1)
    goto <bb 18>;
  else
    goto <bb 19>;

<bb 18>:
  iftmp.164 = "video";
  goto <bb 20>;

<bb 19>:
  iftmp.164 = "audio";

<bb 20>:
  switch_channel_set_variable_name_printf (D.46699, D.46700, "rtp_last_%s_local_crypto_key", iftmp.164);
  D.46676 = smh->session;
  D.46699 = D.46676->channel;
  switch_channel_set_flag_value (D.46699, 92, 1);
  D.46676 = smh->session;
  if (type == 1)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  iftmp.165 = "video";
  goto <bb 23>;

<bb 22>:
  iftmp.165 = "audio";

<bb 23>:
  D.46700 = engine->ssec[ctype].local_crypto_key;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 916, D.46676, 7, "Set Local %s crypto Key [%s]\n", iftmp.165, D.46700);
  D.46712 = smh->mparams;
  D.46713 = D.46712->ndlb;
  D.46714 = D.46713 & 8;
  if (D.46714 == 0)
    goto <bb 24>;
  else
    goto <bb 27>;

<bb 24>:
  val = switch_channel_get_variable_dup (channel, "NDLB_support_asterisk_missing_srtp_auth", 1, -1);
  if (val == 0B)
    goto <bb 26>;
  else
    goto <bb 25>;

<bb 25>:
  D.46717 = switch_true (val);
  if (D.46717 == 0)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  engine->ssec[ctype].crypto_type = ctype;
  goto <bb 28>;

<bb 27>:
  engine->ssec[ctype].crypto_type = 8;

<bb 28>:
  D.46684 = 0;

<bb 29>:
  return D.46684;

}



;; Function switch_core_session_check_incoming_crypto (switch_core_session_check_incoming_crypto)

Scope blocks:

{ Scope block #0 
  int got_crypto; (unused)
  int i; (unused)
  int ctype; (unused)
  const char * vval; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __func__[42] = "switch_core_session_check_incoming_crypto"; (unused)
  void end = <<< error >>>; (unused)

  { Scope block #0 
    switch_rtp_crypto_key_type_t j; (unused)

  }

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

  { Scope block #0 
    const char * a; (unused)
    const char * b; (unused)

  }

}
Removing basic block 32
;; basic block 32, loop depth 0, count 0
;; prev block 31, next block 33
;; pred:      
;; succ:       42 (fallthru)
<bb 32>:
goto <bb 42> (end);


switch_core_session_check_incoming_crypto (struct switch_core_session_t * session, const char * varname, switch_media_type_t type, const char * crypto, int crypto_tag, switch_sdp_type_t sdp_type)
{
  const char * b;
  const char * a;
  size_t __s2_len;
  size_t __s1_len;
  switch_rtp_crypto_key_type_t j;
  static const char __func__[42] = "switch_core_session_check_incoming_crypto";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  const char * vval;
  int ctype;
  int i;
  int got_crypto;
  int D.46806;
  char * D.46805;
  struct switch_channel_t * D.46804;
  struct switch_core_session_t * D.46803;
  const char * D.46802;
  const char * D.46798;
  char * D.46795;
  uint8_t D.46790;
  switch_size_t D.46789;
  int D.46788;
  unsigned char[64] * D.46787;
  uint32_t D.46786;
  int D.46785;
  struct switch_secure_settings_t * D.46784;
  unsigned int D.46783;
  struct switch_secure_settings_t[10] * D.46782;
  uint32_t D.46779;
  uint8_t D.46776;
  const char * D.46775;
  const char * D.46771;
  switch_media_type_t D.46768;
  char * D.46767;
  int D.46765;
  _Bool D.46763;
  _Bool D.46762;
  _Bool D.46761;
  switch_size_t D.46758;
  int D.46757;
  unsigned char[64] * D.46756;
  switch_rtp_crypto_key_type_t D.46755;
  uint32_t D.46754;
  int D.46753;
  switch_rtp_crypto_key_type_t ctype.166;
  int D.38621;
  uint8_t D.46741;
  struct switch_rtp_t * D.46740;
  char * D.46738;
  switch_rtp_crypto_key_type_t D.46737;
  struct switch_channel_t * D.46734;
  switch_rtp_crypto_key_type_t D.46733;
  const char * D.46730;
  char * D.46729;
  switch_rtp_crypto_key_type_t D.46728;
  unsigned int D.46727;
  struct switch_rtp_engine_t[2] * D.46726;
  struct switch_media_handle_t * D.46725;
  switch_rtp_crypto_mode_t D.46722;
  int D.46721;

<bb 2>:
  got_crypto = 0;
  i = 0;
  ctype = 0;
  vval = 0B;
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.46721 = 0;
  goto <bb 42>;

<bb 4>:
  D.46722 = smh->crypto_mode;
  if (D.46722 == 2)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.46721 = -1;
  goto <bb 42>;

<bb 6>:
  D.46725 = session->media_handle;
  D.46726 = &D.46725->engines;
  D.46727 = type * 11416;
  engine = D.46726 + D.46727;
  i = 0;
  goto <bb 10>;

<bb 7>:
  D.46728 = smh->crypto_suite_order[i];
  j = SUITES[D.46728].type;
  D.46729 = SUITES[j].name;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1179, session, 7, "looking for crypto suite [%s] in [%s]\n", D.46729, crypto);
  D.46729 = SUITES[j].name;
  D.46730 = switch_stristr (D.46729, crypto);
  if (D.46730 != 0B)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  D.46733 = SUITES[j].type;
  ctype = (int) D.46733;
  vval = SUITES[j].name;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1184, session, 7, "Found suite %s\n", vval);
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, "rtp_secure_media_negotiated", vval, 1);
  goto <bb 11>;

<bb 9>:
  i = i + 1;

<bb 10>:
  D.46728 = smh->crypto_suite_order[i];
  if (D.46728 != 9)
    goto <bb 7>;
  else
    goto <bb 11>;

<bb 11>:
  D.46737 = engine->crypto_type;
  D.46738 = engine->ssec[D.46737].remote_crypto_key;
  if (D.46738 != 0B)
    goto <bb 12>;
  else
    goto <bb 32>;

<bb 12>:
  D.46740 = engine->rtp_session;
  D.46741 = switch_rtp_ready (D.46740);
  if (D.46741 != 0)
    goto <bb 13>;
  else
    goto <bb 32>;

<bb 13>:
  if (crypto != 0B)
    goto <bb 14>;
  else
    goto <bb 17>;

<bb 14>:
  D.46737 = engine->crypto_type;
  if (D.46737 != 9)
    goto <bb 15>;
  else
    goto <bb 17>;

<bb 15>:
  D.46737 = engine->crypto_type;
  D.46738 = engine->ssec[D.46737].remote_crypto_key;
  D.38621 = __builtin_strcmp (crypto, D.46738);
  if (D.38621 == 0)
    goto <bb 16>;
  else
    goto <bb 17>;

<bb 16>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1193, session, 7, "Existing key is still valid.\n");
  got_crypto = 1;
  goto <bb 41> (end);

<bb 17>:
  D.46737 = engine->crypto_type;
  D.46738 = engine->ssec[D.46737].remote_crypto_key;
  a = switch_stristr ("AE", D.46738);
  b = switch_stristr ("AE", crypto);
  if (sdp_type == 0)
    goto <bb 18>;
  else
    goto <bb 21>;

<bb 18>:
  if (vval == 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1201, session, 7, "Unsupported Crypto [%s]\n", crypto);
  goto <bb 41> (end);

<bb 20>:
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, varname, vval, 1);
  D.46725 = session->media_handle;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  switch_core_media_build_crypto (D.46725, type, crypto_tag, ctype.166, 0, 1);
  D.46740 = engine->rtp_session;
  D.46753 = atoi (crypto);
  D.46754 = (uint32_t) D.46753;
  D.46737 = engine->crypto_type;
  D.46755 = engine->ssec[D.46737].crypto_type;
  D.46737 = engine->crypto_type;
  D.46756 = &engine->ssec[D.46737].local_raw_key;
  D.46757 = SUITES[ctype].keylen;
  D.46758 = (switch_size_t) D.46757;
  switch_rtp_add_crypto_key (D.46740, 0, D.46754, D.46755, D.46756, D.46758);

<bb 21>:
  D.46761 = a != 0B;
  D.46762 = b != 0B;
  D.46763 = D.46761 && D.46762;
  if (D.46763 != 0)
    goto <bb 22>;
  else
    goto <bb 31>;

<bb 22>:
  D.46765 = strncasecmp (a, b, 23);
  if (D.46765 == 0)
    goto <bb 23>;
  else
    goto <bb 31>;

<bb 23>:
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  engine->crypto_type = ctype.166;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1214, session, 7, "Change Remote key to [%s]\n", crypto);
  D.46737 = engine->crypto_type;
  D.46767 = switch_core_perform_session_strdup (session, crypto, "src/switch_core_media.c", &__func__, 1215);
  engine->ssec[D.46737].remote_crypto_key = D.46767;
  D.46768 = engine->type;
  if (D.46768 == 0)
    goto <bb 24>;
  else
    goto <bb 25>;

<bb 24>:
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, "srtp_remote_audio_crypto_key", crypto, 1);
  D.46734 = session->channel;
  switch_channel_set_variable_printf (D.46734, "srtp_remote_audio_crypto_tag", "%d", crypto_tag);
  D.46734 = session->channel;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  D.46771 = switch_core_media_crypto_type2str (ctype.166);
  switch_channel_set_variable_printf (D.46734, "srtp_remote_audio_crypto_type", "%s", D.46771);
  goto <bb 27>;

<bb 25>:
  D.46768 = engine->type;
  if (D.46768 == 1)
    goto <bb 26>;
  else
    goto <bb 27>;

<bb 26>:
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, "srtp_remote_video_crypto_key", crypto, 1);
  D.46734 = session->channel;
  switch_channel_set_variable_printf (D.46734, "srtp_remote_video_crypto_tag", "%d", crypto_tag);
  D.46734 = session->channel;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  D.46775 = switch_core_media_crypto_type2str (ctype.166);
  switch_channel_set_variable_printf (D.46734, "srtp_remote_video_crypto_type", "%s", D.46775);

<bb 27>:
  D.46737 = engine->crypto_type;
  engine->ssec[D.46737].crypto_tag = crypto_tag;
  D.46740 = engine->rtp_session;
  D.46776 = switch_rtp_ready (D.46740);
  if (D.46776 != 0)
    goto <bb 28>;
  else
    goto <bb 30>;

<bb 28>:
  D.46734 = session->channel;
  D.46779 = switch_channel_test_flag (D.46734, 92);
  if (D.46779 != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  D.46782 = &engine->ssec;
  D.46737 = engine->crypto_type;
  D.46783 = D.46737 * 144;
  D.46784 = D.46782 + D.46783;
  D.46737 = engine->crypto_type;
  D.46738 = engine->ssec[D.46737].remote_crypto_key;
  switch_core_media_add_crypto (D.46784, D.46738, 1);
  D.46740 = engine->rtp_session;
  D.46737 = engine->crypto_type;
  D.46785 = engine->ssec[D.46737].crypto_tag;
  D.46786 = (uint32_t) D.46785;
  D.46737 = engine->crypto_type;
  D.46755 = engine->ssec[D.46737].crypto_type;
  D.46737 = engine->crypto_type;
  D.46787 = &engine->ssec[D.46737].remote_raw_key;
  D.46737 = engine->crypto_type;
  D.46755 = engine->ssec[D.46737].crypto_type;
  D.46788 = SUITES[D.46755].keylen;
  D.46789 = (switch_size_t) D.46788;
  switch_rtp_add_crypto_key (D.46740, 1, D.46786, D.46755, D.46787, D.46789);

<bb 30>:
  got_crypto = got_crypto + 1;
  goto <bb 41> (end);

<bb 31>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1238, session, 7, "Ignoring unacceptable key\n");
  goto <bb 41> (end);

<bb 32>:
  D.46740 = engine->rtp_session;
  D.46790 = switch_rtp_ready (D.46740);
  if (D.46790 == 0)
    goto <bb 33>;
  else
    goto <bb 41> (end);

<bb 33>:
  if (vval == 0B)
    goto <bb 34>;
  else
    goto <bb 35>;

<bb 34>:
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1244, session, 7, "Unsupported Crypto [%s]\n", crypto);
  goto <bb 41> (end);

<bb 35>:
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  engine->crypto_type = ctype.166;
  D.46737 = engine->crypto_type;
  D.46795 = switch_core_perform_session_strdup (session, crypto, "src/switch_core_media.c", &__func__, 1249);
  engine->ssec[D.46737].remote_crypto_key = D.46795;
  D.46737 = engine->crypto_type;
  D.46738 = engine->ssec[D.46737].remote_crypto_key;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 1250, session, 7, "Set Remote Key [%s]\n", D.46738);
  D.46768 = engine->type;
  if (D.46768 == 0)
    goto <bb 36>;
  else
    goto <bb 37>;

<bb 36>:
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, "srtp_remote_audio_crypto_key", crypto, 1);
  D.46734 = session->channel;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  D.46798 = switch_core_media_crypto_type2str (ctype.166);
  switch_channel_set_variable_printf (D.46734, "srtp_remote_audio_crypto_type", "%s", D.46798);
  goto <bb 39>;

<bb 37>:
  D.46768 = engine->type;
  if (D.46768 == 1)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, "srtp_remote_video_crypto_key", crypto, 1);
  D.46734 = session->channel;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  D.46802 = switch_core_media_crypto_type2str (ctype.166);
  switch_channel_set_variable_printf (D.46734, "srtp_remote_video_crypto_type", "%s", D.46802);

<bb 39>:
  D.46737 = engine->crypto_type;
  engine->ssec[D.46737].crypto_tag = crypto_tag;
  got_crypto = got_crypto + 1;
  D.46734 = session->channel;
  switch_channel_set_variable_var_check (D.46734, varname, vval, 1);
  D.46803 = smh->session;
  D.46804 = D.46803->channel;
  switch_channel_set_flag_value (D.46804, 92, 1);
  D.46737 = engine->crypto_type;
  D.46805 = engine->ssec[D.46737].local_crypto_key;
  D.46806 = _zstr (D.46805);
  if (D.46806 != 0)
    goto <bb 40>;
  else
    goto <bb 41> (end);

<bb 40>:
  D.46725 = session->media_handle;
  ctype.166 = (switch_rtp_crypto_key_type_t) ctype;
  switch_core_media_build_crypto (D.46725, type, crypto_tag, ctype.166, 0, 1);

end:
  D.46721 = got_crypto;

<bb 42>:
  return D.46721;

}



;; Function switch_core_media_set_rtp_session (switch_core_media_set_rtp_session)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)

}
Removing basic block 3
;; basic block 3, loop depth 0, count 0
;; prev block 2, next block 4
;; pred:      
;; succ:       5 (fallthru)
<bb 3>:
goto <bb 5>;


switch_core_media_set_rtp_session (struct switch_core_session_t * session, switch_media_type_t type, struct switch_rtp_t * rtp_session)
{
  struct switch_rtp_engine_t * engine;
  unsigned int D.46814;
  struct switch_rtp_engine_t[2] * D.46813;
  struct switch_media_handle_t * D.46810;

<bb 2>:
  D.46810 = session->media_handle;
  if (D.46810 == 0B)
    goto <bb 4>;
  else
    goto <bb 3>;

<bb 3>:
  D.46810 = session->media_handle;
  D.46813 = &D.46810->engines;
  D.46814 = type * 11416;
  engine = D.46813 + D.46814;
  engine->rtp_session = rtp_session;
  engine->type = type;

<bb 4>:
  return;

}



;; Function switch_core_media_add_crypto (switch_core_media_add_crypto)

Scope blocks:

{ Scope block #0 
  unsigned char key[64]; (unused)
  switch_rtp_crypto_key_type_t type; (unused)
  char * p; (unused)
  static const char __func__[29] = "switch_core_media_add_crypto"; (unused)
  void bad = <<< error >>>; (unused)

}
switch_core_media_add_crypto (struct switch_secure_settings_t * ssec, const char * key_str, switch_rtp_crypto_direction_t direction)
{
  static const char __func__[29] = "switch_core_media_add_crypto";
  char * p;
  switch_rtp_crypto_key_type_t type;
  unsigned char key[64];
  switch_status_t D.46846;
  void * restrict D.46845;
  unsigned char * D.46844;
  size_t D.46842;
  int D.46841;
  const void * restrict D.46840;
  void * restrict D.46839;
  unsigned char * D.46838;
  int D.46833;
  char D.46822;
  char * D.46821;
  char D.46818;

<bb 2>:
  p = __builtin_strchr (key_str, 32);
  if (p != 0B)
    goto <bb 3>;
  else
    goto <bb 16> (bad);

<bb 3>:
  D.46818 = *p;
  if (D.46818 != 0)
    goto <bb 4>;
  else
    goto <bb 16> (bad);

<bb 4>:
  D.46821 = p + 1;
  D.46822 = *D.46821;
  if (D.46822 != 0)
    goto <bb 5>;
  else
    goto <bb 16> (bad);

<bb 5>:
  p = p + 1;
  type = switch_core_media_crypto_str2type (p);
  if (type == 9)
    goto <bb 6>;
  else
    goto <bb 7>;

<bb 6>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 949, 0B, 3, "Parse Error near [%s]\n", p);
  goto <bb 16> (bad);

<bb 7>:
  p = __builtin_strchr (p, 32);
  if (p != 0B)
    goto <bb 8>;
  else
    goto <bb 16> (bad);

<bb 8>:
  D.46818 = *p;
  if (D.46818 != 0)
    goto <bb 9>;
  else
    goto <bb 16> (bad);

<bb 9>:
  D.46821 = p + 1;
  D.46822 = *D.46821;
  if (D.46822 != 0)
    goto <bb 10>;
  else
    goto <bb 16> (bad);

<bb 10>:
  p = p + 1;
  D.46833 = strncasecmp (p, "inline:", 7);
  if (D.46833 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 957, 0B, 3, "Parse Error near [%s]\n", p);
  goto <bb 16> (bad);

<bb 12>:
  p = p + 7;
  switch_b64_decode (p, &key, 64);
  if (direction == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.46838 = &ssec->local_raw_key[0];
  D.46839 = (void * restrict) D.46838;
  D.46840 = (const void * restrict) &key[0];
  D.46841 = SUITES[type].keylen;
  D.46842 = (size_t) D.46841;
  memcpy (D.46839, D.46840, D.46842);
  goto <bb 15>;

<bb 14>:
  D.46844 = &ssec->remote_raw_key[0];
  D.46845 = (void * restrict) D.46844;
  D.46840 = (const void * restrict) &key[0];
  D.46841 = SUITES[type].keylen;
  D.46842 = (size_t) D.46841;
  memcpy (D.46845, D.46840, D.46842);

<bb 15>:
  D.46846 = 0;
  goto <bb 17>;

bad:
  switch_log_printf (0, "src/switch_core_media.c", &__func__, 976, 0B, 3, "Error!\n");
  D.46846 = 1;

<bb 17>:
  return D.46846;

}



;; Function switch_core_media_parse_rtp_bugs (switch_core_media_parse_rtp_bugs)

Scope blocks:

{ Scope block #0 

}
switch_core_media_parse_rtp_bugs (switch_rtp_bug_flag_t * flag_pole, const char * str)
{
  unsigned int D.46947;
  const char * D.46944;
  unsigned int D.46943;
  const char * D.46940;
  unsigned int D.46939;
  const char * D.46936;
  unsigned int D.46935;
  const char * D.46932;
  unsigned int D.46931;
  const char * D.46928;
  unsigned int D.46927;
  const char * D.46924;
  unsigned int D.46923;
  const char * D.46920;
  unsigned int D.46919;
  const char * D.46916;
  unsigned int D.46915;
  const char * D.46912;
  unsigned int D.46911;
  const char * D.46908;
  unsigned int D.46907;
  const char * D.46904;
  unsigned int D.46903;
  const char * D.46900;
  unsigned int D.46899;
  const char * D.46896;
  unsigned int D.46895;
  const char * D.46892;
  unsigned int D.46891;
  const char * D.46888;
  unsigned int D.46887;
  const char * D.46884;
  unsigned int D.46883;
  const char * D.46880;
  unsigned int D.46879;
  const char * D.46876;
  unsigned int D.46875;
  const char * D.46872;
  unsigned int D.46871;
  const char * D.46868;
  unsigned int D.46867;
  const char * D.46864;
  unsigned int D.46863;
  const char * D.46860;
  unsigned int D.46859;
  const char * D.46856;
  unsigned int D.46855;
  switch_rtp_bug_flag_t D.46854;
  const char * D.46851;
  const char * D.46848;

<bb 2>:
  D.46848 = switch_stristr ("clear", str);
  if (D.46848 != 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  *flag_pole = 0;

<bb 4>:
  D.46851 = switch_stristr ("CISCO_SKIP_MARK_BIT_2833", str);
  if (D.46851 != 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.46854 = *flag_pole;
  D.46855 = D.46854 | 1;
  *flag_pole = D.46855;

<bb 6>:
  D.46856 = switch_stristr ("~CISCO_SKIP_MARK_BIT_2833", str);
  if (D.46856 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.46854 = *flag_pole;
  D.46859 = D.46854 & 4294967294;
  *flag_pole = D.46859;

<bb 8>:
  D.46860 = switch_stristr ("SONUS_SEND_INVALID_TIMESTAMP_2833", str);
  if (D.46860 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.46854 = *flag_pole;
  D.46863 = D.46854 | 2;
  *flag_pole = D.46863;

<bb 10>:
  D.46864 = switch_stristr ("~SONUS_SEND_INVALID_TIMESTAMP_2833", str);
  if (D.46864 != 0B)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  D.46854 = *flag_pole;
  D.46867 = D.46854 & 4294967293;
  *flag_pole = D.46867;

<bb 12>:
  D.46868 = switch_stristr ("IGNORE_MARK_BIT", str);
  if (D.46868 != 0B)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  D.46854 = *flag_pole;
  D.46871 = D.46854 | 4;
  *flag_pole = D.46871;

<bb 14>:
  D.46872 = switch_stristr ("~IGNORE_MARK_BIT", str);
  if (D.46872 != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  D.46854 = *flag_pole;
  D.46875 = D.46854 & 4294967291;
  *flag_pole = D.46875;

<bb 16>:
  D.46876 = switch_stristr ("SEND_LINEAR_TIMESTAMPS", str);
  if (D.46876 != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  D.46854 = *flag_pole;
  D.46879 = D.46854 | 8;
  *flag_pole = D.46879;

<bb 18>:
  D.46880 = switch_stristr ("~SEND_LINEAR_TIMESTAMPS", str);
  if (D.46880 != 0B)
    goto <bb 19>;
  else
    goto <bb 20>;

<bb 19>:
  D.46854 = *flag_pole;
  D.46883 = D.46854 & 4294967287;
  *flag_pole = D.46883;

<bb 20>:
  D.46884 = switch_stristr ("START_SEQ_AT_ZERO", str);
  if (D.46884 != 0B)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  D.46854 = *flag_pole;
  D.46887 = D.46854 | 16;
  *flag_pole = D.46887;

<bb 22>:
  D.46888 = switch_stristr ("~START_SEQ_AT_ZERO", str);
  if (D.46888 != 0B)
    goto <bb 23>;
  else
    goto <bb 24>;

<bb 23>:
  D.46854 = *flag_pole;
  D.46891 = D.46854 & 4294967279;
  *flag_pole = D.46891;

<bb 24>:
  D.46892 = switch_stristr ("NEVER_SEND_MARKER", str);
  if (D.46892 != 0B)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  D.46854 = *flag_pole;
  D.46895 = D.46854 | 32;
  *flag_pole = D.46895;

<bb 26>:
  D.46896 = switch_stristr ("~NEVER_SEND_MARKER", str);
  if (D.46896 != 0B)
    goto <bb 27>;
  else
    goto <bb 28>;

<bb 27>:
  D.46854 = *flag_pole;
  D.46899 = D.46854 & 4294967263;
  *flag_pole = D.46899;

<bb 28>:
  D.46900 = switch_stristr ("IGNORE_DTMF_DURATION", str);
  if (D.46900 != 0B)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  D.46854 = *flag_pole;
  D.46903 = D.46854 | 64;
  *flag_pole = D.46903;

<bb 30>:
  D.46904 = switch_stristr ("~IGNORE_DTMF_DURATION", str);
  if (D.46904 != 0B)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  D.46854 = *flag_pole;
  D.46907 = D.46854 & 4294967231;
  *flag_pole = D.46907;

<bb 32>:
  D.46908 = switch_stristr ("ACCEPT_ANY_PACKETS", str);
  if (D.46908 != 0B)
    goto <bb 33>;
  else
    goto <bb 34>;

<bb 33>:
  D.46854 = *flag_pole;
  D.46911 = D.46854 | 128;
  *flag_pole = D.46911;

<bb 34>:
  D.46912 = switch_stristr ("~ACCEPT_ANY_PACKETS", str);
  if (D.46912 != 0B)
    goto <bb 35>;
  else
    goto <bb 36>;

<bb 35>:
  D.46854 = *flag_pole;
  D.46915 = D.46854 & 4294967167;
  *flag_pole = D.46915;

<bb 36>:
  D.46916 = switch_stristr ("ACCEPT_ANY_PAYLOAD", str);
  if (D.46916 != 0B)
    goto <bb 37>;
  else
    goto <bb 38>;

<bb 37>:
  D.46854 = *flag_pole;
  D.46919 = D.46854 | 2048;
  *flag_pole = D.46919;

<bb 38>:
  D.46920 = switch_stristr ("~ACCEPT_ANY_PAYLOAD", str);
  if (D.46920 != 0B)
    goto <bb 39>;
  else
    goto <bb 40>;

<bb 39>:
  D.46854 = *flag_pole;
  D.46923 = D.46854 & 4294965247;
  *flag_pole = D.46923;

<bb 40>:
  D.46924 = switch_stristr ("GEN_ONE_GEN_ALL", str);
  if (D.46924 != 0B)
    goto <bb 41>;
  else
    goto <bb 42>;

<bb 41>:
  D.46854 = *flag_pole;
  D.46927 = D.46854 | 256;
  *flag_pole = D.46927;

<bb 42>:
  D.46928 = switch_stristr ("~GEN_ONE_GEN_ALL", str);
  if (D.46928 != 0B)
    goto <bb 43>;
  else
    goto <bb 44>;

<bb 43>:
  D.46854 = *flag_pole;
  D.46931 = D.46854 & 4294967039;
  *flag_pole = D.46931;

<bb 44>:
  D.46932 = switch_stristr ("CHANGE_SSRC_ON_MARKER", str);
  if (D.46932 != 0B)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  D.46854 = *flag_pole;
  D.46935 = D.46854 | 512;
  *flag_pole = D.46935;

<bb 46>:
  D.46936 = switch_stristr ("~CHANGE_SSRC_ON_MARKER", str);
  if (D.46936 != 0B)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  D.46854 = *flag_pole;
  D.46939 = D.46854 & 4294966783;
  *flag_pole = D.46939;

<bb 48>:
  D.46940 = switch_stristr ("FLUSH_JB_ON_DTMF", str);
  if (D.46940 != 0B)
    goto <bb 49>;
  else
    goto <bb 50>;

<bb 49>:
  D.46854 = *flag_pole;
  D.46943 = D.46854 | 1024;
  *flag_pole = D.46943;

<bb 50>:
  D.46944 = switch_stristr ("~FLUSH_JB_ON_DTMF", str);
  if (D.46944 != 0B)
    goto <bb 51>;
  else
    goto <bb 52>;

<bb 51>:
  D.46854 = *flag_pole;
  D.46947 = D.46854 & 4294966271;
  *flag_pole = D.46947;

<bb 52>:
  return;

}



;; Function switch_core_session_local_crypto_key (switch_core_session_local_crypto_key)

Scope blocks:

{ Scope block #0 

}
switch_core_session_local_crypto_key (struct switch_core_session_t * session, switch_media_type_t type)
{
  switch_rtp_crypto_key_type_t D.46952;
  const char * D.46951;
  struct switch_media_handle_t * D.46948;

<bb 2>:
  D.46948 = session->media_handle;
  if (D.46948 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.46951 = 0B;
  goto <bb 5>;

<bb 4>:
  D.46948 = session->media_handle;
  D.46948 = session->media_handle;
  D.46952 = D.46948->engines[type].crypto_type;
  D.46951 = D.46948->engines[type].ssec[D.46952].local_crypto_key;

<bb 5>:
  return D.46951;

}



;; Function switch_core_session_clear_crypto (switch_core_session_clear_crypto)

Scope blocks:

{ Scope block #0 
  int i; (unused)
  struct switch_media_handle_t * smh; (unused)
  const char * vars[11]; (unused)

}
Removing basic block 6
;; basic block 6, loop depth 0, count 0
;; prev block 5, next block 7
;; pred:      
;; succ:       10 (fallthru)
<bb 6>:
goto <bb 10>;


switch_core_session_clear_crypto (struct switch_core_session_t * session)
{
  const char * vars[11];
  struct switch_media_handle_t * smh;
  int i;
  void * D.46974;
  struct switch_secure_settings_t[10] * D.46973;
  void * D.46972;
  unsigned int D.46971;
  unsigned int i.167;
  struct switch_secure_settings_t[10] * D.46969;
  const char * D.46966;
  struct switch_channel_t * D.46965;

<bb 2>:
  vars = *.LC10;
  i = 0;
  goto <bb 4>;

<bb 3>:
  D.46965 = session->channel;
  D.46966 = vars[i];
  switch_channel_set_variable_var_check (D.46965, D.46966, 0B, 1);
  i = i + 1;

<bb 4>:
  D.46966 = vars[i];
  if (D.46966 != 0B)
    goto <bb 3>;
  else
    goto <bb 5>;

<bb 5>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 9>;
  else
    goto <bb 6>;

<bb 6>:
  i = 0;
  goto <bb 8>;

<bb 7>:
  D.46969 = &smh->engines[0].ssec;
  i.167 = (unsigned int) i;
  D.46971 = i.167 * 144;
  D.46972 = D.46969 + D.46971;
  memset (D.46972, 0, 144);
  D.46973 = &smh->engines[1].ssec;
  i.167 = (unsigned int) i;
  D.46971 = i.167 * 144;
  D.46974 = D.46973 + D.46971;
  memset (D.46974, 0, 144);
  i = i + 1;

<bb 8>:
  if (i <= 8)
    goto <bb 7>;
  else
    goto <bb 9>;

<bb 9>:
  return;

}



;; Function switch_core_media_get_codec_string (switch_core_media_get_codec_string)

Scope blocks:

{ Scope block #0 
  const char * preferred; (unused)
  const char * fallback; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_get_codec_string"; (unused)

}
Merging blocks 15 and 16
switch_core_media_get_codec_string (struct switch_core_session_t * session)
{
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_get_codec_string";
  struct switch_media_handle_t * smh;
  const char * fallback;
  const char * preferred;
  int D.46993;
  const char * iftmp.168;
  const char * D.46991;
  struct switch_core_media_params_t * D.46989;
  switch_call_direction_t D.46986;
  struct switch_channel_t * D.46981;

<bb 2>:
  preferred = 0B;
  fallback = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 685, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  preferred = "PCMU";
  fallback = "PCMU";
  goto <bb 12>;

<bb 6>:
  D.46981 = session->channel;
  preferred = switch_channel_get_variable_dup (D.46981, "absolute_codec_string", 1, -1);
  if (preferred == 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.46981 = session->channel;
  preferred = switch_channel_get_variable_dup (D.46981, "codec_string", 1, -1);

<bb 8>:
  if (preferred == 0B)
    goto <bb 9>;
  else
    goto <bb 12>;

<bb 9>:
  D.46981 = session->channel;
  D.46986 = switch_channel_direction (D.46981);
  if (D.46986 == 1)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  D.46989 = smh->mparams;
  preferred = D.46989->outbound_codec_string;
  D.46989 = smh->mparams;
  fallback = D.46989->inbound_codec_string;
  goto <bb 12>;

<bb 11>:
  D.46989 = smh->mparams;
  preferred = D.46989->inbound_codec_string;
  D.46989 = smh->mparams;
  fallback = D.46989->outbound_codec_string;

<bb 12>:
  D.46993 = _zstr (preferred);
  if (D.46993 == 0)
    goto <bb 13>;
  else
    goto <bb 14>;

<bb 13>:
  iftmp.168 = preferred;
  goto <bb 15>;

<bb 14>:
  iftmp.168 = fallback;

<bb 15>:
  D.46991 = iftmp.168;
  return D.46991;

}



;; Function switch_core_media_add_payload_map (switch_core_media_add_payload_map)

Scope blocks:

{ Scope block #0 
  struct payload_map_t * pmap; (unused)
  int exists; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  int local_pt; (unused)
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_add_payload_map"; (unused)
  static const char __func__[34] = "switch_core_media_add_payload_map"; (unused)

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

  { Scope block #0 
    switch_ssize_t hlen; (unused)

  }

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

}
Removing basic block 19
;; basic block 19, loop depth 0, count 0
;; prev block 18, next block 20
;; pred:      
;; succ:       23 (fallthru)
<bb 19>:
goto <bb 23>;


switch_core_media_add_payload_map (struct switch_core_session_t * session, switch_media_type_t type, const char * name, const char * fmtp, switch_sdp_type_t sdp_type, uint32_t pt, uint32_t rate, uint32_t ptime, uint8_t negotiated)
{
  size_t __s2_len;
  size_t __s1_len;
  switch_ssize_t hlen;
  size_t __s2_len;
  size_t __s1_len;
  static const char __func__[34] = "switch_core_media_add_payload_map";
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_add_payload_map";
  int local_pt;
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  int exists;
  struct payload_map_t * pmap;
  struct payload_map_s * D.47076;
  struct payload_map_t * D.47074;
  unsigned char iftmp.170;
  _Bool D.47058;
  _Bool D.47057;
  _Bool D.47056;
  unsigned char D.47055;
  char * D.47054;
  int D.38491;
  int D.47052;
  int D.47049;
  unsigned int D.47042;
  char * D.47041;
  struct switch_memory_pool_t * D.47040;
  uint8_t D.47038;
  struct payload_map_t * D.47036;
  uint8_t D.47031;
  switch_payload_t D.47029;
  int D.38476;
  int D.47024;
  char * D.47023;
  int D.47020;
  uint32_t D.47016;
  uint32_t D.47014;
  int D.47012;
  char * D.47011;
  int iftmp.169;
  struct switch_mutex_t * D.47005;
  unsigned int D.47004;
  struct switch_rtp_engine_t[2] * D.47003;
  struct payload_map_t * D.47002;

<bb 2>:
  exists = 0;
  local_pt = 0;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 589, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47002 = 0B;
  goto <bb 50>;

<bb 6>:
  D.47003 = &smh->engines;
  D.47004 = type * 11416;
  engine = D.47003 + D.47004;
  D.47005 = smh->sdp_mutex;
  switch_mutex_lock (D.47005);
  pmap = engine->payload_map;
  goto <bb 20>;

<bb 7>:
  D.47011 = pmap->iananame;
  D.47012 = strcasecmp (name, D.47011);
  if (D.47012 == 0)
    goto <bb 8>;
  else
    goto <bb 13>;

<bb 8>:
  D.47014 = pmap->rate;
  if (D.47014 == 0)
    goto <bb 10>;
  else
    goto <bb 9>;

<bb 9>:
  D.47014 = pmap->rate;
  if (D.47014 == rate)
    goto <bb 10>;
  else
    goto <bb 13>;

<bb 10>:
  D.47016 = pmap->ptime;
  if (D.47016 == 0)
    goto <bb 12>;
  else
    goto <bb 11>;

<bb 11>:
  D.47016 = pmap->ptime;
  if (D.47016 == ptime)
    goto <bb 12>;
  else
    goto <bb 13>;

<bb 12>:
  iftmp.169 = 1;
  goto <bb 14>;

<bb 13>:
  iftmp.169 = 0;

<bb 14>:
  exists = iftmp.169;
  if (exists != 0)
    goto <bb 15>;
  else
    goto <bb 19>;

<bb 15>:
  D.47020 = _zstr (fmtp);
  if (D.47020 == 0)
    goto <bb 16>;
  else
    goto <bb 22>;

<bb 16>:
  D.47023 = pmap->rm_fmtp;
  D.47024 = _zstr (D.47023);
  if (D.47024 == 0)
    goto <bb 17>;
  else
    goto <bb 22>;

<bb 17>:
  D.47023 = pmap->rm_fmtp;
  D.38476 = __builtin_strcmp (D.47023, fmtp);
  if (D.38476 != 0)
    goto <bb 18>;
  else
    goto <bb 22>;

<bb 18>:
  exists = 0;
  D.47029 = pmap->pt;
  local_pt = (int) D.47029;
  // predicted unlikely by continue predictor.

<bb 19>:
  pmap = pmap->next;

<bb 20>:
  if (pmap != 0B)
    goto <bb 21>;
  else
    goto <bb 22>;

<bb 21>:
  D.47031 = pmap->allocated;
  if (D.47031 != 0)
    goto <bb 7>;
  else
    goto <bb 22>;

<bb 22>:
  if (exists == 0)
    goto <bb 23>;
  else
    goto <bb 28>;

<bb 23>:
  hlen = -1;
  D.47036 = engine->payload_map;
  if (D.47036 != 0B)
    goto <bb 24>;
  else
    goto <bb 26>;

<bb 24>:
  D.47036 = engine->payload_map;
  D.47038 = D.47036->allocated;
  if (D.47038 == 0)
    goto <bb 25>;
  else
    goto <bb 26>;

<bb 25>:
  pmap = engine->payload_map;
  goto <bb 27>;

<bb 26>:
  D.47040 = session->pool;
  pmap = switch_core_perform_alloc (D.47040, 84, "src/switch_core_media.c", &__func__, 624);

<bb 27>:
  pmap->type = type;
  D.47040 = session->pool;
  D.47041 = switch_core_perform_strdup (D.47040, name, "src/switch_core_media.c", &__func__, 628);
  pmap->iananame = D.47041;
  D.47011 = pmap->iananame;
  pmap->rm_encoding = D.47011;
  D.47011 = pmap->iananame;
  D.47042 = switch_ci_hashfunc_default (D.47011, &hlen);
  pmap->hash = D.47042;

<bb 28>:
  pmap->sdp_type = sdp_type;
  if (ptime != 0)
    goto <bb 29>;
  else
    goto <bb 30>;

<bb 29>:
  pmap->ptime = ptime;

<bb 30>:
  if (rate != 0)
    goto <bb 31>;
  else
    goto <bb 32>;

<bb 31>:
  pmap->rate = rate;

<bb 32>:
  D.47049 = _zstr (fmtp);
  if (D.47049 == 0)
    goto <bb 33>;
  else
    goto <bb 36>;

<bb 33>:
  D.47023 = pmap->rm_fmtp;
  D.47052 = _zstr (D.47023);
  if (D.47052 != 0)
    goto <bb 35>;
  else
    goto <bb 34>;

<bb 34>:
  D.47023 = pmap->rm_fmtp;
  D.38491 = __builtin_strcmp (D.47023, fmtp);
  if (D.38491 != 0)
    goto <bb 35>;
  else
    goto <bb 36>;

<bb 35>:
  D.47040 = session->pool;
  D.47054 = switch_core_perform_strdup (D.47040, fmtp, "src/switch_core_media.c", &__func__, 644);
  pmap->rm_fmtp = D.47054;

<bb 36>:
  pmap->allocated = 1;
  D.47055 = (unsigned char) pt;
  pmap->recv_pt = D.47055;
  D.47056 = sdp_type == 0;
  D.47057 = exists == 0;
  D.47058 = D.47056 || D.47057;
  if (D.47058 != 0)
    goto <bb 37>;
  else
    goto <bb 41>;

<bb 37>:
  if (local_pt != 0)
    goto <bb 38>;
  else
    goto <bb 39>;

<bb 38>:
  iftmp.170 = (unsigned char) local_pt;
  goto <bb 40>;

<bb 39>:
  iftmp.170 = (unsigned char) pt;

<bb 40>:
  pmap->pt = iftmp.170;

<bb 41>:
  if (negotiated != 0)
    goto <bb 42>;
  else
    goto <bb 43>;

<bb 42>:
  pmap->negotiated = negotiated;

<bb 43>:
  if (exists == 0)
    goto <bb 44>;
  else
    goto <bb 49>;

<bb 44>:
  D.47036 = engine->payload_map;
  if (D.47036 == pmap)
    goto <bb 45>;
  else
    goto <bb 46>;

<bb 45>:
  engine->pmap_tail = pmap;
  goto <bb 49>;

<bb 46>:
  D.47036 = engine->payload_map;
  if (D.47036 == 0B)
    goto <bb 47>;
  else
    goto <bb 48>;

<bb 47>:
  engine->pmap_tail = pmap;
  D.47074 = engine->pmap_tail;
  engine->payload_map = D.47074;
  goto <bb 49>;

<bb 48>:
  D.47074 = engine->pmap_tail;
  D.47074->next = pmap;
  D.47074 = engine->pmap_tail;
  D.47076 = D.47074->next;
  engine->pmap_tail = D.47076;

<bb 49>:
  D.47005 = smh->sdp_mutex;
  switch_mutex_unlock (D.47005);
  D.47002 = pmap;

<bb 50>:
  return D.47002;

}



;; Function switch_core_session_get_payload_code (switch_core_session_get_payload_code)

Scope blocks:

{ Scope block #0 
  struct payload_map_t * pmap; (unused)
  struct switch_media_handle_t * smh; (unused)
  struct switch_rtp_engine_t * engine; (unused)
  switch_payload_t pt; (unused)
  switch_payload_t recv_pt; (unused)
  int found; (unused)
  char * fmtp; (unused)
  static const char __PRETTY_FUNCTION__[37] = "switch_core_session_get_payload_code"; (unused)

}
switch_core_session_get_payload_code (struct switch_core_session_t * session, switch_media_type_t type, const char * iananame, switch_payload_t * ptP, switch_payload_t * recv_ptP, char * * fmtpP)
{
  static const char __PRETTY_FUNCTION__[37] = "switch_core_session_get_payload_code";
  char * fmtp;
  int found;
  switch_payload_t recv_pt;
  switch_payload_t pt;
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  struct payload_map_t * pmap;
  int D.47099;
  int D.47090;
  char * D.47089;
  uint8_t D.47086;
  struct switch_mutex_t * D.47085;
  unsigned int D.47084;
  struct switch_rtp_engine_t[2] * D.47083;
  switch_status_t D.47082;

<bb 2>:
  pt = 0;
  recv_pt = 0;
  found = 0;
  fmtp = 0B;
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 530, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47082 = 1;
  goto <bb 23>;

<bb 6>:
  D.47083 = &smh->engines;
  D.47084 = type * 11416;
  engine = D.47083 + D.47084;
  D.47085 = smh->sdp_mutex;
  switch_mutex_lock (D.47085);
  pmap = engine->payload_map;
  goto <bb 12>;

<bb 7>:
  D.47086 = pmap->allocated;
  if (D.47086 == 0)
    goto <bb 8>;
  else
    goto <bb 9>;

<bb 8>:
  // predicted unlikely by continue predictor.
  goto <bb 11>;

<bb 9>:
  D.47089 = pmap->iananame;
  D.47090 = strcasecmp (D.47089, iananame);
  if (D.47090 == 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  pt = pmap->pt;
  recv_pt = pmap->recv_pt;
  fmtp = pmap->rm_fmtp;
  found = found + 1;
  goto <bb 13>;

<bb 11>:
  pmap = pmap->next;

<bb 12>:
  if (pmap != 0B)
    goto <bb 7>;
  else
    goto <bb 13>;

<bb 13>:
  D.47085 = smh->sdp_mutex;
  switch_mutex_unlock (D.47085);
  if (found != 0)
    goto <bb 14>;
  else
    goto <bb 22>;

<bb 14>:
  if (ptP != 0B)
    goto <bb 15>;
  else
    goto <bb 16>;

<bb 15>:
  *ptP = pt;

<bb 16>:
  if (recv_ptP != 0B)
    goto <bb 17>;
  else
    goto <bb 18>;

<bb 17>:
  *recv_ptP = recv_pt;

<bb 18>:
  D.47099 = _zstr (fmtp);
  if (D.47099 == 0)
    goto <bb 19>;
  else
    goto <bb 21>;

<bb 19>:
  if (fmtpP != 0B)
    goto <bb 20>;
  else
    goto <bb 21>;

<bb 20>:
  *fmtpP = fmtp;

<bb 21>:
  D.47082 = 0;
  goto <bb 23>;

<bb 22>:
  D.47082 = 1;

<bb 23>:
  return D.47082;

}



;; Function switch_core_media_process_t38_passthru (switch_core_media_process_t38_passthru)

Scope blocks:

{ Scope block #0 
  char * remote_host; (unused)
  switch_port_t remote_port; (unused)
  char tmp[32]; (unused)
  struct switch_rtp_engine_t * a_engine; (unused)
  struct switch_media_handle_t * smh; (unused)
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_process_t38_passthru"; (unused)
  static const char __func__[39] = "switch_core_media_process_t38_passthru"; (unused)

  { Scope block #0 
    size_t __s1_len; (unused)
    size_t __s2_len; (unused)

  }

  { Scope block #0 
    const char * err; (unused)

  }

}
switch_core_media_process_t38_passthru (struct switch_core_session_t * session, struct switch_core_session_t * other_session, struct switch_t38_options_t * t38_options)
{
  const char * err;
  size_t __s2_len;
  size_t __s1_len;
  static const char __func__[39] = "switch_core_media_process_t38_passthru";
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_process_t38_passthru";
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  char tmp[32];
  switch_port_t remote_port;
  char * remote_host;
  const char * err.171;
  switch_status_t D.47130;
  int D.47129;
  int D.47128;
  char * D.47127;
  char * D.47126;
  struct switch_channel_t * D.47125;
  switch_port_t D.47123;
  char * D.47121;
  int D.38429;
  _Bool D.47119;
  _Bool D.47118;
  _Bool D.47117;
  uint16_t D.47114;
  char * D.47113;
  const char * D.47112;
  struct payload_map_t * D.47111;
  struct switch_rtp_t * D.47110;
  switch_status_t D.47109;

<bb 2>:
  tmp = "";
  if (session == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("session", "src/switch_core_media.c", 473, &__PRETTY_FUNCTION__);

<bb 4>:
  smh = session->media_handle;
  if (smh == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47109 = 1;
  goto <bb 13>;

<bb 6>:
  a_engine = &smh->engines;
  D.47110 = a_engine->rtp_session;
  remote_host = switch_rtp_get_remote_host (D.47110);
  D.47110 = a_engine->rtp_session;
  remote_port = switch_rtp_get_remote_port (D.47110);
  D.47111 = a_engine->cur_payload_map;
  D.47112 = t38_options->remote_ip;
  D.47113 = switch_core_perform_session_strdup (session, D.47112, "src/switch_core_media.c", &__func__, 484);
  D.47111->remote_sdp_ip = D.47113;
  D.47111 = a_engine->cur_payload_map;
  D.47114 = t38_options->remote_port;
  D.47111->remote_sdp_port = D.47114;
  D.47117 = remote_host != 0B;
  D.47118 = remote_port != 0;
  D.47119 = D.47117 && D.47118;
  if (D.47119 != 0)
    goto <bb 7>;
  else
    goto <bb 10>;

<bb 7>:
  D.47111 = a_engine->cur_payload_map;
  D.47121 = D.47111->remote_sdp_ip;
  D.38429 = __builtin_strcmp (remote_host, D.47121);
  if (D.38429 == 0)
    goto <bb 8>;
  else
    goto <bb 10>;

<bb 8>:
  D.47111 = a_engine->cur_payload_map;
  D.47123 = D.47111->remote_sdp_port;
  if (D.47123 == remote_port)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.47125 = session->channel;
  D.47126 = switch_channel_get_name (D.47125);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 489, session, 7, "Audio params are unchanged for %s.\n", D.47126);
  goto <bb 12>;

<bb 10>:
  err = 0B;
  D.47125 = session->channel;
  D.47127 = switch_channel_get_name (D.47125);
  D.47128 = (int) remote_port;
  D.47111 = a_engine->cur_payload_map;
  D.47121 = D.47111->remote_sdp_ip;
  D.47111 = a_engine->cur_payload_map;
  D.47123 = D.47111->remote_sdp_port;
  D.47129 = (int) D.47123;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 495, session, 7, "Audio params changed for %s from %s:%d to %s:%d\n", D.47127, remote_host, D.47128, D.47121, D.47129);
  D.47111 = a_engine->cur_payload_map;
  D.47123 = D.47111->remote_sdp_port;
  D.47129 = (int) D.47123;
  switch_snprintf (&tmp, 32, "%d", D.47129);
  D.47125 = session->channel;
  D.47111 = a_engine->cur_payload_map;
  D.47121 = D.47111->remote_sdp_ip;
  switch_channel_set_variable_var_check (D.47125, "remote_media_ip", D.47121, 1);
  D.47125 = session->channel;
  switch_channel_set_variable_var_check (D.47125, "remote_media_port", &tmp, 1);
  D.47110 = a_engine->rtp_session;
  D.47111 = a_engine->cur_payload_map;
  D.47121 = D.47111->remote_sdp_ip;
  D.47111 = a_engine->cur_payload_map;
  D.47123 = D.47111->remote_sdp_port;
  D.47130 = switch_rtp_set_remote_address (D.47110, D.47121, D.47123, 0, 1, &err);
  if (D.47130 != 0)
    goto <bb 11>;
  else
    goto <bb 12>;

<bb 11>:
  err.171 = err;
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 505, session, 3, "AUDIO RTP REPORTS ERROR: [%s]\n", err.171);
  D.47125 = session->channel;
  switch_channel_perform_hangup (D.47125, "src/switch_core_media.c", &__func__, 506, 88);

<bb 12>:
  switch_core_media_copy_t38_options (t38_options, other_session);
  D.47109 = 0;

<bb 13>:
  return D.47109;

}



;; Function switch_core_media_extract_t38_options (switch_core_media_extract_t38_options)

Scope blocks:

{ Scope block #0 
  struct sdp_media_t * m; (unused)
  struct sdp_parser_t * parser; (unused)
  struct sdp_session_t * sdp; (unused)
  struct switch_t38_options_t * t38_options; (unused)

}
switch_core_media_extract_t38_options (struct switch_core_session_t * session, const char * r_sdp)
{
  struct switch_t38_options_t * t38_options;
  struct sdp_session_t * sdp;
  struct sdp_parser_t * parser;
  struct sdp_media_t * m;
  long unsigned int D.47148;
  sdp_media_e D.47145;
  sdp_proto_e D.47142;
  struct switch_t38_options_t * D.47139;
  int D.47136;
  size_t D.47135;

<bb 2>:
  parser = 0B;
  t38_options = 0B;
  D.47135 = strlen (r_sdp);
  D.47136 = (int) D.47135;
  parser = sdp_parse (0B, r_sdp, D.47136, 0);
  if (parser == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.47139 = 0B;
  goto <bb 14>;

<bb 4>:
  sdp = sdp_session (parser);
  if (sdp == 0B)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  sdp_parser_free (parser);
  D.47139 = 0B;
  goto <bb 14>;

<bb 6>:
  m = sdp->sdp_media;
  goto <bb 12>;

<bb 7>:
  D.47142 = m->m_proto;
  if (D.47142 == 258)
    goto <bb 8>;
  else
    goto <bb 11>;

<bb 8>:
  D.47145 = m->m_type;
  if (D.47145 == 8)
    goto <bb 9>;
  else
    goto <bb 11>;

<bb 9>:
  D.47148 = m->m_port;
  if (D.47148 != 0)
    goto <bb 10>;
  else
    goto <bb 11>;

<bb 10>:
  t38_options = switch_core_media_process_udptl (session, sdp, m);
  goto <bb 13>;

<bb 11>:
  m = m->m_next;

<bb 12>:
  if (m != 0B)
    goto <bb 7>;
  else
    goto <bb 13>;

<bb 13>:
  sdp_parser_free (parser);
  D.47139 = t38_options;

<bb 14>:
  return D.47139;

}



;; Function switch_core_media_get_zrtp_hash (switch_core_media_get_zrtp_hash)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * engine; (unused)

}
switch_core_media_get_zrtp_hash (struct switch_core_session_t * session, switch_media_type_t type, switch_bool_t local)
{
  struct switch_rtp_engine_t * engine;
  unsigned int D.47157;
  struct switch_rtp_engine_t[2] * D.47156;
  const char * D.47155;
  struct switch_media_handle_t * D.47152;

<bb 2>:
  D.47152 = session->media_handle;
  if (D.47152 == 0B)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.47155 = 0B;
  goto <bb 7>;

<bb 4>:
  D.47152 = session->media_handle;
  D.47156 = &D.47152->engines;
  D.47157 = type * 11416;
  engine = D.47156 + D.47157;
  if (local != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47155 = engine->local_sdp_zrtp_hash;
  goto <bb 7>;

<bb 6>:
  D.47155 = engine->remote_sdp_zrtp_hash;

<bb 7>:
  return D.47155;

}



;; Function switch_core_media_pass_zrtp_hash (switch_core_media_pass_zrtp_hash)

Scope blocks:

{ Scope block #0 
  struct switch_channel_t * channel; (unused)
  struct switch_core_session_t * other_session; (unused)
  static const char __func__[33] = "switch_core_media_pass_zrtp_hash"; (unused)

}
switch_core_media_pass_zrtp_hash (struct switch_core_session_t * session)
{
  static const char __func__[33] = "switch_core_media_pass_zrtp_hash";
  struct switch_core_session_t * other_session;
  struct switch_channel_t * channel;
  struct switch_core_session_t * other_session.172;
  struct switch_core_session_t * D.47170;
  struct switch_core_session_t * D.47169;
  switch_status_t D.47166;
  struct switch_core_session_t * D.47165;
  uint32_t D.47162;
  struct switch_core_session_t * D.47161;

<bb 2>:
  channel = switch_core_session_get_channel (session);
  D.47161 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 289, D.47161, 101, "Deciding whether to pass zrtp-hash between legs\n");
  D.47162 = switch_channel_test_flag (channel, 73);
  if (D.47162 == 0)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  D.47165 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 291, D.47165, 101, "CF_ZRTP_PASSTHRU_REQ not set, so not propagating zrtp-hash\n");
  goto <bb 7>;

<bb 4>:
  D.47166 = switch_core_session_perform_get_partner (session, &other_session, "src/switch_core_media.c", &__func__, 293);
  if (D.47166 != 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47169 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 294, D.47169, 101, "No partner channel found, so not propagating zrtp-hash\n");
  goto <bb 7>;

<bb 6>:
  D.47170 = switch_channel_get_session (channel);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 297, D.47170, 101, "Found peer channel; propagating zrtp-hash if set\n");
  other_session.172 = other_session;
  switch_core_media_pass_zrtp_hash2 (session, other_session.172);
  other_session.172 = other_session;
  switch_core_session_rwunlock (other_session.172);

<bb 7>:
  return;

}



;; Function switch_core_media_pass_zrtp_hash2 (switch_core_media_pass_zrtp_hash2)

Scope blocks:

{ Scope block #0 

}
switch_core_media_pass_zrtp_hash2 (struct switch_core_session_t * aleg_session, struct switch_core_session_t * bleg_session)
{
<bb 2>:
  _switch_core_media_pass_zrtp_hash2 (aleg_session, bleg_session, 0);
  _switch_core_media_pass_zrtp_hash2 (aleg_session, bleg_session, 1);
  return;

}



;; Function _switch_core_media_pass_zrtp_hash2 (_switch_core_media_pass_zrtp_hash2)

Scope blocks:

{ Scope block #0 
  struct switch_rtp_engine_t * aleg_engine; (unused)
  struct switch_rtp_engine_t * bleg_engine; (unused)
  static const char __func__[35] = "_switch_core_media_pass_zrtp_hash2"; (unused)

}
Removing basic block 4
;; basic block 4, loop depth 0, count 0
;; prev block 3, next block 5
;; pred:      
;; succ:       11 (fallthru)
<bb 4>:
goto <bb 11>;


_switch_core_media_pass_zrtp_hash2 (struct switch_core_session_t * aleg_session, struct switch_core_session_t * bleg_session, switch_media_type_t type)
{
  static const char __func__[35] = "_switch_core_media_pass_zrtp_hash2";
  struct switch_rtp_engine_t * bleg_engine;
  struct switch_rtp_engine_t * aleg_engine;
  char * D.47199;
  char * D.47198;
  struct switch_core_session_t * D.47197;
  char * D.47194;
  char * D.47193;
  struct switch_channel_t * D.47192;
  char * D.47191;
  struct switch_core_session_t * D.47190;
  char * D.47187;
  struct switch_core_session_t * D.47186;
  uint32_t D.47183;
  struct switch_core_session_t * D.47182;
  struct switch_channel_t * D.47181;
  struct switch_rtp_engine_t[2] * D.47180;
  unsigned int D.47179;
  struct switch_rtp_engine_t[2] * D.47178;
  struct switch_media_handle_t * D.47177;
  struct switch_media_handle_t * D.47175;

<bb 2>:
  D.47175 = aleg_session->media_handle;
  if (D.47175 == 0B)
    goto <bb 10>;
  else
    goto <bb 3>;

<bb 3>:
  D.47177 = bleg_session->media_handle;
  if (D.47177 == 0B)
    goto <bb 10>;
  else
    goto <bb 4>;

<bb 4>:
  D.47175 = aleg_session->media_handle;
  D.47178 = &D.47175->engines;
  D.47179 = type * 11416;
  aleg_engine = D.47178 + D.47179;
  D.47177 = bleg_session->media_handle;
  D.47180 = &D.47177->engines;
  D.47179 = type * 11416;
  bleg_engine = D.47180 + D.47179;
  D.47181 = aleg_session->channel;
  D.47182 = switch_channel_get_session (D.47181);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 255, D.47182, 101, "Deciding whether to pass zrtp-hash between a-leg and b-leg\n");
  D.47181 = aleg_session->channel;
  D.47183 = switch_channel_test_flag (D.47181, 73);
  if (D.47183 == 0)
    goto <bb 5>;
  else
    goto <bb 6>;

<bb 5>:
  D.47181 = aleg_session->channel;
  D.47186 = switch_channel_get_session (D.47181);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 259, D.47186, 101, "CF_ZRTP_PASSTHRU_REQ not set on a-leg, so not propagating zrtp-hash\n");
  goto <bb 10>;

<bb 6>:
  D.47187 = aleg_engine->remote_sdp_zrtp_hash;
  if (D.47187 != 0B)
    goto <bb 7>;
  else
    goto <bb 8>;

<bb 7>:
  D.47181 = aleg_session->channel;
  D.47190 = switch_channel_get_session (D.47181);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 265, D.47190, 7, "Passing a-leg remote zrtp-hash (audio) to b-leg\n");
  D.47187 = aleg_engine->remote_sdp_zrtp_hash;
  D.47191 = switch_core_perform_session_strdup (bleg_session, D.47187, "src/switch_core_media.c", &__func__, 266);
  bleg_engine->local_sdp_zrtp_hash = D.47191;
  D.47192 = bleg_session->channel;
  D.47193 = bleg_engine->local_sdp_zrtp_hash;
  switch_channel_set_variable_var_check (D.47192, "l_sdp_audio_zrtp_hash", D.47193, 1);

<bb 8>:
  D.47194 = bleg_engine->remote_sdp_zrtp_hash;
  if (D.47194 != 0B)
    goto <bb 9>;
  else
    goto <bb 10>;

<bb 9>:
  D.47181 = aleg_session->channel;
  D.47197 = switch_channel_get_session (D.47181);
  switch_log_printf (3, "src/switch_core_media.c", &__func__, 271, D.47197, 7, "Passing b-leg remote zrtp-hash (audio) to a-leg\n");
  D.47194 = bleg_engine->remote_sdp_zrtp_hash;
  D.47198 = switch_core_perform_session_strdup (aleg_session, D.47194, "src/switch_core_media.c", &__func__, 272);
  aleg_engine->local_sdp_zrtp_hash = D.47198;
  D.47181 = aleg_session->channel;
  D.47199 = aleg_engine->local_sdp_zrtp_hash;
  switch_channel_set_variable_var_check (D.47181, "l_sdp_audio_zrtp_hash", D.47199, 1);

<bb 10>:
  return;

}



;; Function switch_core_media_crypto_keylen (switch_core_media_crypto_keylen)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_crypto_keylen"; (unused)

}
Merging blocks 4 and 5
switch_core_media_crypto_keylen (switch_rtp_crypto_key_type_t type)
{
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_crypto_keylen";
  int D.47203;

<bb 2>:
  if (type > 8)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("type < CRYPTO_INVALID", "src/switch_core_media.c", 229, &__PRETTY_FUNCTION__);

<bb 4>:
  D.47203 = SUITES[type].keylen;
  return D.47203;

}



;; Function switch_core_media_crypto_type2str (switch_core_media_crypto_type2str)

Scope blocks:

{ Scope block #0 
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_crypto_type2str"; (unused)

}
Merging blocks 4 and 5
switch_core_media_crypto_type2str (switch_rtp_crypto_key_type_t type)
{
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_crypto_type2str";
  const char * D.47207;

<bb 2>:
  if (type > 8)
    goto <bb 3>;
  else
    goto <bb 4>;

<bb 3>:
  __assert_fail ("type < CRYPTO_INVALID", "src/switch_core_media.c", 222, &__PRETTY_FUNCTION__);

<bb 4>:
  D.47207 = SUITES[type].name;
  return D.47207;

}



;; Function switch_core_media_crypto_str2type (switch_core_media_crypto_str2type)

Scope blocks:

{ Scope block #0 
  int i; (unused)

}
switch_core_media_crypto_str2type (const char * str)
{
  int i;
  switch_rtp_crypto_key_type_t D.47214;
  int D.47211;
  size_t D.47210;
  char * D.47209;

<bb 2>:
  i = 0;
  goto <bb 6>;

<bb 3>:
  D.47209 = SUITES[i].name;
  D.47209 = SUITES[i].name;
  D.47210 = strlen (D.47209);
  D.47211 = strncasecmp (str, D.47209, D.47210);
  if (D.47211 == 0)
    goto <bb 4>;
  else
    goto <bb 5>;

<bb 4>:
  D.47214 = SUITES[i].type;
  goto <bb 8>;

<bb 5>:
  i = i + 1;

<bb 6>:
  if (i <= 8)
    goto <bb 3>;
  else
    goto <bb 7>;

<bb 7>:
  D.47214 = 9;

<bb 8>:
  return D.47214;

}


