
;; Function atof (null)
;; enabled by -tree-original


{
  return strtod (__nptr, 0B);
}



;; Function atoi (null)
;; enabled by -tree-original

{
  return (int) strtol (__nptr, 0B, 10);
}



;; Function atol (null)
;; enabled by -tree-original

{
  return strtol (__nptr, 0B, 10);
}



;; Function atoll (null)
;; enabled by -tree-original

{
  return strtoll (__nptr, 0B, 10);
}



;; Function gnu_dev_major (null)
;; enabled by -tree-original

{
  return (unsigned int) (__dev >> 8) & 4095 | (unsigned int) (__dev >> 32) & 4294963200;
}



;; Function gnu_dev_minor (null)
;; enabled by -tree-original

{
  return (unsigned int) __dev & 255 | (unsigned int) (__dev >> 12) & 4294967040;
}



;; Function gnu_dev_makedev (null)
;; enabled by -tree-original

{
  return ((long long unsigned int) (__minor & 255 | (__major & 4095) << 8) | ((long long unsigned int) __minor & 4294967040) << 12) | ((long long unsigned int) __major & 4294963200) << 32;
}



;; Function vprintf (null)
;; enabled by -tree-original

{
  return vfprintf ((struct FILE * restrict) stdout, __fmt, __arg);
}



;; Function getchar (null)
;; enabled by -tree-original

{
  return _IO_getc ((struct _IO_FILE *) stdin);
}



;; Function fgetc_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow ((struct _IO_FILE *) __fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}



;; Function getc_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow ((struct _IO_FILE *) __fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}



;; Function getchar_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (stdin->_IO_read_ptr >= stdin->_IO_read_end, 0) != 0 ? __uflow ((struct _IO_FILE *) stdin) : (int) *(unsigned char *) stdin->_IO_read_ptr++ ;
}



;; Function putchar (null)
;; enabled by -tree-original

{
  return _IO_putc (__c, (struct _IO_FILE *) stdout);
}



;; Function fputc_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow ((struct _IO_FILE *) __stream, (int) (unsigned char) __c) : (int) (*__stream->_IO_write_ptr++  = (char) __c);
}



;; Function putc_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow ((struct _IO_FILE *) __stream, (int) (unsigned char) __c) : (int) (*__stream->_IO_write_ptr++  = (char) __c);
}



;; Function putchar_unlocked (null)
;; enabled by -tree-original

{
  return __builtin_expect (stdout->_IO_write_ptr >= stdout->_IO_write_end, 0) != 0 ? __overflow ((struct _IO_FILE *) stdout, (int) (unsigned char) __c) : (int) (*stdout->_IO_write_ptr++  = (char) __c);
}



;; Function getline (null)
;; enabled by -tree-original

{
  return __getdelim (__lineptr, __n, 10, __stream);
}



;; Function feof_unlocked (null)
;; enabled by -tree-original

{
  return (__stream->_flags & 16) != 0;
}



;; Function ferror_unlocked (null)
;; enabled by -tree-original

{
  return (__stream->_flags & 32) != 0;
}



;; Function tolower (null)
;; enabled by -tree-original

{
  return (unsigned int) __c + 128 <= 383 ? (int) *(*__ctype_tolower_loc () + (unsigned int) ((unsigned int) __c * 4)) : __c;
}



;; Function toupper (null)
;; enabled by -tree-original

{
  return (unsigned int) __c + 128 <= 383 ? (int) *(*__ctype_toupper_loc () + (unsigned int) ((unsigned int) __c * 4)) : __c;
}



;; Function __strcspn_c1 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2842>;
  <D.2841>:;
   ++__result;
  <D.2842>:;
  if ((unsigned char) *(__s + (unsigned int) __result) != 0 && (int) *(__s + (unsigned int) __result) != __reject) goto <D.2841>; else goto <D.2843>;
  <D.2843>:;
  return __result;
}



;; Function __strcspn_c2 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2855>;
  <D.2854>:;
   ++__result;
  <D.2855>:;
  if (((unsigned char) *(__s + (unsigned int) __result) != 0 && (int) *(__s + (unsigned int) __result) != __reject1) && (int) *(__s + (unsigned int) __result) != __reject2) goto <D.2854>; else goto <D.2856>;
  <D.2856>:;
  return __result;
}



;; Function __strcspn_c3 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2870>;
  <D.2869>:;
   ++__result;
  <D.2870>:;
  if ((((unsigned char) *(__s + (unsigned int) __result) != 0 && (int) *(__s + (unsigned int) __result) != __reject1) && (int) *(__s + (unsigned int) __result) != __reject2) && (int) *(__s + (unsigned int) __result) != __reject3) goto <D.2869>; else goto <D.2871>;
  <D.2871>:;
  return __result;
}



;; Function __strspn_c1 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2881>;
  <D.2880>:;
   ++__result;
  <D.2881>:;
  if ((int) *(__s + (unsigned int) __result) == __accept) goto <D.2880>; else goto <D.2882>;
  <D.2882>:;
  return __result;
}



;; Function __strspn_c2 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2894>;
  <D.2893>:;
   ++__result;
  <D.2894>:;
  if ((int) *(__s + (unsigned int) __result) == __accept1 || (int) *(__s + (unsigned int) __result) == __accept2) goto <D.2893>; else goto <D.2895>;
  <D.2895>:;
  return __result;
}



;; Function __strspn_c3 (null)
;; enabled by -tree-original

{
  register size_t __result = 0;

    register size_t __result = 0;
  goto <D.2909>;
  <D.2908>:;
   ++__result;
  <D.2909>:;
  if (((int) *(__s + (unsigned int) __result) == __accept1 || (int) *(__s + (unsigned int) __result) == __accept2) || (int) *(__s + (unsigned int) __result) == __accept3) goto <D.2908>; else goto <D.2910>;
  <D.2910>:;
  return __result;
}



;; Function __strpbrk_c2 (null)
;; enabled by -tree-original

{
  goto <D.2921>;
  <D.2920>:;
   ++__s;
  <D.2921>:;
  if (((unsigned char) *__s != 0 && (int) *__s != __accept1) && (int) *__s != __accept2) goto <D.2920>; else goto <D.2922>;
  <D.2922>:;
  return (unsigned char) *__s != 0 ? (char *) __s : 0B;
}



;; Function __strpbrk_c3 (null)
;; enabled by -tree-original

{
  goto <D.2935>;
  <D.2934>:;
   ++__s;
  <D.2935>:;
  if ((((unsigned char) *__s != 0 && (int) *__s != __accept1) && (int) *__s != __accept2) && (int) *__s != __accept3) goto <D.2934>; else goto <D.2936>;
  <D.2936>:;
  return (unsigned char) *__s != 0 ? (char *) __s : 0B;
}



;; Function __strtok_r_1c (null)
;; enabled by -tree-original

{
  char * __result;

    char * __result;
  if (__s == 0B)
    {
      __s = *__nextp;
    }
  goto <D.2948>;
  <D.2947>:;
   ++__s;
  <D.2948>:;
  if ((unsigned char) *__s == (unsigned char) __sep) goto <D.2947>; else goto <D.2949>;
  <D.2949>:;
  __result = 0B;
  if ((unsigned char) *__s != 0)
    {
      __result = __s++ ;
      goto <D.2952>;
      <D.2951>:;
      if ((unsigned char) *__s++  == (unsigned char) __sep)
        {
          *(__s + -1) = 0;
          goto <D.2950>;
        }
      <D.2952>:;
      if ((unsigned char) *__s != 0) goto <D.2951>; else goto <D.2950>;
      <D.2950>:;
    }
  *__nextp = __s;
  return __result;
}



;; Function __strsep_1c (null)
;; enabled by -tree-original

{
  register char * __retval = *__s;

    register char * __retval = *__s;
  if (__retval != 0B && (*__s = __builtin_constant_p ((int) __reject) != 0 && (unsigned char) __reject == 0 ? (char *) __rawmemchr ((const void *) __retval, (int) __reject) : __builtin_strchr ((const char *) __retval, (int) __reject)) != 0B)
    {
      **__s++  = 0;
    }
  return __retval;
}



;; Function __strsep_2c (null)
;; enabled by -tree-original

{
  register char * __retval = *__s;

    register char * __retval = *__s;
  if (__retval != 0B)
    {
      {
        register char * __cp = __retval;

                register char * __cp = __retval;
        <D.2976>:;
        if ((unsigned char) *__cp == 0)
          {
            __cp = 0B;
            goto <D.2975>;
          }
        if ((unsigned char) *__cp == (unsigned char) __reject1 || (unsigned char) *__cp == (unsigned char) __reject2)
          {
            *__cp++  = 0;
            goto <D.2975>;
          }
         ++__cp;
        goto <D.2976>;
        <D.2975>:;
        *__s = __cp;
      }
    }
  return __retval;
}



;; Function __strsep_3c (null)
;; enabled by -tree-original

{
  register char * __retval = *__s;

    register char * __retval = *__s;
  if (__retval != 0B)
    {
      {
        register char * __cp = __retval;

                register char * __cp = __retval;
        <D.2991>:;
        if ((unsigned char) *__cp == 0)
          {
            __cp = 0B;
            goto <D.2990>;
          }
        if (((unsigned char) *__cp == (unsigned char) __reject1 || (unsigned char) *__cp == (unsigned char) __reject2) || (unsigned char) *__cp == (unsigned char) __reject3)
          {
            *__cp++  = 0;
            goto <D.2990>;
          }
         ++__cp;
        goto <D.2991>;
        <D.2990>:;
        *__s = __cp;
      }
    }
  return __retval;
}



;; Function stat (null)
;; enabled by -tree-original

{
  return __xstat (3, __path, __statbuf);
}



;; Function lstat (null)
;; enabled by -tree-original

{
  return __lxstat (3, __path, __statbuf);
}



;; Function fstat (null)
;; enabled by -tree-original

{
  return __fxstat (3, __fd, __statbuf);
}



;; Function fstatat (null)
;; enabled by -tree-original

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



;; Function mknod (null)
;; enabled by -tree-original

{
  return __xmknod (1, __path, __mode, &__dev);
}



;; Function mknodat (null)
;; enabled by -tree-original

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}



;; Function stat64 (null)
;; enabled by -tree-original

{
  return __xstat64 (3, __path, __statbuf);
}



;; Function lstat64 (null)
;; enabled by -tree-original

{
  return __lxstat64 (3, __path, __statbuf);
}



;; Function fstat64 (null)
;; enabled by -tree-original

{
  return __fxstat64 (3, __fd, __statbuf);
}



;; Function fstatat64 (null)
;; enabled by -tree-original

{
  return __fxstatat64 (3, __fd, __filename, __statbuf, __flag);
}



;; Function __sigismember (null)
;; enabled by -tree-original

{
  long unsigned int __mask = 1 << (__sig + -1 & 31);
  long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);

    long unsigned int __mask = 1 << (__sig + -1 & 31);
    long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);
  return ((long unsigned int) __set->__val[__word] & __mask) != 0;
}



;; Function __sigaddset (null)
;; enabled by -tree-original

{
  long unsigned int __mask = 1 << (__sig + -1 & 31);
  long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);

    long unsigned int __mask = 1 << (__sig + -1 & 31);
    long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);
  return __set->__val[__word] = __set->__val[__word] | __mask;, 0;
}



;; Function __sigdelset (null)
;; enabled by -tree-original

{
  long unsigned int __mask = 1 << (__sig + -1 & 31);
  long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);

    long unsigned int __mask = 1 << (__sig + -1 & 31);
    long unsigned int __word = (long unsigned int) ((unsigned int) (__sig + -1) / 32);
  return __set->__val[__word] = __set->__val[__word] & ~__mask;, 0;
}



;; Function strtoimax (null)
;; enabled by -tree-original

{
  return (intmax_t) __strtoll_internal (nptr, endptr, base, 0);
}



;; Function strtoumax (null)
;; enabled by -tree-original

{
  return (uintmax_t) __strtoull_internal (nptr, endptr, base, 0);
}



;; Function wcstoimax (null)
;; enabled by -tree-original

{
  return (intmax_t) __wcstoll_internal (nptr, endptr, base, 0);
}



;; Function wcstoumax (null)
;; enabled by -tree-original

{
  return (uintmax_t) __wcstoull_internal (nptr, endptr, base, 0);
}



;; Function __cmsg_nxthdr (null)
;; enabled by -tree-original

{
  if (__cmsg->cmsg_len <= 11)
    {
      return 0B;
    }
  __cmsg = __cmsg + ((unsigned int) (__cmsg->cmsg_len + 3) & -4);
  if ((unsigned char *) __cmsg + 12 > (unsigned char *) __mhdr->msg_control + (unsigned int) __mhdr->msg_controllen || (unsigned char *) __cmsg + ((unsigned int) (__cmsg->cmsg_len + 3) & -4) > (unsigned char *) __mhdr->msg_control + (unsigned int) __mhdr->msg_controllen)
    {
      return 0B;
    }
  return __cmsg;
}



;; Function json_add_child_obj (null)
;; enabled by -tree-original

{
  struct cJSON * new_json = 0B;
  static const char __PRETTY_FUNCTION__[19] = "json_add_child_obj";

    static const char __PRETTY_FUNCTION__[19] = "json_add_child_obj";
    struct cJSON * new_json = 0B;
  if (json == 0B)
    {
      __assert_fail ((const char *) "json", (const char *) "./src/include/switch_json.h", 137, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if (obj != 0B)
    {
      new_json = obj;
    }
  else
    {
      new_json = cJSON_CreateObject ();
    }
  if (new_json == 0B)
    {
      __assert_fail ((const char *) "new_json", (const char *) "./src/include/switch_json.h", 145, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  cJSON_AddItemToObject (json, name, new_json);
  return new_json;
}



;; Function json_add_child_array (null)
;; enabled by -tree-original

{
  struct cJSON * new_json = 0B;
  static const char __PRETTY_FUNCTION__[21] = "json_add_child_array";

    static const char __PRETTY_FUNCTION__[21] = "json_add_child_array";
    struct cJSON * new_json = 0B;
  if (json == 0B)
    {
      __assert_fail ((const char *) "json", (const char *) "./src/include/switch_json.h", 156, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  new_json = cJSON_CreateArray ();
  if (new_json == 0B)
    {
      __assert_fail ((const char *) "new_json", (const char *) "./src/include/switch_json.h", 159, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  cJSON_AddItemToObject (json, name, new_json);
  return new_json;
}



;; Function json_add_child_string (null)
;; enabled by -tree-original

{
  struct cJSON * new_json = 0B;
  static const char __PRETTY_FUNCTION__[22] = "json_add_child_string";

    static const char __PRETTY_FUNCTION__[22] = "json_add_child_string";
    struct cJSON * new_json = 0B;
  if (json == 0B)
    {
      __assert_fail ((const char *) "json", (const char *) "./src/include/switch_json.h", 170, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  new_json = cJSON_CreateString (val);
  if (new_json == 0B)
    {
      __assert_fail ((const char *) "new_json", (const char *) "./src/include/switch_json.h", 173, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  cJSON_AddItemToObject (json, name, new_json);
  return new_json;
}



;; Function pthread_equal (null)
;; enabled by -tree-original

{
  return __thread1 == __thread2;
}



;; Function switch_cache_db_type_name (null)
;; enabled by -tree-original

{
  const char * type_str = (const char *) "INVALID";

    const char * type_str = (const char *) "INVALID";
  switch ((unsigned int) type)
    {
      case 2:;
      type_str = (const char *) "PGSQL";
      goto <D.9360>;
      case 1:;
      type_str = (const char *) "ODBC";
      goto <D.9360>;
      case 0:;
      type_str = (const char *) "CORE_DB";
      goto <D.9360>;
    }
  <D.9360>:;
  return type_str;
}



;; Function switch_check_interval (null)
;; enabled by -tree-original

{
  uint32_t max_ms = 0;
  uint32_t ptime_div = 0;

    uint32_t max_ms = 0;
    uint32_t ptime_div = 0;
  switch (rate)
    {
      case 22050:;
      case 11025:;
      if (ptime <= 119)
        {
          return 1;
        }
      goto <D.10441>;
      case 48000:;
      max_ms = 40;
      ptime_div = 2;
      goto <D.10441>;
      case 32000:;
      case 24000:;
      case 16000:;
      max_ms = 60;
      ptime_div = 2;
      goto <D.10441>;
      case 12000:;
      max_ms = 100;
      ptime_div = 2;
      goto <D.10441>;
      case 8000:;
      max_ms = 120;
      ptime_div = 2;
      goto <D.10441>;
    }
  <D.10441>:;
  if (((max_ms != 0 && ptime_div != 0) && (ptime <= max_ms && ptime % ptime_div == 0)) && (rate / 1000) * ptime <= 4095)
    {
      return 1;
    }
  return 0;
}



;; Function switch_core_codec_add_implementation (null)
;; enabled by -tree-original

{
  static const char __func__[37] = "switch_core_codec_add_implementation";

    static const char __func__[37] = "switch_core_codec_add_implementation";
  if (decoded_bytes_per_packet > 4096)
    {
      switch_log_printf (0, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 498, 0B, 2, (const char *) "Rejected codec name: %s rate: %u ptime: %d not enough buffer space %u > %d\n", iananame, actual_samples_per_second, microseconds_per_packet / 1000, decoded_bytes_per_packet, 4096);
    }
  else
    {
      if ((unsigned int) codec_type == 1 || switch_check_interval (actual_samples_per_second, (uint32_t) (microseconds_per_packet / 1000)) != 0)
        {
          {
            struct switch_codec_implementation_t * impl = (struct switch_codec_implementation_t *) switch_core_perform_alloc (pool, 80, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 501);

                        struct switch_codec_implementation_t * impl = (struct switch_codec_implementation_t *) switch_core_perform_alloc (pool, 80, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 501);
            impl->codec_type = codec_type;
            impl->ianacode = ianacode;
            impl->iananame = switch_core_perform_strdup (pool, iananame, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 504);
            impl->fmtp = switch_core_perform_strdup (pool, (const char *) fmtp, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 505);
            impl->samples_per_second = samples_per_second;
            impl->actual_samples_per_second = actual_samples_per_second;
            impl->bits_per_second = bits_per_second;
            impl->microseconds_per_packet = microseconds_per_packet;
            impl->samples_per_packet = samples_per_packet;
            impl->decoded_bytes_per_packet = decoded_bytes_per_packet;
            impl->encoded_bytes_per_packet = encoded_bytes_per_packet;
            impl->number_of_channels = number_of_channels;
            impl->codec_frames_per_packet = codec_frames_per_packet;
            impl->init = init;
            impl->encode = encode;
            impl->decode = decode;
            impl->destroy = destroy;
            impl->codec_id = codec_interface->codec_id;
            impl->next = (struct switch_codec_implementation *) codec_interface->implementations;
            impl->impl_id = switch_core_codec_next_id ();
            codec_interface->implementations = impl;
          }
        }
      else
        {
          switch_log_printf (0, (const char *) "./src/include/switch_loadable_module.h", (const char *) &__func__, 524, 0B, 2, (const char *) "Rejected codec name: %s rate: %u ptime: %d\n", iananame, actual_samples_per_second, microseconds_per_packet / 1000);
        }
    }
}



;; Function switch_core_codec_ready (null)
;; enabled by -tree-original

{
  return (switch_bool_t) ((((codec != 0B && (codec->flags & 256) != 0) && codec->mutex != 0B) && codec->codec_interface != 0B) && codec->implementation != 0B);
}



;; Function switch_toupper (null)
;; enabled by -tree-original

{
  uint32_t ebx = (uint32_t) (((long unsigned int) eax & 2139062143) + 84215045);

    uint32_t ebx = (uint32_t) (((long unsigned int) eax & 2139062143) + 84215045);
  ebx = (uint32_t) (((long unsigned int) ebx & 2139062143) + 437918234);
  ebx = (~eax & ebx) >> 2 & 538976288;
  return eax - ebx;
}



;; Function switch_tolower (null)
;; enabled by -tree-original

{
  uint32_t ebx = (uint32_t) (((long unsigned int) eax & 2139062143) + 623191333);

    uint32_t ebx = (uint32_t) (((long unsigned int) eax & 2139062143) + 623191333);
  ebx = (uint32_t) (((long unsigned int) ebx & 2139062143) + 437918234);
  ebx = (~eax & ebx) >> 2 & 538976288;
  return eax + ebx;
}



;; Function switch_toupper_max (null)
;; enabled by -tree-original

{
  uint32_t * b;
  uint32_t * p;
  char * c;
  size_t l;

    uint32_t * b;
    uint32_t * p;
    char * c;
    size_t l;
  l = strlen ((const char *) s);
  p = (uint32_t *) s;
  goto <D.10554>;
  <D.10553>:;
  b = p;
  *b = switch_toupper (*b);
  b++ ;
  p++ ;
  l = l + 4294967292;
  <D.10554>:;
  if (l > 4) goto <D.10553>; else goto <D.10555>;
  <D.10555>:;
  c = (char *) p;
  goto <D.10557>;
  <D.10556>:;
  *c = (char) switch_toupper ((uint32_t) *c);
  c++ ;
  l-- ;
  <D.10557>:;
  if (l != 0) goto <D.10556>; else goto <D.10558>;
  <D.10558>:;
}



;; Function switch_tolower_max (null)
;; enabled by -tree-original

{
  uint32_t * b;
  uint32_t * p;
  char * c;
  size_t l;

    uint32_t * b;
    uint32_t * p;
    char * c;
    size_t l;
  l = strlen ((const char *) s);
  p = (uint32_t *) s;
  goto <D.10567>;
  <D.10566>:;
  b = p;
  *b = switch_tolower (*b);
  b++ ;
  p++ ;
  l = l + 4294967292;
  <D.10567>:;
  if (l > 4) goto <D.10566>; else goto <D.10568>;
  <D.10568>:;
  c = (char *) p;
  goto <D.10570>;
  <D.10569>:;
  *c = (char) switch_tolower ((uint32_t) *c);
  c++ ;
  l-- ;
  <D.10570>:;
  if (l != 0) goto <D.10569>; else goto <D.10571>;
  <D.10571>:;
}



;; Function _zstr (null)
;; enabled by -tree-original

{
  return s == 0B || (unsigned char) *s == 0;
}



;; Function switch_is_moh (null)
;; enabled by -tree-original

{
  if ((_zstr (s) != 0 || strcasecmp (s, (const char *) "silence") == 0) || strcasecmp (s, (const char *) "indicate_hold") == 0)
    {
      return 0;
    }
  return 1;
}



;; Function switch_strchr_strict (null)
;; enabled by -tree-original

{
  const char * p;
  static const char __PRETTY_FUNCTION__[21] = "switch_strchr_strict";

    static const char __PRETTY_FUNCTION__[21] = "switch_strchr_strict";
    const char * p;
  if (in == 0B)
    {
      __assert_fail ((const char *) "in", (const char *) "./src/include/switch_utils.h", 283, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  p = in;
  if ((unsigned char) *p == 0)
    {
      return 0B;
    }
  goto <D.10630>;
  <D.10629>:;
  {
    const char * a = allowed;
    int acceptable = 0;

        const char * a = allowed;
        int acceptable = 0;
    if ((unsigned char) *p == (unsigned char) find)
      {
        goto <D.10625>;
      }
    if (a == 0B)
      {
        acceptable = 1;
      }
    else
      {
        goto <D.10628>;
        <D.10627>:;
        if ((unsigned char) *p == (unsigned char) *a)
          {
            acceptable = 1;
            goto <D.10626>;
          }
        a++ ;
        <D.10628>:;
        if (a != 0B && (unsigned char) *a != 0) goto <D.10627>; else goto <D.10626>;
        <D.10626>:;
      }
    if (acceptable == 0)
      {
        return 0B;
      }
    p++ ;
  }
  <D.10630>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10629>; else goto <D.10625>;
  <D.10625>:;
  return (char *) p;
}



;; Function switch_string_has_escaped_data (null)
;; enabled by -tree-original

{
  const char * i;
  static const char __PRETTY_FUNCTION__[31] = "switch_string_has_escaped_data";

    static const char __PRETTY_FUNCTION__[31] = "switch_string_has_escaped_data";
    const char * i;
  if (in == 0B)
    {
      __assert_fail ((const char *) "in", (const char *) "./src/include/switch_utils.h", 332, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  i = (const char *) __builtin_strchr (in, 92);
  goto <D.10637>;
  <D.10636>:;
  i++ ;
  if ((((*i == 92 || *i == 110) || (unsigned char) *i == 115) || (unsigned char) *i == 116) || (unsigned char) *i == 39)
    {
      return 1;
    }
  i = (const char *) __builtin_strchr (i, 92);
  <D.10637>:;
  if (i != 0B && (unsigned char) *i == 92) goto <D.10636>; else goto <D.10638>;
  <D.10638>:;
  return 0;
}



;; Function switch_is_digit_string (null)
;; enabled by -tree-original

{
  goto <D.10656>;
  <D.10655>:;
  if (*s + 208 > 9)
    {
      return 0;
    }
  s++ ;
  <D.10656>:;
  if (s != 0B && (unsigned char) *s != 0) goto <D.10655>; else goto <D.10657>;
  <D.10657>:;
  return 1;
}



;; Function switch_itodtmf (null)
;; enabled by -tree-original

{
  char r = i;

    char r = i;
  if (i + 246 <= 3)
    {
      r = r + 55;
    }
  else
    {
      r = r + 48;
    }
  return r;
}



;; Function switch_dtmftoi (null)
;; enabled by -tree-original

{
  int r;
  static const char __PRETTY_FUNCTION__[15] = "switch_dtmftoi";

    static const char __PRETTY_FUNCTION__[15] = "switch_dtmftoi";
    int r;
  if (s == 0B)
    {
      __assert_fail ((const char *) "s", (const char *) "./src/include/switch_utils.h", 384, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((r = atoi ((const char *) s)) == 0)
    {
      {
        int l = TARGET_EXPR <D.10670, {
          int __res;

                    int __res;
          {
            if (0)
              {
                if (__builtin_constant_p ((int) *s) != 0)
                  {
                    {
                      int __c = (int) *s;

                                            int __c = (int) *s;
                      __res = (unsigned int) __c + 128 <= 383 ? (const int) *(*__ctype_tolower_loc () + (unsigned int) ((unsigned int) __c * 4)) : (const int) __c;
                    }
                  }
                else
                  {
                    __res = tolower ((int) *s);
                  }
              }
            else
              {
                __res = *(*__ctype_tolower_loc () + (unsigned int) ((unsigned int) *s * 4));
              }
          }
          D.10670 = __res;
        }>;

                int l = TARGET_EXPR <D.10670, {
          int __res;

                    int __res;
          {
            if (0)
              {
                if (__builtin_constant_p ((int) *s) != 0)
                  {
                    {
                      int __c = (int) *s;

                                            int __c = (int) *s;
                      __res = (unsigned int) __c + 128 <= 383 ? (const int) *(*__ctype_tolower_loc () + (unsigned int) ((unsigned int) __c * 4)) : (const int) __c;
                    }
                  }
                else
                  {
                    __res = tolower ((int) *s);
                  }
              }
            else
              {
                __res = *(*__ctype_tolower_loc () + (unsigned int) ((unsigned int) *s * 4));
              }
          }
          D.10670 = __res;
        }>;
        if ((unsigned int) l + 4294967199 <= 3)
          {
            r = l + -87;
          }
      }
    }
  return r;
}



;; Function switch_known_bitrate (null)
;; enabled by -tree-original

{
  switch ((int) payload)
    {
      case 0:;
      return 64000;
      case 3:;
      return 13200;
      case 4:;
      return 6300;
      case 7:;
      return 2400;
      case 8:;
      return 64000;
      case 9:;
      return 64000;
      case 18:;
      return 8000;
      default:;
      goto <D.10682>;
    }
  <D.10682>:;
  return 0;
}



;; Function switch_true (null)
;; enabled by -tree-original

{
  return expr != 0B && (((((((strcasecmp (expr, (const char *) "yes") == 0 || strcasecmp (expr, (const char *) "on") == 0) || strcasecmp (expr, (const char *) "true") == 0) || strcasecmp (expr, (const char *) "t") == 0) || strcasecmp (expr, (const char *) "enabled") == 0) || strcasecmp (expr, (const char *) "active") == 0) || strcasecmp (expr, (const char *) "allow") == 0) || (unsigned int) switch_is_number (expr) != 0 && atoi (expr) != 0);
}



;; Function switch_true_byte (null)
;; enabled by -tree-original

{
  return (switch_byte_t) switch_true (expr);
}



;; Function switch_false (null)
;; enabled by -tree-original

{
  return expr != 0B && (((((((strcasecmp (expr, (const char *) "no") == 0 || strcasecmp (expr, (const char *) "off") == 0) || strcasecmp (expr, (const char *) "false") == 0) || strcasecmp (expr, (const char *) "f") == 0) || strcasecmp (expr, (const char *) "disabled") == 0) || strcasecmp (expr, (const char *) "inactive") == 0) || strcasecmp (expr, (const char *) "disallow") == 0) || (unsigned int) switch_is_number (expr) != 0 && atoi (expr) == 0);
}



;; Function switch_sanitize_number (null)
;; enabled by -tree-original

{
  char * p = number;
  char * q;
  char warp[3] = "/:";
  int i;
  static const char __PRETTY_FUNCTION__[23] = "switch_sanitize_number";

    static const char __PRETTY_FUNCTION__[23] = "switch_sanitize_number";
    char * p = number;
    char * q;
    char warp[3] = "/:";
    int i;
  if (number == 0B)
    {
      __assert_fail ((const char *) "number", (const char *) "./src/include/switch_utils.h", 628, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((__builtin_strchr ((const char *) p, 47) == 0B && __builtin_strchr ((const char *) p, 58) == 0B) && __builtin_strchr ((const char *) p, 64) == 0B)
    {
      return number;
    }
  goto <D.10776>;
  <D.10775>:;
  *q = 0;
  <D.10776>:;
  if ((q = strrchr ((const char *) p, 64)) != 0B) goto <D.10775>; else goto <D.10777>;
  <D.10777>:;
  i = 0;
  goto <D.10782>;
  <D.10781>:;
  goto <D.10779>;
  <D.10778>:;
  p = q + 1;
  <D.10779>:;
  if (p != 0B && (q = __builtin_constant_p ((int) warp[i]) != 0 && (unsigned char) warp[i] == 0 ? (char *) __rawmemchr ((const void *) p, (int) warp[i]) : __builtin_strchr ((const char *) p, (int) warp[i])) != 0B) goto <D.10778>; else goto <D.10780>;
  <D.10780>:;
  i++ ;
  <D.10782>:;
  if ((int) strlen ((const char *) &warp) > i) goto <D.10781>; else goto <D.10783>;
  <D.10783>:;
  return p;
}



;; Function switch_string_var_check (null)
;; enabled by -tree-original

{
  char * p;
  char * dol = 0B;

    char * p;
    char * dol = 0B;
  p = s;
  goto <D.10791>;
  <D.10790>:;
  if ((unsigned char) *p == 36)
    {
      dol = p;
    }
  else
    {
      if (dol != 0B)
        {
          if ((unsigned char) *p == 123)
            {
              if ((unsigned int) disable != 0)
                {
                  *dol = 37;
                  dol = 0B;
                }
              else
                {
                  return 1;
                }
            }
          else
            {
              if ((unsigned char) *p != 92)
                {
                  dol = 0B;
                }
            }
        }
    }
  p++ ;
  <D.10791>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10790>; else goto <D.10792>;
  <D.10792>:;
  return 0;
}



;; Function switch_string_var_check_const (null)
;; enabled by -tree-original

{
  const char * p;
  int dol = 0;

    const char * p;
    int dol = 0;
  p = s;
  goto <D.10799>;
  <D.10798>:;
  if ((unsigned char) *p == 36)
    {
      dol = 1;
    }
  else
    {
      if (dol != 0)
        {
          if ((unsigned char) *p == 123)
            {
              return 1;
            }
          else
            {
              if ((unsigned char) *p != 92)
                {
                  dol = 0;
                }
            }
        }
    }
  p++ ;
  <D.10799>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10798>; else goto <D.10800>;
  <D.10800>:;
  return 0;
}



;; Function switch_var_clean_string (null)
;; enabled by -tree-original

{
  switch_string_var_check (s, 1);
  return s;
}



;; Function switch_clean_string (null)
;; enabled by -tree-original

{
  char * p;

    char * p;
  p = s;
  goto <D.10810>;
  <D.10809>:;
  {
    uint8_t x = (unsigned char) *p;

        uint8_t x = (unsigned char) *p;
    if (((unsigned char) x <= 31 && (unsigned char) x != 10) && (unsigned char) x != 13)
      {
        *p = 32;
      }
  }
  p++ ;
  <D.10810>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10809>; else goto <D.10811>;
  <D.10811>:;
  return s;
}



;; Function switch_clean_name_string (null)
;; enabled by -tree-original

{
  char * p;

    char * p;
  p = s;
  goto <D.10818>;
  <D.10817>:;
  {
    uint8_t x = (unsigned char) *p;

        uint8_t x = (unsigned char) *p;
    if ((((((unsigned char) x <= 31 || (unsigned char) x == 39) || ((unsigned char) x == 34 || (unsigned char) x == 60)) || ((unsigned char) x == 62 || (unsigned char) x == 92)) || ((unsigned char) x == 58 || (unsigned char) x == 64)) || (unsigned char) x == 47)
      {
        *p = 32;
      }
    if (p == s && (unsigned char) *p == 32)
      {
        s++ ;
      }
  }
  p++ ;
  <D.10818>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10817>; else goto <D.10819>;
  <D.10819>:;
  return s;
}



;; Function switch_safe_atoi (null)
;; enabled by -tree-original

{
  return nptr != 0B ? atoi (nptr) : dft;
}



;; Function switch_safe_strdup (null)
;; enabled by -tree-original

{
  if (it != 0B)
    {
      return __strdup (it);
    }
  return 0B;
}



;; Function switch_lc_strdup (null)
;; enabled by -tree-original

{
  char * dup;
  char * p;

    char * dup;
    char * p;
  if (it != 0B)
    {
      dup = __strdup (it);
      p = dup;
      goto <D.10839>;
      <D.10838>:;
      *p = (char) switch_tolower ((uint32_t) *p);
      p++ ;
      <D.10839>:;
      if (p != 0B && (unsigned char) *p != 0) goto <D.10838>; else goto <D.10840>;
      <D.10840>:;
      return dup;
    }
  return 0B;
}



;; Function switch_uc_strdup (null)
;; enabled by -tree-original

{
  char * dup;
  char * p;

    char * dup;
    char * p;
  if (it != 0B)
    {
      dup = __strdup (it);
      p = dup;
      goto <D.10850>;
      <D.10849>:;
      *p = (char) switch_toupper ((uint32_t) *p);
      p++ ;
      <D.10850>:;
      if (p != 0B && (unsigned char) *p != 0) goto <D.10849>; else goto <D.10851>;
      <D.10851>:;
      return dup;
    }
  return 0B;
}



;; Function switch_strstr (null)
;; enabled by -tree-original

{
  char * p;
  char * S = 0B;
  char * Q = 0B;
  switch_bool_t tf = 0;
  static const char __PRETTY_FUNCTION__[14] = "switch_strstr";
  void done = <<< error >>>;

    static const char __PRETTY_FUNCTION__[14] = "switch_strstr";
    char * p;
    char * S = 0B;
    char * Q = 0B;
    switch_bool_t tf = 0;
  if (s == 0B || q == 0B)
    {
      return 0;
    }
  if (strstr ((const char *) s, (const char *) q) != 0B)
    {
      return 1;
    }
  S = __strdup ((const char *) s);
  if (S == 0B)
    {
      __assert_fail ((const char *) "S != ((void *)0)", (const char *) "./src/include/switch_utils.h", 816, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  p = S;
  goto <D.10865>;
  <D.10864>:;
  *p = (char) switch_toupper ((uint32_t) *p);
  p++ ;
  <D.10865>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10864>; else goto <D.10866>;
  <D.10866>:;
  if (strstr ((const char *) S, (const char *) q) != 0B)
    {
      tf = 1;
      goto done;
    }
  Q = __strdup ((const char *) q);
  if (Q == 0B)
    {
      __assert_fail ((const char *) "Q != ((void *)0)", (const char *) "./src/include/switch_utils.h", 828, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  p = Q;
  goto <D.10872>;
  <D.10871>:;
  *p = (char) switch_toupper ((uint32_t) *p);
  p++ ;
  <D.10872>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.10871>; else goto <D.10873>;
  <D.10873>:;
  if (strstr ((const char *) s, (const char *) Q) != 0B)
    {
      tf = 1;
      goto done;
    }
  if (strstr ((const char *) S, (const char *) Q) != 0B)
    {
      tf = 1;
      goto done;
    }
  done:;
  if (S != 0B)
    {
      free ((void *) S);
      S = 0B;
    }
  if (Q != 0B)
    {
      free ((void *) Q);
      Q = 0B;
    }
  return tf;
}



;; Function switch_is_file_path (null)
;; enabled by -tree-original

{
  const char * e;
  int r;
  int x;

    const char * e;
    int r;
    int x;
  x = 0;
  goto <D.10974>;
  <D.10973>:;
  if ((unsigned char) *file == 91 && (unsigned char) *(file + 1) == (unsigned char) *(char *) "/")
    {
      if ((e = (const char *) switch_find_end_paren (file, 91, 93)) != 0B)
        {
          file = e + 1;
        }
    }
  else
    {
      if ((unsigned char) *file == 123)
        {
          if ((e = (const char *) switch_find_end_paren (file, 123, 125)) != 0B)
            {
              file = e + 1;
            }
        }
      else
        {
          goto <D.10972>;
        }
    }
  x++ ;
  <D.10974>:;
  if (x <= 1) goto <D.10973>; else goto <D.10972>;
  <D.10972>:;
  r = file != 0B && ((unsigned char) *file == 47 || strstr (file, (const char *) "://") != 0B);
  return r != 0;
}



;; Function switch_event_create_plain (null)
;; enabled by -tree-original

{
  switch_status_t status = switch_event_create_subclass_detailed ((const char *) "./src/include/switch_event.h", (const char *) &__func__, 385, event, 1, 0B);
  static const char __func__[26] = "switch_event_create_plain";

    static const char __func__[26] = "switch_event_create_plain";
    switch_status_t status = switch_event_create_subclass_detailed ((const char *) "./src/include/switch_event.h", (const char *) &__func__, 385, event, 1, 0B);
  if ((unsigned int) status == 0)
    {
      (*event)->event_id = event_id;
      if ((unsigned int) event_id + 4294967234 <= 1)
        {
          (*event)->flags = (*event)->flags | 1;
        }
    }
  return status;
}



;; Function switch_media_type2str (null)
;; enabled by -tree-original

{
  switch ((unsigned int) type)
    {
      case 0:;
      return (const char *) "audio";
      case 1:;
      return (const char *) "video";
      default:;
      return (const char *) "!ERR";
    }
}



;; Function teletone_dds_phase_rate (null)
;; enabled by -tree-original

{
  return (int32_t) (int) (((tone * 6.5536e+4) * 6.5536e+4) / (teletone_process_t) rate);
}



;; Function teletone_dds_state_modulate_sample (null)
;; enabled by -tree-original

{
  int32_t bitmask = (int32_t) dds->phase_accumulator;
  int32_t sine_index = (int) (bitmask = bitmask >> 23) & 127;
  int16_t sample;

    int32_t bitmask = (int32_t) dds->phase_accumulator;
    int32_t sine_index = (int) (bitmask = bitmask >> 23) & 127;
    int16_t sample;
  if (pindex > 3)
    {
      pindex = 0;
    }
  if (((int) bitmask & 128) != 0)
    {
      sine_index = 127 - sine_index;
    }
  sample = TELETONE_SINES[sine_index];
  if (((int) bitmask & 256) != 0)
    {
      sample = (int16_t) -(short unsigned int) sample;
    }
  dds->phase_accumulator = dds->phase_accumulator + dds->phase_rate[pindex];
  return (int16_t) ((uint32_t) sample * dds->scale_factor >> 15);
}



;; Function teletone_dds_state_set_tx_level (null)
;; enabled by -tree-original

{
  dds->scale_factor = (uint32_t) (int) (powf (1.0e+1, (tx_level - 6.159999847412109375e+0) / 2.0e+1) * 4.633955078125e+4);
  dds->tx_level = (teletone_process_t) tx_level;
}



;; Function teletone_dds_state_reset_accum (null)
;; enabled by -tree-original

{
  dds->phase_accumulator = 0;
}



;; Function teletone_dds_state_set_tone (null)
;; enabled by -tree-original

{
  if (pindex <= 3)
    {
      dds->phase_rate[pindex] = (uint32_t) teletone_dds_phase_rate (tone, rate);
      return 0;
    }
  return -1;
}



;; Function lfastrint (null)
;; enabled by -tree-original

{
  return (long int) x;
}



;; Function lfastrintf (null)
;; enabled by -tree-original

{
  return (long int) x;
}



;; Function complex_setf (null)
;; enabled by -tree-original

{
  struct complexf_t z;

    struct complexf_t z;
  z.re = re;
  z.im = im;
  return z;
}



;; Function complex_set (null)
;; enabled by -tree-original

{
  struct complex_t z;

    struct complex_t z;
  z.re = re;
  z.im = im;
  return z;
}



;; Function complex_seti (null)
;; enabled by -tree-original

{
  struct complexi_t z;

    struct complexi_t z;
  z.re = re;
  z.im = im;
  return z;
}



;; Function complex_seti16 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = re;
  z.im = im;
  return z;
}



;; Function complex_seti32 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = re;
  z.im = im;
  return z;
}



;; Function complex_addf (null)
;; enabled by -tree-original

{
  struct complexf_t z;

    struct complexf_t z;
  z.re = (float) x->re + (float) y->re;
  z.im = (float) x->im + (float) y->im;
  return z;
}



;; Function complex_add (null)
;; enabled by -tree-original

{
  struct complex_t z;

    struct complex_t z;
  z.re = (double) x->re + (double) y->re;
  z.im = (double) x->im + (double) y->im;
  return z;
}



;; Function complex_addi (null)
;; enabled by -tree-original

{
  struct complexi_t z;

    struct complexi_t z;
  z.re = (int) x->re + (int) y->re;
  z.im = (int) x->im + (int) y->im;
  return z;
}



;; Function complex_addi16 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = (int16_t) ((short unsigned int) x->re + (short unsigned int) y->re);
  z.im = (int16_t) ((short unsigned int) x->im + (short unsigned int) y->im);
  return z;
}



;; Function complex_addi32 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = (int) x->re + (int) y->re;
  z.im = (int) x->im + (int) y->im;
  return z;
}



;; Function complex_subf (null)
;; enabled by -tree-original

{
  struct complexf_t z;

    struct complexf_t z;
  z.re = (float) x->re - (float) y->re;
  z.im = (float) x->im - (float) y->im;
  return z;
}



;; Function complex_sub (null)
;; enabled by -tree-original

{
  struct complex_t z;

    struct complex_t z;
  z.re = (double) x->re - (double) y->re;
  z.im = (double) x->im - (double) y->im;
  return z;
}



;; Function complex_subi (null)
;; enabled by -tree-original

{
  struct complexi_t z;

    struct complexi_t z;
  z.re = (int) x->re - (int) y->re;
  z.im = (int) x->im - (int) y->im;
  return z;
}



;; Function complex_subi16 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = (int16_t) ((short unsigned int) x->re - (short unsigned int) y->re);
  z.im = (int16_t) ((short unsigned int) x->im - (short unsigned int) y->im);
  return z;
}



;; Function complex_subi32 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = (int) x->re - (int) y->re;
  z.im = (int) x->im - (int) y->im;
  return z;
}



;; Function complex_mulf (null)
;; enabled by -tree-original

{
  struct complexf_t z;

    struct complexf_t z;
  z.re = (float) x->re * (float) y->re - (float) x->im * (float) y->im;
  z.im = (float) x->re * (float) y->im + (float) x->im * (float) y->re;
  return z;
}



;; Function complex_mul (null)
;; enabled by -tree-original

{
  struct complex_t z;

    struct complex_t z;
  z.re = (double) x->re * (double) y->re - (double) x->im * (double) y->im;
  z.im = (double) x->re * (double) y->im + (double) x->im * (double) y->re;
  return z;
}



;; Function complex_muli (null)
;; enabled by -tree-original

{
  struct complexi_t z;

    struct complexi_t z;
  z.re = (int) x->re * (int) y->re - (int) x->im * (int) y->im;
  z.im = (int) x->re * (int) y->im + (int) x->im * (int) y->re;
  return z;
}



;; Function complex_muli16 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = (short int) ((short unsigned int) x->re * (short unsigned int) y->re - (short unsigned int) x->im * (short unsigned int) y->im);
  z.im = (short int) ((short unsigned int) x->re * (short unsigned int) y->im + (short unsigned int) x->im * (short unsigned int) y->re);
  return z;
}



;; Function complex_mul_q1_15 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = (short int) ((int) x->re * (int) y->re - (int) x->im * (int) y->im >> 15);
  z.im = (short int) ((int) x->re * (int) y->im + (int) x->im * (int) y->re >> 15);
  return z;
}



;; Function complex_muli32i16 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = (int) x->re * (int) y->re - (int) x->im * (int) y->im;
  z.im = (int) x->re * (int) y->im + (int) x->im * (int) y->re;
  return z;
}



;; Function complex_muli32 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = (int) x->re * (int) y->re - (int) x->im * (int) y->im;
  z.im = (int) x->re * (int) y->im + (int) x->im * (int) y->re;
  return z;
}



;; Function complex_divf (null)
;; enabled by -tree-original

{
  struct complexf_t z;
  float f;

    struct complexf_t z;
    float f;
  f = (float) y->re * (float) y->re + (float) y->im * (float) y->im;
  z.re = ((float) x->re * (float) y->re + (float) x->im * (float) y->im) / f;
  z.im = ((float) -x->re * (float) y->im + (float) x->im * (float) y->re) / f;
  return z;
}



;; Function complex_div (null)
;; enabled by -tree-original

{
  struct complex_t z;
  double f;

    struct complex_t z;
    double f;
  f = (double) y->re * (double) y->re + (double) y->im * (double) y->im;
  z.re = ((double) x->re * (double) y->re + (double) x->im * (double) y->im) / f;
  z.im = ((double) -x->re * (double) y->im + (double) x->im * (double) y->re) / f;
  return z;
}



;; Function complex_conjf (null)
;; enabled by -tree-original

{
  struct complexf_t z;

    struct complexf_t z;
  z.re = x->re;
  z.im = -x->im;
  return z;
}



;; Function complex_conj (null)
;; enabled by -tree-original

{
  struct complex_t z;

    struct complex_t z;
  z.re = x->re;
  z.im = -x->im;
  return z;
}



;; Function complex_conji (null)
;; enabled by -tree-original

{
  struct complexi_t z;

    struct complexi_t z;
  z.re = x->re;
  z.im = -x->im;
  return z;
}



;; Function complex_conji16 (null)
;; enabled by -tree-original

{
  struct complexi16_t z;

    struct complexi16_t z;
  z.re = x->re;
  z.im = (int16_t) -(short unsigned int) x->im;
  return z;
}



;; Function complex_conji32 (null)
;; enabled by -tree-original

{
  struct complexi32_t z;

    struct complexi32_t z;
  z.re = x->re;
  z.im = -x->im;
  return z;
}



;; Function poweri16 (null)
;; enabled by -tree-original

{
  return (int32_t) ((int) x->re * (int) x->re + (int) x->im * (int) x->im);
}



;; Function powerf (null)
;; enabled by -tree-original

{
  return (float) x->re * (float) x->re + (float) x->im * (float) x->im;
}



;; Function power (null)
;; enabled by -tree-original

{
  return (double) x->re * (double) x->re + (double) x->im * (double) x->im;
}



;; Function top_bit (null)
;; enabled by -tree-original

{
  int res;

    int res;
  if (bits == 0)
    {
      return -1;
    }
  res = 0;
  if ((bits & 4294901760) != 0)
    {
      bits = bits & 4294901760;
      res = res + 16;
    }
  if ((bits & 4278255360) != 0)
    {
      bits = bits & 4278255360;
      res = res + 8;
    }
  if ((bits & 4042322160) != 0)
    {
      bits = bits & 4042322160;
      res = res + 4;
    }
  if ((bits & 3435973836) != 0)
    {
      bits = bits & 3435973836;
      res = res + 2;
    }
  if ((bits & 2863311530) != 0)
    {
      bits = bits & 2863311530;
      res = res + 1;
    }
  return res;
}



;; Function bottom_bit (null)
;; enabled by -tree-original

{
  int res;

    int res;
  if (bits == 0)
    {
      return -1;
    }
  res = 31;
  if ((bits & 65535) != 0)
    {
      bits = bits & 65535;
      res = res + -16;
    }
  if ((bits & 16711935) != 0)
    {
      bits = bits & 16711935;
      res = res + -8;
    }
  if ((bits & 252645135) != 0)
    {
      bits = bits & 252645135;
      res = res + -4;
    }
  if ((bits & 858993459) != 0)
    {
      bits = bits & 858993459;
      res = res + -2;
    }
  if ((bits & 1431655765) != 0)
    {
      bits = bits & 1431655765;
      res = res + -1;
    }
  return res;
}



;; Function bit_reverse8 (null)
;; enabled by -tree-original

{
  x = (uint8_t) ((signed char) ((unsigned char) x >> 4) | (signed char) ((int) x << 4));
  x = (uint8_t) ((signed char) (((int) x & 204) >> 2) | (signed char) (((int) x & 51) << 2));
  return (uint8_t) ((signed char) (((int) x & 170) >> 1) | (signed char) (((int) x & 85) << 1));
}



;; Function least_significant_one32 (null)
;; enabled by -tree-original

{
  return (uint32_t) -(int) x & x;
}



;; Function most_significant_one32 (null)
;; enabled by -tree-original

{
  x = make_mask32 (x);
  return x >> 1 ^ x;
}



;; Function parity8 (null)
;; enabled by -tree-original

{
  x = (uint8_t) ((unsigned char) x >> 4 ^ (unsigned char) x) & 15;
  return 27030 >> (int) x & 1;
}



;; Function parity16 (null)
;; enabled by -tree-original

{
  x = (uint16_t) ((short unsigned int) x >> 8 ^ (short unsigned int) x);
  x = (uint16_t) ((short unsigned int) x >> 4 ^ (short unsigned int) x) & 15;
  return 27030 >> (int) x & 1;
}



;; Function parity32 (null)
;; enabled by -tree-original

{
  x = x >> 16 ^ x;
  x = x >> 8 ^ x;
  x = (x >> 4 ^ x) & 15;
  return 27030 >> (int) x & 1;
}



;; Function linear_to_ulaw (null)
;; enabled by -tree-original

{
  uint8_t u_val;
  int mask;
  int seg;

    uint8_t u_val;
    int mask;
    int seg;
  if (linear >= 0)
    {
      linear = linear + 132;
      mask = 255;
    }
  else
    {
      linear = 132 - linear;
      mask = 127;
    }
  seg = top_bit ((uint32_t) (linear | 255)) + -7;
  if (seg > 7)
    {
      u_val = (unsigned char) ((signed char) mask ^ 127);
    }
  else
    {
      u_val = (unsigned char) (((signed char) (seg << 4) | (signed char) (linear >> seg + 3) & 15) ^ (signed char) mask);
    }
  return u_val;
}



;; Function ulaw_to_linear (null)
;; enabled by -tree-original

{
  int t;

    int t;
  ulaw = ~ulaw;
  t = (((int) ulaw & 15) << 3) + 132 << (((int) ulaw & 112) >> 4);
  return (signed char) ulaw < 0 ? (int16_t) (132 - (short unsigned int) t) : (int16_t) ((short unsigned int) t + 65404);
}



;; Function linear_to_alaw (null)
;; enabled by -tree-original

{
  uint8_t a_val;
  int mask;
  int seg;

    uint8_t a_val;
    int mask;
    int seg;
  if (linear >= 0)
    {
      mask = 213;
    }
  else
    {
      mask = 85;
      linear = ~linear;
    }
  seg = top_bit ((uint32_t) (linear | 255)) + -7;
  if (seg > 7)
    {
      a_val = (unsigned char) ((signed char) mask ^ 127);
    }
  else
    {
      a_val = (unsigned char) (((signed char) (seg << 4) | (signed char) (linear >> (seg != 0 ? seg + 3 : 4)) & 15) ^ (signed char) mask);
    }
  return a_val;
}



;; Function alaw_to_linear (null)
;; enabled by -tree-original

{
  int i;
  int seg;

    int i;
    int seg;
  alaw = (uint8_t) ((unsigned char) alaw ^ 85);
  i = (int) alaw << 4 & 255;
  seg = ((int) alaw & 112) >> 4;
  if (seg != 0)
    {
      i = i + 264 << seg + -1;
    }
  else
    {
      i = i + 8;
    }
  return (signed char) alaw < 0 ? (int16_t) i : (int16_t) -(short unsigned int) i;
}



;; Function rdtscll (null)
;; enabled by -tree-original

{
  return 0;
}



;; Function cvec_copyf (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29411>;
  <D.29410>:;
  *(z + (unsigned int) ((unsigned int) i * 8)) = *(x + (unsigned int) ((unsigned int) i * 8));
  i++ ;
  <D.29411>:;
  if (i < n) goto <D.29410>; else goto <D.29412>;
  <D.29412>:;
}



;; Function cvec_copy (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29420>;
  <D.29419>:;
  *(z + (unsigned int) ((unsigned int) i * 16)) = *(x + (unsigned int) ((unsigned int) i * 16));
  i++ ;
  <D.29420>:;
  if (i < n) goto <D.29419>; else goto <D.29421>;
  <D.29421>:;
}



;; Function cvec_zerof (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29428>;
  <D.29427>:;
  *(z + (unsigned int) ((unsigned int) i * 8)) = complex_setf (0.0, 0.0);
  i++ ;
  <D.29428>:;
  if (i < n) goto <D.29427>; else goto <D.29429>;
  <D.29429>:;
}



;; Function cvec_zero (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29436>;
  <D.29435>:;
  *(z + (unsigned int) ((unsigned int) i * 16)) = complex_set (0.0, 0.0);
  i++ ;
  <D.29436>:;
  if (i < n) goto <D.29435>; else goto <D.29437>;
  <D.29437>:;
}



;; Function cvec_setf (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29445>;
  <D.29444>:;
  *(z + (unsigned int) ((unsigned int) i * 8)) = *x;
  i++ ;
  <D.29445>:;
  if (i < n) goto <D.29444>; else goto <D.29446>;
  <D.29446>:;
}



;; Function cvec_set (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29454>;
  <D.29453>:;
  *(z + (unsigned int) ((unsigned int) i * 16)) = *x;
  i++ ;
  <D.29454>:;
  if (i < n) goto <D.29453>; else goto <D.29455>;
  <D.29455>:;
}



;; Function vec_copyi (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 4);
}



;; Function vec_copyi16 (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 2);
}



;; Function vec_copyi32 (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 4);
}



;; Function vec_zeroi (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 4);
}



;; Function vec_zeroi16 (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 2);
}



;; Function vec_zeroi32 (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 4);
}



;; Function vec_seti (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29524>;
  <D.29523>:;
  *(z + (unsigned int) ((unsigned int) i * 4)) = x;
  i++ ;
  <D.29524>:;
  if (i < n) goto <D.29523>; else goto <D.29525>;
  <D.29525>:;
}



;; Function vec_seti16 (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29533>;
  <D.29532>:;
  *(z + (unsigned int) ((unsigned int) i * 2)) = x;
  i++ ;
  <D.29533>:;
  if (i < n) goto <D.29532>; else goto <D.29534>;
  <D.29534>:;
}



;; Function vec_seti32 (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29542>;
  <D.29541>:;
  *(z + (unsigned int) ((unsigned int) i * 4)) = x;
  i++ ;
  <D.29542>:;
  if (i < n) goto <D.29541>; else goto <D.29543>;
  <D.29543>:;
}



;; Function vec_norm2i16 (null)
;; enabled by -tree-original

{
  int i;
  int sum;

    int i;
    int sum;
  sum = 0;
  i = 0;
  goto <D.29575>;
  <D.29574>:;
  sum = (int) *(vec + (unsigned int) ((unsigned int) i * 2)) * (int) *(vec + (unsigned int) ((unsigned int) i * 2)) + sum;
  i++ ;
  <D.29575>:;
  if (i < len) goto <D.29574>; else goto <D.29576>;
  <D.29576>:;
  return sum;
}



;; Function vec_sari16 (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29584>;
  <D.29583>:;
  *(vec + (unsigned int) ((unsigned int) i * 2)) = (int16_t) ((int) *(vec + (unsigned int) ((unsigned int) i * 2)) >> shift);
  i++ ;
  <D.29584>:;
  if (i < len) goto <D.29583>; else goto <D.29585>;
  <D.29585>:;
}



;; Function vec_max_bitsi16 (null)
;; enabled by -tree-original

{
  int i;
  int max;
  int v;
  int b;

    int i;
    int max;
    int v;
    int b;
  max = 0;
  i = 0;
  goto <D.29595>;
  <D.29594>:;
  v = ABS_EXPR <(int) *(vec + (unsigned int) ((unsigned int) i * 2))>;
  if (v > max)
    {
      max = v;
    }
  i++ ;
  <D.29595>:;
  if (i < len) goto <D.29594>; else goto <D.29596>;
  <D.29596>:;
  b = 0;
  goto <D.29598>;
  <D.29597>:;
  b++ ;
  max = max >> 1;
  <D.29598>:;
  if (max != 0) goto <D.29597>; else goto <D.29599>;
  <D.29599>:;
  return b;
}



;; Function cvec_copyi (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 8);
}



;; Function cvec_copyi16 (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 4);
}



;; Function cvec_copyi32 (null)
;; enabled by -tree-original

{
  memcpy ((void * restrict) z, (const void * restrict) x, (unsigned int) n * 8);
}



;; Function cvec_zeroi (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 8);
}



;; Function cvec_zeroi16 (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 4);
}



;; Function cvec_zeroi32 (null)
;; enabled by -tree-original

{
  memset ((void *) z, 0, (unsigned int) n * 8);
}



;; Function cvec_seti (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29634>;
  <D.29633>:;
  *(z + (unsigned int) ((unsigned int) i * 8)) = *x;
  i++ ;
  <D.29634>:;
  if (i < n) goto <D.29633>; else goto <D.29635>;
  <D.29635>:;
}



;; Function cvec_seti16 (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29643>;
  <D.29642>:;
  *(z + (unsigned int) ((unsigned int) i * 4)) = *x;
  i++ ;
  <D.29643>:;
  if (i < n) goto <D.29642>; else goto <D.29644>;
  <D.29644>:;
}



;; Function cvec_seti32 (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.29652>;
  <D.29651>:;
  *(z + (unsigned int) ((unsigned int) i * 8)) = *x;
  i++ ;
  <D.29652>:;
  if (i < n) goto <D.29651>; else goto <D.29653>;
  <D.29653>:;
}



;; Function arctan2 (null)
;; enabled by -tree-original

{
  float abs_y;
  float angle;

    float abs_y;
    float angle;
  if (y == 0.0)
    {
      if (x < 0.0)
        {
          return -2147483648;
        }
      return 0;
    }
  if (x == 0.0)
    {
      if (y < 0.0)
        {
          return -1073741824;
        }
      return 1073741824;
    }
  abs_y = ABS_EXPR <y>;
  if (x < 0.0)
    {
      angle = 3.0e+0 - (x + abs_y) / (abs_y - x);
    }
  else
    {
      angle = 1.0e+0 - (x - abs_y) / (abs_y + x);
    }
  angle = angle * 5.36870912e+8;
  if (y < 0.0)
    {
      angle = -angle;
    }
  return (int32_t) (int) angle;
}



;; Function biquad2_init (null)
;; enabled by -tree-original

{
  bq->gain = gain;
  bq->a1 = a1;
  bq->a2 = a2;
  bq->b1 = b1;
  bq->b2 = b2;
  bq->z1 = 0;
  bq->z2 = 0;
}



;; Function biquad2 (null)
;; enabled by -tree-original

{
  int32_t y;
  int32_t z0;

    int32_t y;
    int32_t z0;
  z0 = ((int32_t) sample * bq->gain + bq->z1 * bq->a1) + bq->z2 * bq->a2;
  y = (bq->z1 * bq->b1 + bq->z2 * bq->b2) + z0;
  bq->z2 = bq->z1;
  bq->z1 = z0 >> 15;
  y = y >> 15;
  return (int16_t) y;
}



;; Function fir16_create (null)
;; enabled by -tree-original

{
  fir->taps = taps;
  fir->curr_pos = taps + -1;
  fir->coeffs = coeffs;
  if ((fir->history = (int16_t *) malloc ((unsigned int) taps * 2)) != 0B)
    {
      memset ((void *) fir->history, 0, (unsigned int) taps * 2);
    }
  return (const int16_t *) fir->history;
}



;; Function fir16_flush (null)
;; enabled by -tree-original

{
  memset ((void *) fir->history, 0, (unsigned int) fir->taps * 2);
}



;; Function fir16_free (null)
;; enabled by -tree-original

{
  free ((void *) fir->history);
}



;; Function fir16 (null)
;; enabled by -tree-original

{
  int i;
  int32_t y;
  int offset1;
  int offset2;

    int i;
    int32_t y;
    int offset1;
    int offset2;
  *(fir->history + (unsigned int) ((unsigned int) fir->curr_pos * 2)) = sample;
  offset2 = fir->curr_pos;
  offset1 = fir->taps - offset2;
  y = 0;
  i = fir->taps + -1;
  goto <D.29745>;
  <D.29744>:;
  y = (int) *(fir->coeffs + (unsigned int) ((unsigned int) i * 2)) * (int) *(fir->history + (unsigned int) ((unsigned int) (i - offset1) * 2)) + (int) y;
  i-- ;
  <D.29745>:;
  if (i >= offset1) goto <D.29744>; else goto <D.29746>;
  <D.29746>:;
  goto <D.29748>;
  <D.29747>:;
  y = (int) *(fir->coeffs + (unsigned int) ((unsigned int) i * 2)) * (int) *(fir->history + (unsigned int) ((unsigned int) (i + offset2) * 2)) + (int) y;
  i-- ;
  <D.29748>:;
  if (i >= 0) goto <D.29747>; else goto <D.29749>;
  <D.29749>:;
  if (fir->curr_pos <= 0)
    {
      fir->curr_pos = fir->taps;
    }
  fir->curr_pos-- ;
  return (int16_t) (y >> 15);
}



;; Function fir32_create (null)
;; enabled by -tree-original

{
  fir->taps = taps;
  fir->curr_pos = taps + -1;
  fir->coeffs = coeffs;
  fir->history = (int16_t *) malloc ((unsigned int) taps * 2);
  if (fir->history != 0B)
    {
      memset ((void *) fir->history, 0, (unsigned int) taps * 2);
    }
  return (const int16_t *) fir->history;
}



;; Function fir32_flush (null)
;; enabled by -tree-original

{
  memset ((void *) fir->history, 0, (unsigned int) fir->taps * 2);
}



;; Function fir32_free (null)
;; enabled by -tree-original

{
  free ((void *) fir->history);
}



;; Function fir32 (null)
;; enabled by -tree-original

{
  int i;
  int32_t y;
  int offset1;
  int offset2;

    int i;
    int32_t y;
    int offset1;
    int offset2;
  *(fir->history + (unsigned int) ((unsigned int) fir->curr_pos * 2)) = sample;
  offset2 = fir->curr_pos;
  offset1 = fir->taps - offset2;
  y = 0;
  i = fir->taps + -1;
  goto <D.29770>;
  <D.29769>:;
  y = (int) *(fir->coeffs + (unsigned int) ((unsigned int) i * 4)) * (int) *(fir->history + (unsigned int) ((unsigned int) (i - offset1) * 2)) + (int) y;
  i-- ;
  <D.29770>:;
  if (i >= offset1) goto <D.29769>; else goto <D.29771>;
  <D.29771>:;
  goto <D.29773>;
  <D.29772>:;
  y = (int) *(fir->coeffs + (unsigned int) ((unsigned int) i * 4)) * (int) *(fir->history + (unsigned int) ((unsigned int) (i + offset2) * 2)) + (int) y;
  i-- ;
  <D.29773>:;
  if (i >= 0) goto <D.29772>; else goto <D.29774>;
  <D.29774>:;
  if (fir->curr_pos <= 0)
    {
      fir->curr_pos = fir->taps;
    }
  fir->curr_pos-- ;
  return (int16_t) (y >> 15);
}



;; Function fir_float_create (null)
;; enabled by -tree-original

{
  fir->taps = taps;
  fir->curr_pos = taps + -1;
  fir->coeffs = coeffs;
  fir->history = (float *) malloc ((unsigned int) taps * 4);
  if (fir->history != 0B)
    {
      memset ((void *) fir->history, 0, (unsigned int) taps * 4);
    }
  return (const float *) fir->history;
}



;; Function fir_float_free (null)
;; enabled by -tree-original

{
  free ((void *) fir->history);
}



;; Function fir_float (null)
;; enabled by -tree-original

{
  int i;
  float y;
  int offset1;
  int offset2;

    int i;
    float y;
    int offset1;
    int offset2;
  *(fir->history + (unsigned int) ((unsigned int) fir->curr_pos * 4)) = (float) sample;
  offset2 = fir->curr_pos;
  offset1 = fir->taps - offset2;
  y = 0.0;
  i = fir->taps + -1;
  goto <D.29792>;
  <D.29791>:;
  y = (float) *(fir->coeffs + (unsigned int) ((unsigned int) i * 4)) * *(fir->history + (unsigned int) ((unsigned int) (i - offset1) * 4)) + y;
  i-- ;
  <D.29792>:;
  if (i >= offset1) goto <D.29791>; else goto <D.29793>;
  <D.29793>:;
  goto <D.29795>;
  <D.29794>:;
  y = (float) *(fir->coeffs + (unsigned int) ((unsigned int) i * 4)) * *(fir->history + (unsigned int) ((unsigned int) (i + offset2) * 4)) + y;
  i-- ;
  <D.29795>:;
  if (i >= 0) goto <D.29794>; else goto <D.29796>;
  <D.29796>:;
  if (fir->curr_pos <= 0)
    {
      fir->curr_pos = fir->taps;
    }
  fir->curr_pos-- ;
  return (int16_t) (short int) y;
}



;; Function dc_restore_init (null)
;; enabled by -tree-original

{
  dc->state = 0;
}



;; Function dc_restore (null)
;; enabled by -tree-original

{
  dc->state = dc->state + ((int32_t) ((int) sample << 15) - dc->state >> 14);
  return (int16_t) ((short unsigned int) sample - (short unsigned int) (dc->state >> 15));
}



;; Function dc_restore_estimate (null)
;; enabled by -tree-original

{
  return (int16_t) (dc->state >> 15);
}



;; Function saturate16 (null)
;; enabled by -tree-original

{
  int16_t z;

    int16_t z;
  __asm__ __volatile__(" ssat %0,#16,%1;\n":"z" "=r" z:"amp" "r" amp);
  return z;
}



;; Function saturate15 (null)
;; enabled by -tree-original

{
  int16_t z;

    int16_t z;
  __asm__ __volatile__(" ssat %0,#15,%1;\n":"z" "=r" z:"amp" "r" amp);
  return z;
}



;; Function saturateu16 (null)
;; enabled by -tree-original

{
  uint16_t z;

    uint16_t z;
  __asm__ __volatile__(" usat %0,#16,%1;\n":"z" "=r" z:"amp" "r" amp);
  return z;
}



;; Function saturateu8 (null)
;; enabled by -tree-original

{
  uint8_t z;

    uint8_t z;
  __asm__ __volatile__(" usat %0,#8,%1;\n":"z" "=r" z:"amp" "r" amp);
  return z;
}



;; Function fsaturatef (null)
;; enabled by -tree-original

{
  if (famp > 3.2767e+4)
    {
      return 32767;
    }
  if (famp < -3.2768e+4)
    {
      return -32768;
    }
  return (int16_t) lrintf (famp);
}



;; Function fsaturate (null)
;; enabled by -tree-original

{
  if (damp > 3.2767e+4)
    {
      return 32767;
    }
  if (damp < -3.2768e+4)
    {
      return -32768;
    }
  return (int16_t) lrint (damp);
}



;; Function ffastsaturatef (null)
;; enabled by -tree-original

{
  if (famp > 3.2767e+4)
    {
      return 32767;
    }
  if (famp < -3.2768e+4)
    {
      return -32768;
    }
  return (int16_t) lfastrintf (famp);
}



;; Function ffastsaturate (null)
;; enabled by -tree-original

{
  if (damp > 3.2767e+4)
    {
      return 32767;
    }
  if (damp < -3.2768e+4)
    {
      return -32768;
    }
  return (int16_t) lfastrint (damp);
}



;; Function ffsaturatef (null)
;; enabled by -tree-original

{
  if (famp > 3.2767e+4)
    {
      return 3.2767e+4;
    }
  if (famp < -3.2768e+4)
    {
      return -3.2768e+4;
    }
  return famp;
}



;; Function ffsaturate (null)
;; enabled by -tree-original

{
  if (famp > 3.2767e+4)
    {
      return 3.2767e+4;
    }
  if (famp < -3.2768e+4)
    {
      return -3.2768e+4;
    }
  return famp;
}



;; Function sat_add16 (null)
;; enabled by -tree-original

{
  int16_t z;

    int16_t z;
  __asm__ __volatile__(" qadd16 %0,%1,%2;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return z;
}



;; Function sat_add32 (null)
;; enabled by -tree-original

{
  int32_t z;

    int32_t z;
  __asm__ __volatile__(" qadd %0,%1,%2;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return z;
}



;; Function sat_sub16 (null)
;; enabled by -tree-original

{
  int16_t z;

    int16_t z;
  __asm__ __volatile__(" qsub16 %0,%1,%2;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return z;
}



;; Function sat_sub32 (null)
;; enabled by -tree-original

{
  int32_t z;

    int32_t z;
  __asm__ __volatile__(" qsub %0,%1,%2;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return z;
}



;; Function sat_mul16 (null)
;; enabled by -tree-original

{
  int32_t z;

    int32_t z;
  __asm__ __volatile__(" smulbb %0,%1,%2;\n qadd %0,%0,%0;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return (int16_t) (z >> 16);
}



;; Function sat_mul32_16 (null)
;; enabled by -tree-original

{
  int32_t z;

    int32_t z;
  __asm__ __volatile__(" smulbb %0,%1,%2;\n qadd %0,%0,%0;\n":"z" "=r" z:"x" "r" x, "y" "r" y);
  return z;
}



;; Function sat_mac32_16 (null)
;; enabled by -tree-original

{
  int32_t product;

    int32_t product;
  __asm__ __volatile__(" smulbb %3,%1,%2;\n qdadd %0,%0,%3;\n":"z" "+r" z:"x" "r" x, "y" "r" y, "p" "r" product);
  return z;
}



;; Function sat_msu32_16 (null)
;; enabled by -tree-original

{
  int32_t product;

    int32_t product;
  __asm__ __volatile__(" smulbb %3,%1,%2;\n qdsub %0,%0,%3;\n":"z" "+r" z:"x" "r" x, "y" "r" y, "p" "r" product);
  return z;
}



;; Function sat_abs16 (null)
;; enabled by -tree-original

{
  if ((short int) x == -32768)
    {
      return 32767;
    }
  return (int16_t) ABS_EXPR <(int) x>;
}



;; Function sat_abs32 (null)
;; enabled by -tree-original

{
  if ((int) x == -2147483648)
    {
      return 2147483647;
    }
  return (int32_t) ABS_EXPR <(int) x>;
}



;; Function goertzel_sample (null)
;; enabled by -tree-original

{
  float v1;

    float v1;
  v1 = s->v2;
  s->v2 = s->v3;
  s->v3 = (s->fac * s->v2 - v1) + (float) amp;
  s->current_sample++ ;
}



;; Function goertzel_samplex (null)
;; enabled by -tree-original

{
  float v1;

    float v1;
  v1 = s->v2;
  s->v2 = s->v3;
  s->v3 = (s->fac * s->v2 - v1) + amp;
}



;; Function _curl_easy_setopt_err_long (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_curl_off_t (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_string (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_write_callback (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_read_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_ioctl_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_sockopt_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_opensocket_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_progress_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_debug_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_ssl_ctx_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_conv_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_seek_cb (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_cb_data (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_error_buffer (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_FILE (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_postfields (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_curl_httpost (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_curl_slist (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_setopt_err_CURLSH (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_getinfo_err_string (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_getinfo_err_long (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_getinfo_err_double (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function _curl_easy_getinfo_err_curl_slist (null)
;; enabled by -tree-original

{
  __asm__ __volatile__(""::);
}



;; Function switch_core_media_crypto_str2type (null)
;; enabled by -tree-original

{
  int i;

    int i;
  i = 0;
  goto <D.38330>;
  <D.38329>:;
  if (strncasecmp (str, (const char *) SUITES[i].name, strlen ((const char *) SUITES[i].name)) == 0)
    {
      return SUITES[i].type;
    }
  i++ ;
  <D.38330>:;
  if (i <= 8) goto <D.38329>; else goto <D.38331>;
  <D.38331>:;
  return 9;
}



;; Function switch_core_media_crypto_type2str (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_crypto_type2str";

    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_crypto_type2str";
  if ((unsigned int) type > 8)
    {
      __assert_fail ((const char *) "type < CRYPTO_INVALID", (const char *) "src/switch_core_media.c", 222, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  return (const char *) SUITES[(unsigned int) type].name;
}



;; Function switch_core_media_crypto_keylen (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_crypto_keylen";

    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_crypto_keylen";
  if ((unsigned int) type > 8)
    {
      __assert_fail ((const char *) "type < CRYPTO_INVALID", (const char *) "src/switch_core_media.c", 229, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  return SUITES[(unsigned int) type].keylen;
}



;; Function get_channels (null)
;; enabled by -tree-original

{
  if (switch_true ((const char *) switch_core_get_variable ((const char *) "NDLB_broken_opus_sdp")) == 0 && strcasecmp (name, (const char *) "opus") == 0)
    {
      return 2;
    }
  return dft != 0 ? dft : 1;
}



;; Function _switch_core_media_pass_zrtp_hash2 (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * aleg_engine;
  struct switch_rtp_engine_t * bleg_engine;
  static const char __func__[35] = "_switch_core_media_pass_zrtp_hash2";

    static const char __func__[35] = "_switch_core_media_pass_zrtp_hash2";
    struct switch_rtp_engine_t * aleg_engine;
    struct switch_rtp_engine_t * bleg_engine;
  if (aleg_session->media_handle == 0B || bleg_session->media_handle == 0B)
    {
      return;
    }
  aleg_engine = (struct switch_rtp_engine_t *) &aleg_session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  bleg_engine = (struct switch_rtp_engine_t *) &bleg_session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 255, (const char *) switch_channel_get_session (aleg_session->channel), 101, (const char *) "Deciding whether to pass zrtp-hash between a-leg and b-leg\n");
  if (switch_channel_test_flag (aleg_session->channel, 73) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 259, (const char *) switch_channel_get_session (aleg_session->channel), 101, (const char *) "CF_ZRTP_PASSTHRU_REQ not set on a-leg, so not propagating zrtp-hash\n");
      return;
    }
  if (aleg_engine->remote_sdp_zrtp_hash != 0B)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 265, (const char *) switch_channel_get_session (aleg_session->channel), 7, (const char *) "Passing a-leg remote zrtp-hash (audio) to b-leg\n");
      bleg_engine->local_sdp_zrtp_hash = switch_core_perform_session_strdup (bleg_session, (const char *) aleg_engine->remote_sdp_zrtp_hash, (const char *) "src/switch_core_media.c", (const char *) &__func__, 266);
      switch_channel_set_variable_var_check (bleg_session->channel, (const char *) "l_sdp_audio_zrtp_hash", (const char *) bleg_engine->local_sdp_zrtp_hash, 1);
    }
  if (bleg_engine->remote_sdp_zrtp_hash != 0B)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 271, (const char *) switch_channel_get_session (aleg_session->channel), 7, (const char *) "Passing b-leg remote zrtp-hash (audio) to a-leg\n");
      aleg_engine->local_sdp_zrtp_hash = switch_core_perform_session_strdup (aleg_session, (const char *) bleg_engine->remote_sdp_zrtp_hash, (const char *) "src/switch_core_media.c", (const char *) &__func__, 272);
      switch_channel_set_variable_var_check (aleg_session->channel, (const char *) "l_sdp_audio_zrtp_hash", (const char *) aleg_engine->local_sdp_zrtp_hash, 1);
    }
}



;; Function switch_core_media_pass_zrtp_hash2 (null)
;; enabled by -tree-original

{
  _switch_core_media_pass_zrtp_hash2 (aleg_session, bleg_session, 0);
  _switch_core_media_pass_zrtp_hash2 (aleg_session, bleg_session, 1);
}



;; Function switch_core_media_pass_zrtp_hash (null)
;; enabled by -tree-original

{
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  struct switch_core_session_t * other_session;
  static const char __func__[33] = "switch_core_media_pass_zrtp_hash";

    static const char __func__[33] = "switch_core_media_pass_zrtp_hash";
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    struct switch_core_session_t * other_session;
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 289, (const char *) switch_channel_get_session (channel), 101, (const char *) "Deciding whether to pass zrtp-hash between legs\n");
  if (switch_channel_test_flag (channel, 73) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 291, (const char *) switch_channel_get_session (channel), 101, (const char *) "CF_ZRTP_PASSTHRU_REQ not set, so not propagating zrtp-hash\n");
      return;
    }
  else
    {
      if ((unsigned int) switch_core_session_perform_get_partner (session, &other_session, (const char *) "src/switch_core_media.c", (const char *) &__func__, 293) != 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 294, (const char *) switch_channel_get_session (channel), 101, (const char *) "No partner channel found, so not propagating zrtp-hash\n");
          return;
        }
      else
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 297, (const char *) switch_channel_get_session (channel), 101, (const char *) "Found peer channel; propagating zrtp-hash if set\n");
          switch_core_media_pass_zrtp_hash2 (session, other_session);
          switch_core_session_rwunlock (other_session);
        }
    }
}



;; Function switch_core_media_get_zrtp_hash (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine;

    struct switch_rtp_engine_t * engine;
  if (session->media_handle == 0B)
    {
      return 0B;
    }
  engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  if ((unsigned int) local != 0)
    {
      return (const char *) engine->local_sdp_zrtp_hash;
    }
  return (const char *) engine->remote_sdp_zrtp_hash;
}



;; Function switch_core_media_find_zrtp_hash (null)
;; enabled by -tree-original

{
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  struct switch_rtp_engine_t * audio_engine;
  struct switch_rtp_engine_t * video_engine;
  struct sdp_media_t * m;
  struct sdp_attribute_t * attr;
  int got_audio = 0;
  int got_video = 0;
  static const char __func__[33] = "switch_core_media_find_zrtp_hash";

    static const char __func__[33] = "switch_core_media_find_zrtp_hash";
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    struct switch_rtp_engine_t * audio_engine;
    struct switch_rtp_engine_t * video_engine;
    struct sdp_media_t * m;
    struct sdp_attribute_t * attr;
    int got_audio = 0;
    int got_video = 0;
  if (session->media_handle == 0B)
    {
      return;
    }
  audio_engine = (struct switch_rtp_engine_t *) &session->media_handle->engines;
  video_engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + 11416;
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 334, (const char *) switch_channel_get_session (channel), 101, (const char *) "Looking for zrtp-hash\n");
  m = sdp->sdp_media;
  goto <D.38386>;
  <D.38385>:;
  if (got_audio != 0 && got_video != 0)
    {
      goto <D.38380>;
    }
  if (m->m_port != 0 && ((unsigned int) m->m_type == 2 && got_audio == 0 || (unsigned int) m->m_type == 3 && got_video == 0))
    {
      attr = m->m_attributes;
      goto <D.38384>;
      <D.38383>:;
      if (_zstr (attr->a_name) != 0)
        {
          // predicted unlikely by continue predictor.;
          goto <D.38381>;
        }
      if (strcasecmp (attr->a_name, (const char *) "zrtp-hash") != 0 || attr->a_value == 0B)
        {
          // predicted unlikely by continue predictor.;
          goto <D.38381>;
        }
      if ((unsigned int) m->m_type == 2)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 343, (const char *) switch_channel_get_session (channel), 7, (const char *) "Found audio zrtp-hash; setting r_sdp_audio_zrtp_hash=%s\n", attr->a_value);
          switch_channel_set_variable_var_check (channel, (const char *) "r_sdp_audio_zrtp_hash", attr->a_value, 1);
          audio_engine->remote_sdp_zrtp_hash = switch_core_perform_session_strdup (session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 346);
          got_audio++ ;
        }
      else
        {
          if ((unsigned int) m->m_type == 3)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 349, (const char *) switch_channel_get_session (channel), 7, (const char *) "Found video zrtp-hash; setting r_sdp_video_zrtp_hash=%s\n", attr->a_value);
              switch_channel_set_variable_var_check (channel, (const char *) "r_sdp_video_zrtp_hash", attr->a_value, 1);
              video_engine->remote_sdp_zrtp_hash = switch_core_perform_session_strdup (session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 352);
              got_video++ ;
            }
        }
      switch_channel_set_flag_value (channel, 75, 1);
      goto <D.38382>;
      <D.38381>:;
      attr = attr->a_next;
      <D.38384>:;
      if (attr != 0B) goto <D.38383>; else goto <D.38382>;
      <D.38382>:;
    }
  m = m->m_next;
  <D.38386>:;
  if (m != 0B) goto <D.38385>; else goto <D.38380>;
  <D.38380>:;
}



;; Function switch_core_media_process_udptl (null)
;; enabled by -tree-original

{
  struct switch_t38_options_t * t38_options = (struct switch_t38_options_t *) switch_channel_get_private (session->channel, (const char *) "t38_options");
  struct sdp_attribute_t * attr;
  static const char __func__[32] = "switch_core_media_process_udptl";

    static const char __func__[32] = "switch_core_media_process_udptl";
    struct switch_t38_options_t * t38_options = (struct switch_t38_options_t *) switch_channel_get_private (session->channel, (const char *) "t38_options");
    struct sdp_attribute_t * attr;
  if (t38_options == 0B)
    {
      t38_options = (struct switch_t38_options_t *) switch_core_perform_session_alloc (session, 60, (const char *) "src/switch_core_media.c", (const char *) &__func__, 369);
      t38_options->T38FaxVersion = 0;
      t38_options->T38MaxBitRate = 14400;
      t38_options->T38FaxRateManagement = (const char *) switch_core_perform_session_strdup (session, (const char *) "transferredTCF", (const char *) "src/switch_core_media.c", (const char *) &__func__, 374);
      t38_options->T38FaxUdpEC = (const char *) switch_core_perform_session_strdup (session, (const char *) "t38UDPRedundancy", (const char *) "src/switch_core_media.c", (const char *) &__func__, 375);
      t38_options->T38FaxMaxBuffer = 500;
      t38_options->T38FaxMaxDatagram = 500;
    }
  t38_options->remote_port = (short unsigned int) m->m_port;
  if (sdp->sdp_origin != 0B)
    {
      t38_options->sdp_o_line = (const char *) switch_core_perform_session_strdup (session, sdp->sdp_origin->o_username, (const char *) "src/switch_core_media.c", (const char *) &__func__, 383);
    }
  else
    {
      t38_options->sdp_o_line = (const char *) "unknown";
    }
  if (m->m_connections != 0B && m->m_connections->c_address != 0B)
    {
      t38_options->remote_ip = (const char *) switch_core_perform_session_strdup (session, m->m_connections->c_address, (const char *) "src/switch_core_media.c", (const char *) &__func__, 389);
    }
  else
    {
      if ((sdp != 0B && sdp->sdp_connection != 0B) && sdp->sdp_connection->c_address != 0B)
        {
          t38_options->remote_ip = (const char *) switch_core_perform_session_strdup (session, sdp->sdp_connection->c_address, (const char *) "src/switch_core_media.c", (const char *) &__func__, 391);
        }
    }
  attr = m->m_attributes;
  goto <D.38396>;
  <D.38395>:;
  if (strcasecmp (attr->a_name, (const char *) "T38FaxVersion") == 0 && attr->a_value != 0B)
    {
      t38_options->T38FaxVersion = (short unsigned int) atoi (attr->a_value);
    }
  else
    {
      if (strcasecmp (attr->a_name, (const char *) "T38MaxBitRate") == 0 && attr->a_value != 0B)
        {
          t38_options->T38MaxBitRate = (unsigned int) atoi (attr->a_value);
        }
      else
        {
          if (strcasecmp (attr->a_name, (const char *) "T38FaxFillBitRemoval") == 0)
            {
              t38_options->T38FaxFillBitRemoval = (switch_bool_t) switch_safe_atoi (attr->a_value, 1);
            }
          else
            {
              if (strcasecmp (attr->a_name, (const char *) "T38FaxTranscodingMMR") == 0)
                {
                  t38_options->T38FaxTranscodingMMR = (switch_bool_t) switch_safe_atoi (attr->a_value, 1);
                }
              else
                {
                  if (strcasecmp (attr->a_name, (const char *) "T38FaxTranscodingJBIG") == 0)
                    {
                      t38_options->T38FaxTranscodingJBIG = (switch_bool_t) switch_safe_atoi (attr->a_value, 1);
                    }
                  else
                    {
                      if (strcasecmp (attr->a_name, (const char *) "T38FaxRateManagement") == 0 && attr->a_value != 0B)
                        {
                          t38_options->T38FaxRateManagement = (const char *) switch_core_perform_session_strdup (session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 406);
                        }
                      else
                        {
                          if (strcasecmp (attr->a_name, (const char *) "T38FaxMaxBuffer") == 0 && attr->a_value != 0B)
                            {
                              t38_options->T38FaxMaxBuffer = (unsigned int) atoi (attr->a_value);
                            }
                          else
                            {
                              if (strcasecmp (attr->a_name, (const char *) "T38FaxMaxDatagram") == 0 && attr->a_value != 0B)
                                {
                                  t38_options->T38FaxMaxDatagram = (unsigned int) atoi (attr->a_value);
                                }
                              else
                                {
                                  if (strcasecmp (attr->a_name, (const char *) "T38FaxUdpEC") == 0 && attr->a_value != 0B)
                                    {
                                      t38_options->T38FaxUdpEC = (const char *) switch_core_perform_session_strdup (session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 412);
                                    }
                                  else
                                    {
                                      if (strcasecmp (attr->a_name, (const char *) "T38VendorInfo") == 0 && attr->a_value != 0B)
                                        {
                                          t38_options->T38VendorInfo = (const char *) switch_core_perform_session_strdup (session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 414);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  attr = attr->a_next;
  <D.38396>:;
  if (attr != 0B) goto <D.38395>; else goto <D.38397>;
  <D.38397>:;
  switch_channel_set_variable_var_check (session->channel, (const char *) "has_t38", (const char *) "true", 1);
  switch_channel_set_private (session->channel, (const char *) "t38_options", (const void *) t38_options);
  switch_channel_set_app_flag_key ((const char *) "T38", session->channel, 2);
  switch_channel_execute_on (session->channel, (const char *) "sip_execute_on_image");
  switch_channel_api_on (session->channel, (const char *) "sip_api_on_image");
  return t38_options;
}



;; Function switch_core_media_extract_t38_options (null)
;; enabled by -tree-original

{
  struct sdp_media_t * m;
  struct sdp_parser_t * parser = 0B;
  struct sdp_session_t * sdp;
  struct switch_t38_options_t * t38_options = 0B;

    struct sdp_media_t * m;
    struct sdp_parser_t * parser = 0B;
    struct sdp_session_t * sdp;
    struct switch_t38_options_t * t38_options = 0B;
  if ((parser = sdp_parse (0B, r_sdp, (int) strlen (r_sdp), 0)) == 0B)
    {
      return 0B;
    }
  if ((sdp = sdp_session (parser)) == 0B)
    {
      sdp_parser_free (parser);
      return 0B;
    }
  m = sdp->sdp_media;
  goto <D.38408>;
  <D.38407>:;
  if (((unsigned int) m->m_proto == 258 && (unsigned int) m->m_type == 8) && m->m_port != 0)
    {
      t38_options = switch_core_media_process_udptl (session, sdp, m);
      goto <D.38406>;
    }
  m = m->m_next;
  <D.38408>:;
  if (m != 0B) goto <D.38407>; else goto <D.38406>;
  <D.38406>:;
  sdp_parser_free (parser);
  return t38_options;
}



;; Function switch_core_media_process_t38_passthru (null)
;; enabled by -tree-original

{
  char * remote_host;
  switch_port_t remote_port;
  char tmp[32] = "";
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_process_t38_passthru";
  static const char __func__[39] = "switch_core_media_process_t38_passthru";

    static const char __func__[39] = "switch_core_media_process_t38_passthru";
    static const char __PRETTY_FUNCTION__[39] = "switch_core_media_process_t38_passthru";
    char * remote_host;
    switch_port_t remote_port;
    char tmp[32] = "";
    struct switch_rtp_engine_t * a_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 473, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
  remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
  a_engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (session, t38_options->remote_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 484);
  a_engine->cur_payload_map->remote_sdp_port = t38_options->remote_port;
  if (((remote_host != 0B && (short unsigned int) remote_port != 0) && TARGET_EXPR <D.38429, {
    size_t __s1_len;
    size_t __s2_len;

        size_t __s1_len;
        size_t __s2_len;
    D.38429 = __builtin_strcmp ((const char *) remote_host, (const char *) a_engine->cur_payload_map->remote_sdp_ip);
  }> == 0) && (short unsigned int) a_engine->cur_payload_map->remote_sdp_port == (short unsigned int) remote_port)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 489, (const char *) session, 7, (const char *) "Audio params are unchanged for %s.\n", switch_channel_get_name (session->channel));
    }
  else
    {
      {
        const char * err = 0B;

                const char * err = 0B;
        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 495, (const char *) session, 7, (const char *) "Audio params changed for %s from %s:%d to %s:%d\n", switch_channel_get_name (session->channel), remote_host, (int) remote_port, a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
        switch_snprintf ((char *) &tmp, 32, (const char *) "%d", (int) a_engine->cur_payload_map->remote_sdp_port);
        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_ip", (const char *) a_engine->cur_payload_map->remote_sdp_ip, 1);
        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
        if ((unsigned int) switch_rtp_set_remote_address (a_engine->rtp_session, (const char *) a_engine->cur_payload_map->remote_sdp_ip, a_engine->cur_payload_map->remote_sdp_port, 0, 1, &err) != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 505, (const char *) session, 3, (const char *) "AUDIO RTP REPORTS ERROR: [%s]\n", err);
            switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 506, 88);
          }
      }
    }
  switch_core_media_copy_t38_options (t38_options, other_session);
  return 0;
}



;; Function switch_core_session_get_payload_code (null)
;; enabled by -tree-original

{
  struct payload_map_t * pmap;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  switch_payload_t pt = 0;
  switch_payload_t recv_pt = 0;
  int found = 0;
  char * fmtp = 0B;
  static const char __PRETTY_FUNCTION__[37] = "switch_core_session_get_payload_code";

    static const char __PRETTY_FUNCTION__[37] = "switch_core_session_get_payload_code";
    struct payload_map_t * pmap;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * engine;
    switch_payload_t pt = 0;
    switch_payload_t recv_pt = 0;
    int found = 0;
    char * fmtp = 0B;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 530, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  switch_mutex_lock (smh->sdp_mutex);
  pmap = engine->payload_map;
  goto <D.38450>;
  <D.38449>:;
  if ((unsigned char) pmap->allocated == 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.38447>;
    }
  if (strcasecmp ((const char *) pmap->iananame, iananame) == 0)
    {
      pt = pmap->pt;
      recv_pt = pmap->recv_pt;
      fmtp = pmap->rm_fmtp;
      found++ ;
      goto <D.38448>;
    }
  <D.38447>:;
  pmap = (struct payload_map_t *) pmap->next;
  <D.38450>:;
  if (pmap != 0B) goto <D.38449>; else goto <D.38448>;
  <D.38448>:;
  switch_mutex_unlock (smh->sdp_mutex);
  if (found != 0)
    {
      if (ptP != 0B)
        {
          *ptP = pt;
        }
      if (recv_ptP != 0B)
        {
          *recv_ptP = recv_pt;
        }
      if (_zstr ((const char *) fmtp) == 0 && fmtpP != 0B)
        {
          *fmtpP = fmtp;
        }
      return 0;
    }
  return 1;
}



;; Function switch_core_media_add_payload_map (null)
;; enabled by -tree-original

{
  struct payload_map_t * pmap;
  int exists = 0;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  int local_pt = 0;
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_add_payload_map";
  static const char __func__[34] = "switch_core_media_add_payload_map";

    static const char __func__[34] = "switch_core_media_add_payload_map";
    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_add_payload_map";
    struct payload_map_t * pmap;
    int exists = 0;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * engine;
    int local_pt = 0;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 589, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0B;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  switch_mutex_lock (smh->sdp_mutex);
  pmap = engine->payload_map;
  goto <D.38480>;
  <D.38479>:;
  exists = (strcasecmp (name, (const char *) pmap->iananame) == 0 && (pmap->rate == 0 || pmap->rate == rate)) && (pmap->ptime == 0 || pmap->ptime == ptime);
  if (exists != 0)
    {
      if (_zstr (fmtp) == 0 && _zstr ((const char *) pmap->rm_fmtp) == 0)
        {
          if (TARGET_EXPR <D.38476, {
            size_t __s1_len;
            size_t __s2_len;

                        size_t __s1_len;
                        size_t __s2_len;
            D.38476 = __builtin_strcmp ((const char *) pmap->rm_fmtp, fmtp);
          }> != 0)
            {
              exists = 0;
              local_pt = (int) pmap->pt;
              // predicted unlikely by continue predictor.;
              goto <D.38477>;
            }
        }
      goto <D.38478>;
    }
  <D.38477>:;
  pmap = (struct payload_map_t *) pmap->next;
  <D.38480>:;
  if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.38479>; else goto <D.38478>;
  <D.38478>:;
  if (exists == 0)
    {
      {
        switch_ssize_t hlen = -1;

                switch_ssize_t hlen = -1;
        if (engine->payload_map != 0B && (unsigned char) engine->payload_map->allocated == 0)
          {
            pmap = engine->payload_map;
          }
        else
          {
            pmap = (struct payload_map_t *) switch_core_perform_alloc (session->pool, 84, (const char *) "src/switch_core_media.c", (const char *) &__func__, 624);
          }
        pmap->type = type;
        pmap->iananame = switch_core_perform_strdup (session->pool, name, (const char *) "src/switch_core_media.c", (const char *) &__func__, 628);
        pmap->rm_encoding = pmap->iananame;
        pmap->hash = (long unsigned int) switch_ci_hashfunc_default ((const char *) pmap->iananame, &hlen);
      }
    }
  pmap->sdp_type = sdp_type;
  if (ptime != 0)
    {
      pmap->ptime = ptime;
    }
  if (rate != 0)
    {
      pmap->rate = rate;
    }
  if (_zstr (fmtp) == 0 && (_zstr ((const char *) pmap->rm_fmtp) != 0 || TARGET_EXPR <D.38491, {
    size_t __s1_len;
    size_t __s2_len;

        size_t __s1_len;
        size_t __s2_len;
    D.38491 = __builtin_strcmp ((const char *) pmap->rm_fmtp, fmtp);
  }> != 0))
    {
      pmap->rm_fmtp = switch_core_perform_strdup (session->pool, fmtp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 644);
    }
  pmap->allocated = 1;
  pmap->recv_pt = (unsigned char) pt;
  if ((unsigned int) sdp_type == 0 || exists == 0)
    {
      pmap->pt = local_pt != 0 ? (unsigned char) local_pt : (unsigned char) pt;
    }
  if ((unsigned char) negotiated != 0)
    {
      pmap->negotiated = negotiated;
    }
  if (exists == 0)
    {
      if (engine->payload_map == pmap)
        {
          engine->pmap_tail = pmap;
        }
      else
        {
          if (engine->payload_map == 0B)
            {
              engine->payload_map = engine->pmap_tail = pmap;
            }
          else
            {
              engine->pmap_tail->next = (struct payload_map_s *) pmap;
              engine->pmap_tail = (struct payload_map_t *) engine->pmap_tail->next;
            }
        }
    }
  switch_mutex_unlock (smh->sdp_mutex);
  return pmap;
}



;; Function switch_core_media_get_codec_string (null)
;; enabled by -tree-original

{
  const char * preferred = 0B;
  const char * fallback = 0B;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_get_codec_string";

    static const char __PRETTY_FUNCTION__[35] = "switch_core_media_get_codec_string";
    const char * preferred = 0B;
    const char * fallback = 0B;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 685, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      preferred = (const char *) "PCMU";
      fallback = (const char *) "PCMU";
    }
  else
    {
      if ((preferred = switch_channel_get_variable_dup (session->channel, (const char *) "absolute_codec_string", 1, -1)) == 0B)
        {
          preferred = switch_channel_get_variable_dup (session->channel, (const char *) "codec_string", 1, -1);
        }
      if (preferred == 0B)
        {
          if ((unsigned int) switch_channel_direction (session->channel) == 1)
            {
              preferred = (const char *) smh->mparams->outbound_codec_string;
              fallback = (const char *) smh->mparams->inbound_codec_string;
            }
          else
            {
              preferred = (const char *) smh->mparams->inbound_codec_string;
              fallback = (const char *) smh->mparams->outbound_codec_string;
            }
        }
    }
  return _zstr (preferred) == 0 ? preferred : fallback;
}



;; Function switch_core_session_clear_crypto (null)
;; enabled by -tree-original

{
  int i;
  struct switch_media_handle_t * smh;
  const char * vars[11] = {(const char *) "rtp_last_audio_local_crypto_key", (const char *) "srtp_remote_audio_crypto_key", (const char *) "srtp_remote_audio_crypto_tag", (const char *) "srtp_remote_audio_crypto_type", (const char *) "srtp_remote_video_crypto_key", (const char *) "srtp_remote_video_crypto_tag", (const char *) "srtp_remote_video_crypto_type", (const char *) "rtp_secure_media", (const char *) "rtp_secure_media_inbound", (const char *) "rtp_secure_media_outbound", 0B};

    int i;
    struct switch_media_handle_t * smh;
    const char * vars[11] = {(const char *) "rtp_last_audio_local_crypto_key", (const char *) "srtp_remote_audio_crypto_key", (const char *) "srtp_remote_audio_crypto_tag", (const char *) "srtp_remote_audio_crypto_type", (const char *) "srtp_remote_video_crypto_key", (const char *) "srtp_remote_video_crypto_tag", (const char *) "srtp_remote_video_crypto_type", (const char *) "rtp_secure_media", (const char *) "rtp_secure_media_inbound", (const char *) "rtp_secure_media_outbound", 0B};
  i = 0;
  goto <D.38506>;
  <D.38505>:;
  switch_channel_set_variable_var_check (session->channel, vars[i], 0B, 1);
  i++ ;
  <D.38506>:;
  if (vars[i] != 0B) goto <D.38505>; else goto <D.38507>;
  <D.38507>:;
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  i = 0;
  goto <D.38509>;
  <D.38508>:;
  memset ((void *) &smh->engines[0].ssec + (unsigned int) ((unsigned int) i * 144), 0, 144);
  memset ((void *) &smh->engines[1].ssec + (unsigned int) ((unsigned int) i * 144), 0, 144);
  i++ ;
  <D.38509>:;
  if (i <= 8) goto <D.38508>; else goto <D.38510>;
  <D.38510>:;
}



;; Function switch_core_session_local_crypto_key (null)
;; enabled by -tree-original

{
  if (session->media_handle == 0B)
    {
      return 0B;
    }
  return (const char *) session->media_handle->engines[(unsigned int) type].ssec[(unsigned int) session->media_handle->engines[(unsigned int) type].crypto_type].local_crypto_key;
}



;; Function switch_core_media_parse_rtp_bugs (null)
;; enabled by -tree-original

{
  if (switch_stristr ((const char *) "clear", str) != 0B)
    {
      *flag_pole = 0;
    }
  if (switch_stristr ((const char *) "CISCO_SKIP_MARK_BIT_2833", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 1);
    }
  if (switch_stristr ((const char *) "~CISCO_SKIP_MARK_BIT_2833", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967294);
    }
  if (switch_stristr ((const char *) "SONUS_SEND_INVALID_TIMESTAMP_2833", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 2);
    }
  if (switch_stristr ((const char *) "~SONUS_SEND_INVALID_TIMESTAMP_2833", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967293);
    }
  if (switch_stristr ((const char *) "IGNORE_MARK_BIT", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 4);
    }
  if (switch_stristr ((const char *) "~IGNORE_MARK_BIT", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967291);
    }
  if (switch_stristr ((const char *) "SEND_LINEAR_TIMESTAMPS", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 8);
    }
  if (switch_stristr ((const char *) "~SEND_LINEAR_TIMESTAMPS", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967287);
    }
  if (switch_stristr ((const char *) "START_SEQ_AT_ZERO", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 16);
    }
  if (switch_stristr ((const char *) "~START_SEQ_AT_ZERO", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967279);
    }
  if (switch_stristr ((const char *) "NEVER_SEND_MARKER", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 32);
    }
  if (switch_stristr ((const char *) "~NEVER_SEND_MARKER", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967263);
    }
  if (switch_stristr ((const char *) "IGNORE_DTMF_DURATION", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 64);
    }
  if (switch_stristr ((const char *) "~IGNORE_DTMF_DURATION", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967231);
    }
  if (switch_stristr ((const char *) "ACCEPT_ANY_PACKETS", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 128);
    }
  if (switch_stristr ((const char *) "~ACCEPT_ANY_PACKETS", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967167);
    }
  if (switch_stristr ((const char *) "ACCEPT_ANY_PAYLOAD", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 2048);
    }
  if (switch_stristr ((const char *) "~ACCEPT_ANY_PAYLOAD", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294965247);
    }
  if (switch_stristr ((const char *) "GEN_ONE_GEN_ALL", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 256);
    }
  if (switch_stristr ((const char *) "~GEN_ONE_GEN_ALL", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294967039);
    }
  if (switch_stristr ((const char *) "CHANGE_SSRC_ON_MARKER", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 512);
    }
  if (switch_stristr ((const char *) "~CHANGE_SSRC_ON_MARKER", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294966783);
    }
  if (switch_stristr ((const char *) "FLUSH_JB_ON_DTMF", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole | 1024);
    }
  if (switch_stristr ((const char *) "~FLUSH_JB_ON_DTMF", str) != 0B)
    {
      *flag_pole = (switch_rtp_bug_flag_t) ((unsigned int) *flag_pole & 4294966271);
    }
}



;; Function switch_core_media_build_crypto (null)
;; enabled by -tree-original

{
  unsigned char b64_key[512] = "";
  unsigned char * key;
  const char * val;
  struct switch_channel_t * channel;
  char * p;
  struct switch_rtp_engine_t * engine;
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_build_crypto";
  static const char __func__[31] = "switch_core_media_build_crypto";

    static const char __func__[31] = "switch_core_media_build_crypto";
    static const char __PRETTY_FUNCTION__[31] = "switch_core_media_build_crypto";
    unsigned char b64_key[512] = "";
    unsigned char * key;
    const char * val;
    struct switch_channel_t * channel;
    char * p;
    struct switch_rtp_engine_t * engine;
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 869, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  channel = switch_core_session_get_channel (smh->session);
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  if (force == 0 && engine->ssec[(unsigned int) ctype].local_raw_key[0] != 0)
    {
      return 0;
    }
  if ((unsigned int) direction == 0)
    {
      key = (unsigned char *) &engine->ssec[(unsigned int) ctype].local_raw_key;
    }
  else
    {
      key = (unsigned char *) &engine->ssec[(unsigned int) ctype].remote_raw_key;
    }
  switch_rtp_get_random ((void *) key, (uint32_t) SUITES[(unsigned int) ctype].keylen);
  switch_b64_encode (key, (switch_size_t) SUITES[(unsigned int) ctype].keylen, (unsigned char *) &b64_key, 512);
  p = strrchr ((const char *) &b64_key, 61);
  goto <D.38535>;
  <D.38534>:;
  *p--  = 0;
  <D.38535>:;
  if ((p != 0B && (unsigned char) *p != 0) && (unsigned char) *p == 61) goto <D.38534>; else goto <D.38536>;
  <D.38536>:;
  if (index == 0)
    {
      index = (int) ((unsigned int) ctype + 1);
    }
  engine->ssec[(unsigned int) ctype].local_crypto_key = switch_core_session_sprintf (smh->session, (const char *) "%d %s inline:%s", index, SUITES[(unsigned int) ctype].name, (unsigned char *) &b64_key);
  switch_channel_set_variable_name_printf (smh->session->channel, (const char *) engine->ssec[(unsigned int) ctype].local_crypto_key, (const char *) "rtp_last_%s_local_crypto_key", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
  switch_channel_set_flag_value (smh->session->channel, 92, 1);
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 916, (const char *) smh->session, 7, (const char *) "Set Local %s crypto Key [%s]\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", engine->ssec[(unsigned int) ctype].local_crypto_key);
  if (((unsigned int) smh->mparams->ndlb & 8) == 0 && ((val = switch_channel_get_variable_dup (channel, (const char *) "NDLB_support_asterisk_missing_srtp_auth", 1, -1)) == 0B || switch_true (val) == 0))
    {
      engine->ssec[(unsigned int) ctype].crypto_type = ctype;
    }
  else
    {
      engine->ssec[(unsigned int) ctype].crypto_type = 8;
    }
  return 0;
}



;; Function switch_core_media_add_crypto (null)
;; enabled by -tree-original

{
  unsigned char key[64];
  switch_rtp_crypto_key_type_t type;
  char * p;
  static const char __func__[29] = "switch_core_media_add_crypto";
  void bad = <<< error >>>;

    static const char __func__[29] = "switch_core_media_add_crypto";
    unsigned char key[64];
    switch_rtp_crypto_key_type_t type;
    char * p;
  p = __builtin_strchr (key_str, 32);
  if ((p != 0B && (unsigned char) *p != 0) && (unsigned char) *(p + 1) != 0)
    {
      p++ ;
      type = switch_core_media_crypto_str2type ((const char *) p);
      if ((unsigned int) type == 9)
        {
          switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 949, 0B, 3, (const char *) "Parse Error near [%s]\n", p);
          goto bad;
        }
      p = __builtin_strchr ((const char *) p, 32);
      if ((p != 0B && (unsigned char) *p != 0) && (unsigned char) *(p + 1) != 0)
        {
          p++ ;
          if (strncasecmp ((const char *) p, (const char *) "inline:", 7) != 0)
            {
              switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 957, 0B, 3, (const char *) "Parse Error near [%s]\n", p);
              goto bad;
            }
          p = p + 7;
          switch_b64_decode (p, (char *) &key, 64);
          if ((unsigned int) direction == 0)
            {
              memcpy ((void * restrict) &ssec->local_raw_key, (const void * restrict) &key, (size_t) SUITES[(unsigned int) type].keylen);
            }
          else
            {
              memcpy ((void * restrict) &ssec->remote_raw_key, (const void * restrict) &key, (size_t) SUITES[(unsigned int) type].keylen);
            }
          return 0;
        }
    }
  bad:;
  switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 976, 0B, 3, (const char *) "Error!\n");
  return 1;
}



;; Function switch_core_media_set_rtp_session (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine;

    struct switch_rtp_engine_t * engine;
  if (session->media_handle == 0B)
    {
      return;
    }
  engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  engine->rtp_session = rtp_session;
  engine->type = type;
}



;; Function switch_core_session_get_recovery_crypto_key (null)
;; enabled by -tree-original

{
  const char * tmp;
  struct switch_rtp_engine_t * engine;
  char * keyvar;
  char * tagvar;
  char * ctypevar;
  static const char __func__[44] = "switch_core_session_get_recovery_crypto_key";

    static const char __func__[44] = "switch_core_session_get_recovery_crypto_key";
    const char * tmp;
    struct switch_rtp_engine_t * engine;
    char * keyvar;
    char * tagvar;
    char * ctypevar;
  if (session->media_handle == 0B)
    {
      return;
    }
  engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  if ((unsigned int) type == 0)
    {
      keyvar = (char *) "srtp_remote_audio_crypto_key";
      tagvar = (char *) "srtp_remote_audio_crypto_tag";
      ctypevar = (char *) "srtp_remote_audio_crypto_type";
    }
  else
    {
      keyvar = (char *) "srtp_remote_video_crypto_key";
      tagvar = (char *) "srtp_remote_video_crypto_tag";
      ctypevar = (char *) "srtp_remote_video_crypto_type";
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) keyvar, 1, -1)) != 0B)
    {
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) ctypevar, 1, -1)) != 0B)
        {
          engine->crypto_type = switch_core_media_crypto_str2type (tmp);
        }
      engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key = switch_core_perform_session_strdup (session, tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1015);
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) tagvar, 1, -1)) != 0B)
        {
          {
            int tv = atoi (tmp);

                        int tv = atoi (tmp);
            engine->ssec[(unsigned int) engine->crypto_type].crypto_tag = tv;
          }
        }
      else
        {
          engine->ssec[(unsigned int) engine->crypto_type].crypto_tag = 1;
        }
      switch_channel_set_flag_value (session->channel, 92, 1);
    }
}



;; Function switch_core_session_apply_crypto (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine;
  const char * varname;

    struct switch_rtp_engine_t * engine;
    const char * varname;
  if ((unsigned int) type == 0)
    {
      varname = (const char *) "rtp_secure_audio_confirmed";
    }
  else
    {
      varname = (const char *) "rtp_secure_video_confirmed";
    }
  if (session->media_handle == 0B)
    {
      return;
    }
  engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  if (switch_channel_test_flag (session->channel, 84) != 0)
    {
      return;
    }
  if (engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key != 0B && switch_channel_test_flag (session->channel, 92) != 0)
    {
      switch_core_media_add_crypto ((struct switch_secure_settings_t *) &engine->ssec + (unsigned int) ((unsigned int) engine->crypto_type * 144), (const char *) engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key, 1);
      switch_rtp_add_crypto_key (engine->rtp_session, 0, 1, engine->ssec[(unsigned int) engine->crypto_type].crypto_type, (unsigned char *) &engine->ssec[(unsigned int) engine->crypto_type].local_raw_key, (switch_size_t) SUITES[(unsigned int) engine->ssec[(unsigned int) engine->crypto_type].crypto_type].keylen);
      switch_rtp_add_crypto_key (engine->rtp_session, 1, (uint32_t) engine->ssec[(unsigned int) engine->crypto_type].crypto_tag, engine->ssec[(unsigned int) engine->crypto_type].crypto_type, (unsigned char *) &engine->ssec[(unsigned int) engine->crypto_type].remote_raw_key, (switch_size_t) SUITES[(unsigned int) engine->ssec[(unsigned int) engine->crypto_type].crypto_type].keylen);
      switch_channel_set_variable_var_check (session->channel, varname, (const char *) "true", 1);
      switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_secure_media_negotiated", (const char *) SUITES[(unsigned int) engine->crypto_type].name, 1);
    }
}



;; Function switch_core_session_parse_crypto_prefs (null)
;; enabled by -tree-original

{
  const char * var = 0B;
  const char * val = 0B;
  char * suites = 0B;
  struct switch_media_handle_t * smh;
  char * fields[10];
  int argc = 0;
  int i = 0;
  int j = 0;
  int k = 0;
  static const char __func__[39] = "switch_core_session_parse_crypto_prefs";

    static const char __func__[39] = "switch_core_session_parse_crypto_prefs";
    const char * var = 0B;
    const char * val = 0B;
    char * suites = 0B;
    struct switch_media_handle_t * smh;
    char * fields[10];
    int argc = 0;
    int i = 0;
    int j = 0;
    int k = 0;
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if (switch_channel_test_flag (session->channel, 106) != 0)
    {
      return;
    }
  if ((unsigned int) switch_channel_direction (session->channel) == 0)
    {
      var = (const char *) "rtp_secure_media_inbound";
    }
  else
    {
      var = (const char *) "rtp_secure_media_outbound";
    }
  if ((val = switch_channel_get_variable_dup (session->channel, var, 1, -1)) == 0B)
    {
      var = (const char *) "rtp_secure_media";
      val = switch_channel_get_variable_dup (session->channel, var, 1, -1);
    }
  if (_zstr (val) == 0 && (suites = __builtin_strchr (val, 58)) != 0B)
    {
      *suites++  = 0;
    }
  if (_zstr ((const char *) suites) != 0)
    {
      suites = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtp_secure_media_suites", 1, -1);
    }
  if (_zstr (val) != 0)
    {
      if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 84) == 0)
        {
          val = (const char *) "optional";
        }
      else
        {
          val = (const char *) "forbidden";
        }
    }
  if (strcasecmp (val, (const char *) "optional") == 0)
    {
      smh->crypto_mode = 0;
    }
  else
    {
      if (switch_true (val) != 0 || strcasecmp (val, (const char *) "mandatory") == 0)
        {
          smh->crypto_mode = 1;
        }
      else
        {
          smh->crypto_mode = 2;
          if (switch_false (val) == 0 && strcasecmp (val, (const char *) "forbidden") != 0)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1123, (const char *) session, 4, (const char *) "INVALID VALUE FOR %s defaulting to \'forbidden\'\n", var);
            }
        }
    }
  if ((unsigned int) smh->crypto_mode != 2 && _zstr ((const char *) suites) == 0)
    {
      argc = (int) switch_separate_string (suites, 58, (char * *) &fields, 10);
      i = 0;
      goto <D.38589>;
      <D.38588>:;
      {
        int ok = 0;

                int ok = 0;
        j = 0;
        goto <D.38587>;
        <D.38586>:;
        if (strcasecmp ((const char *) fields[i], (const char *) SUITES[j].name) == 0)
          {
            smh->crypto_suite_order[k++ ] = SUITES[j].type;
            ok++ ;
            goto <D.38585>;
          }
        j++ ;
        <D.38587>:;
        if (j <= 8) goto <D.38586>; else goto <D.38585>;
        <D.38585>:;
        if (ok == 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1142, (const char *) session, 4, (const char *) "INVALID SUITE SUPPLIED\n");
          }
      }
      i++ ;
      <D.38589>:;
      if (i < argc) goto <D.38588>; else goto <D.38590>;
      <D.38590>:;
    }
  else
    {
      i = 0;
      goto <D.38592>;
      <D.38591>:;
      smh->crypto_suite_order[k++ ] = SUITES[i].type;
      i++ ;
      <D.38592>:;
      if (i <= 8) goto <D.38591>; else goto <D.38593>;
      <D.38593>:;
    }
}



;; Function switch_core_session_check_incoming_crypto (null)
;; enabled by -tree-original

{
  int got_crypto = 0;
  int i = 0;
  int ctype = 0;
  const char * vval = 0B;
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  static const char __func__[42] = "switch_core_session_check_incoming_crypto";
  void end = <<< error >>>;

    static const char __func__[42] = "switch_core_session_check_incoming_crypto";
    int got_crypto = 0;
    int i = 0;
    int ctype = 0;
    const char * vval = 0B;
    struct switch_rtp_engine_t * engine;
    struct switch_media_handle_t * smh;
  if ((smh = session->media_handle) == 0B)
    {
      return 0;
    }
  if ((unsigned int) smh->crypto_mode == 2)
    {
      return -1;
    }
  engine = (struct switch_rtp_engine_t *) &session->media_handle->engines + (unsigned int) ((unsigned int) type * 11416);
  i = 0;
  goto <D.38612>;
  <D.38611>:;
  {
    switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;

        switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;
    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1179, (const char *) session, 7, (const char *) "looking for crypto suite [%s] in [%s]\n", SUITES[(unsigned int) j].name, crypto);
    if (switch_stristr ((const char *) SUITES[(unsigned int) j].name, crypto) != 0B)
      {
        ctype = (int) SUITES[(unsigned int) j].type;
        vval = (const char *) SUITES[(unsigned int) j].name;
        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1184, (const char *) session, 7, (const char *) "Found suite %s\n", vval);
        switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_secure_media_negotiated", vval, 1);
        goto <D.38610>;
      }
  }
  i++ ;
  <D.38612>:;
  if ((unsigned int) smh->crypto_suite_order[i] != 9) goto <D.38611>; else goto <D.38610>;
  <D.38610>:;
  if (engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key != 0B && (unsigned char) switch_rtp_ready (engine->rtp_session) != 0)
    {
      if ((crypto != 0B && (unsigned int) engine->crypto_type != 9) && TARGET_EXPR <D.38621, {
        size_t __s1_len;
        size_t __s2_len;

                size_t __s1_len;
                size_t __s2_len;
        D.38621 = __builtin_strcmp (crypto, (const char *) engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key);
      }> == 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1193, (const char *) session, 7, (const char *) "Existing key is still valid.\n");
          got_crypto = 1;
        }
      else
        {
          {
            const char * a = switch_stristr ((const char *) "AE", (const char *) engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key);
            const char * b = switch_stristr ((const char *) "AE", crypto);

                        const char * a = switch_stristr ((const char *) "AE", (const char *) engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key);
                        const char * b = switch_stristr ((const char *) "AE", crypto);
            if ((unsigned int) sdp_type == 0)
              {
                if (vval == 0B)
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1201, (const char *) session, 7, (const char *) "Unsupported Crypto [%s]\n", crypto);
                    goto end;
                  }
                switch_channel_set_variable_var_check (session->channel, varname, vval, 1);
                switch_core_media_build_crypto (session->media_handle, type, crypto_tag, (switch_rtp_crypto_key_type_t) ctype, 0, 1);
                switch_rtp_add_crypto_key (engine->rtp_session, 0, (uint32_t) atoi (crypto), engine->ssec[(unsigned int) engine->crypto_type].crypto_type, (unsigned char *) &engine->ssec[(unsigned int) engine->crypto_type].local_raw_key, (switch_size_t) SUITES[ctype].keylen);
              }
            if ((a != 0B && b != 0B) && strncasecmp (a, b, 23) == 0)
              {
                engine->crypto_type = (switch_rtp_crypto_key_type_t) ctype;
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1214, (const char *) session, 7, (const char *) "Change Remote key to [%s]\n", crypto);
                engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key = switch_core_perform_session_strdup (session, crypto, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1215);
                if ((unsigned int) engine->type == 0)
                  {
                    switch_channel_set_variable_var_check (session->channel, (const char *) "srtp_remote_audio_crypto_key", crypto, 1);
                    switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_audio_crypto_tag", (const char *) "%d", crypto_tag);
                    switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_audio_crypto_type", (const char *) "%s", switch_core_media_crypto_type2str ((switch_rtp_crypto_key_type_t) ctype));
                  }
                else
                  {
                    if ((unsigned int) engine->type == 1)
                      {
                        switch_channel_set_variable_var_check (session->channel, (const char *) "srtp_remote_video_crypto_key", crypto, 1);
                        switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_video_crypto_tag", (const char *) "%d", crypto_tag);
                        switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_video_crypto_type", (const char *) "%s", switch_core_media_crypto_type2str ((switch_rtp_crypto_key_type_t) ctype));
                      }
                  }
                engine->ssec[(unsigned int) engine->crypto_type].crypto_tag = crypto_tag;
                if ((unsigned char) switch_rtp_ready (engine->rtp_session) != 0 && switch_channel_test_flag (session->channel, 92) != 0)
                  {
                    switch_core_media_add_crypto ((struct switch_secure_settings_t *) &engine->ssec + (unsigned int) ((unsigned int) engine->crypto_type * 144), (const char *) engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key, 1);
                    switch_rtp_add_crypto_key (engine->rtp_session, 1, (uint32_t) engine->ssec[(unsigned int) engine->crypto_type].crypto_tag, engine->ssec[(unsigned int) engine->crypto_type].crypto_type, (unsigned char *) &engine->ssec[(unsigned int) engine->crypto_type].remote_raw_key, (switch_size_t) SUITES[(unsigned int) engine->ssec[(unsigned int) engine->crypto_type].crypto_type].keylen);
                  }
                got_crypto++ ;
              }
            else
              {
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1238, (const char *) session, 7, (const char *) "Ignoring unacceptable key\n");
              }
          }
        }
    }
  else
    {
      if ((unsigned char) switch_rtp_ready (engine->rtp_session) == 0)
        {
          if (vval == 0B)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1244, (const char *) session, 7, (const char *) "Unsupported Crypto [%s]\n", crypto);
              goto end;
            }
          engine->crypto_type = (switch_rtp_crypto_key_type_t) ctype;
          engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key = switch_core_perform_session_strdup (session, crypto, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1249);
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1250, (const char *) session, 7, (const char *) "Set Remote Key [%s]\n", engine->ssec[(unsigned int) engine->crypto_type].remote_crypto_key);
          if ((unsigned int) engine->type == 0)
            {
              switch_channel_set_variable_var_check (session->channel, (const char *) "srtp_remote_audio_crypto_key", crypto, 1);
              switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_audio_crypto_type", (const char *) "%s", switch_core_media_crypto_type2str ((switch_rtp_crypto_key_type_t) ctype));
            }
          else
            {
              if ((unsigned int) engine->type == 1)
                {
                  switch_channel_set_variable_var_check (session->channel, (const char *) "srtp_remote_video_crypto_key", crypto, 1);
                  switch_channel_set_variable_printf (session->channel, (const char *) "srtp_remote_video_crypto_type", (const char *) "%s", switch_core_media_crypto_type2str ((switch_rtp_crypto_key_type_t) ctype));
                }
            }
          engine->ssec[(unsigned int) engine->crypto_type].crypto_tag = crypto_tag;
          got_crypto++ ;
          switch_channel_set_variable_var_check (session->channel, varname, vval, 1);
          switch_channel_set_flag_value (smh->session->channel, 92, 1);
          if (_zstr ((const char *) engine->ssec[(unsigned int) engine->crypto_type].local_crypto_key) != 0)
            {
              switch_core_media_build_crypto (session->media_handle, type, crypto_tag, (switch_rtp_crypto_key_type_t) ctype, 0, 1);
            }
        }
    }
  end:;
  return got_crypto;
}



;; Function switch_core_session_check_outgoing_crypto (null)
;; enabled by -tree-original

{
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  struct switch_media_handle_t * smh;
  int i;

    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    struct switch_media_handle_t * smh;
    int i;
  if ((unsigned int) switch_core_session_media_handle_ready (session) != 0)
    {
      return;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if (smh->crypto_mode > 1)
    {
      return;
    }
  switch_channel_set_flag_value (channel, 92, 1);
  i = 0;
  goto <D.38632>;
  <D.38631>:;
  switch_core_media_build_crypto (session->media_handle, 0, 0, smh->crypto_suite_order[i], 0, 0);
  switch_core_media_build_crypto (session->media_handle, 1, 0, smh->crypto_suite_order[i], 0, 0);
  i++ ;
  <D.38632>:;
  if ((unsigned int) smh->crypto_suite_order[i] != 9) goto <D.38631>; else goto <D.38633>;
  <D.38633>:;
}



;; Function set_stats (null)
;; enabled by -tree-original

{
  struct switch_rtp_stats_t * stats = switch_core_media_get_stats (session, type, 0B);
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  char var_name[256] = "";
  char var_val[35] = "";

    struct switch_rtp_stats_t * stats = switch_core_media_get_stats (session, type, 0B);
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    char var_name[256] = "";
    char var_val[35] = "";
  if (stats != 0B)
    {
      stats->inbound.std_deviation = sqrt (stats->inbound.variance);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_raw_bytes");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.raw_bytes);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_media_bytes");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.media_bytes);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_media_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.media_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_skip_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.skip_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_jitter_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.jb_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_dtmf_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.dtmf_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_cng_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.cng_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_flush_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.flush_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_largest_jb_size");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.largest_jb_size);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_jitter_min_variance");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.min_variance);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_jitter_max_variance");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.max_variance);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_jitter_loss_rate");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.lossrate);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_jitter_burst_rate");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.burstrate);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_mean_interval");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.mean_interval);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_flaw_total");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->inbound.flaws);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_quality_percentage");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.R);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "in_mos");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%0.2f", stats->inbound.mos);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_raw_bytes");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.raw_bytes);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_media_bytes");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.media_bytes);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_media_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.media_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_skip_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.skip_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_dtmf_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.dtmf_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "out_cng_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->outbound.cng_packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "rtcp_packet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->rtcp.packet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
      switch_snprintf ((char *) &var_name, 256, (const char *) "rtp_%s_%s", prefix != 0B ? prefix : (const char *) "", (char *) "rtcp_octet_count");
      switch_snprintf ((char *) &var_val, 35, (const char *) "%d", stats->rtcp.octet_count);
      switch_channel_set_variable_var_check (channel, (const char *) &var_name, (const char *) &var_val, 1);
    }
}



;; Function switch_core_media_set_stats (null)
;; enabled by -tree-original

{
  if (session->media_handle == 0B)
    {
      return;
    }
  set_stats (session, 0, (const char *) "audio");
  set_stats (session, 1, (const char *) "video");
}



;; Function switch_media_handle_destroy (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  static const char __PRETTY_FUNCTION__[28] = "switch_media_handle_destroy";

    static const char __PRETTY_FUNCTION__[28] = "switch_media_handle_destroy";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 1378, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if ((unsigned int) switch_core_codec_ready (&a_engine->read_codec) != 0)
    {
      switch_core_codec_destroy (&a_engine->read_codec);
    }
  if ((unsigned int) switch_core_codec_ready (&a_engine->write_codec) != 0)
    {
      switch_core_codec_destroy (&a_engine->write_codec);
    }
  if ((unsigned int) switch_core_codec_ready (&v_engine->read_codec) != 0)
    {
      switch_core_codec_destroy (&v_engine->read_codec);
    }
  if ((unsigned int) switch_core_codec_ready (&v_engine->write_codec) != 0)
    {
      switch_core_codec_destroy (&v_engine->write_codec);
    }
  switch_core_session_unset_read_codec (session);
  switch_core_session_unset_write_codec (session);
  switch_core_media_deactivate_rtp (session);
}



;; Function switch_media_handle_create (null)
;; enabled by -tree-original

{
  switch_status_t status = 1;
  struct switch_media_handle_t * smh = 0B;
  int i;
  static const char __func__[27] = "switch_media_handle_create";

    static const char __func__[27] = "switch_media_handle_create";
    switch_status_t status = 1;
    struct switch_media_handle_t * smh = 0B;
    int i;
  *smhp = 0B;
  if (_zstr ((const char *) params->sdp_username) != 0)
    {
      params->sdp_username = (char *) "FreeSWITCH";
    }
  if ((session->media_handle = (struct switch_media_handle_t *) switch_core_perform_session_alloc (session, 23856, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1426)) != 0B)
    {
      session->media_handle->session = session;
      *smhp = session->media_handle;
      session->media_handle->flags = (smh_flag_t) ((unsigned int) session->media_handle->flags | 1);
      session->media_handle->media_flags[0] = 1;
      session->media_handle->engines[0].read_frame.buflen = 16384;
      session->media_handle->engines[0].type = 0;
      session->media_handle->engines[0].crypto_type = 9;
      i = 0;
      goto <D.38663>;
      <D.38662>:;
      session->media_handle->engines[0].ssec[i].crypto_type = (switch_rtp_crypto_key_type_t) i;
      i++ ;
      <D.38663>:;
      if (i <= 8) goto <D.38662>; else goto <D.38664>;
      <D.38664>:;
      session->media_handle->engines[1].read_frame.buflen = 16384;
      session->media_handle->engines[1].type = 1;
      session->media_handle->engines[1].crypto_type = 9;
      i = 0;
      goto <D.38666>;
      <D.38665>:;
      session->media_handle->engines[1].ssec[i].crypto_type = (switch_rtp_crypto_key_type_t) i;
      i++ ;
      <D.38666>:;
      if (i <= 8) goto <D.38665>; else goto <D.38667>;
      <D.38667>:;
      session->media_handle->mparams = params;
      i = 0;
      goto <D.38669>;
      <D.38668>:;
      session->media_handle->crypto_suite_order[i] = 9;
      i++ ;
      <D.38669>:;
      if (i <= 9) goto <D.38668>; else goto <D.38670>;
      <D.38670>:;
      switch_mutex_init (&session->media_handle->mutex, 1, switch_core_session_get_pool (session));
      switch_mutex_init (&session->media_handle->sdp_mutex, 1, switch_core_session_get_pool (session));
      session->media_handle->engines[0].ssrc = (unsigned int) &session->media_handle->engines + (unsigned int) time (0B);
      session->media_handle->engines[1].ssrc = (unsigned int) ((struct switch_rtp_engine_t *) &session->media_handle->engines + 11416) + (unsigned int) time (0B) / 2;
      session->media_handle->engines[0].payload_map = (struct payload_map_t *) switch_core_perform_alloc (session->pool, 84, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1464);
      session->media_handle->engines[0].cur_payload_map = session->media_handle->engines[0].payload_map;
      session->media_handle->engines[0].cur_payload_map->current = 1;
      session->media_handle->engines[1].payload_map = (struct payload_map_t *) switch_core_perform_alloc (session->pool, 84, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1467);
      session->media_handle->engines[1].cur_payload_map = session->media_handle->engines[1].payload_map;
      session->media_handle->engines[1].cur_payload_map->current = 1;
      switch_channel_set_flag_value (session->channel, 111, 1);
      status = 0;
    }
  return status;
}



;; Function switch_media_handle_set_media_flag (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[35] = "switch_media_handle_set_media_flag";

    static const char __PRETTY_FUNCTION__[35] = "switch_media_handle_set_media_flag";
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 1482, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  smh->media_flags[(unsigned int) flag] = 1;
}



;; Function switch_media_handle_set_media_flags (null)
;; enabled by -tree-original

{
  int i;
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_set_media_flags";

    static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_set_media_flags";
    int i;
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 1491, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  i = 0;
  goto <D.38683>;
  <D.38682>:;
  if ((unsigned int) *(flags + (unsigned int) ((unsigned int) i * 4)) != 0)
    {
      smh->media_flags[i] = *(flags + (unsigned int) ((unsigned int) i * 4));
    }
  i++ ;
  <D.38683>:;
  if (i <= 16) goto <D.38682>; else goto <D.38684>;
  <D.38684>:;
}



;; Function switch_media_handle_clear_media_flag (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[37] = "switch_media_handle_clear_media_flag";

    static const char __PRETTY_FUNCTION__[37] = "switch_media_handle_clear_media_flag";
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 1503, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  smh->media_flags[(unsigned int) flag] = 0;
}



;; Function switch_media_handle_test_media_flag (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_test_media_flag";

    static const char __PRETTY_FUNCTION__[36] = "switch_media_handle_test_media_flag";
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 1510, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  return (int32_t) smh->media_flags[(unsigned int) flag];
}



;; Function switch_core_session_media_handle_ready (null)
;; enabled by -tree-original

{
  if (session->media_handle != 0B && (int) session->media_handle->flags & 1)
    {
      return 0;
    }
  return 1;
}



;; Function switch_core_session_get_media_handle (null)
;; enabled by -tree-original

{
  if ((unsigned int) switch_core_session_media_handle_ready (session) == 0)
    {
      return session->media_handle;
    }
  return 0B;
}



;; Function switch_core_session_clear_media_handle (null)
;; enabled by -tree-original

{
  if (session->media_handle == 0B)
    {
      return 1;
    }
  return 0;
}



;; Function switch_core_media_get_mparams (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_get_mparams";

    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_get_mparams";
  if (smh == 0B)
    {
      __assert_fail ((const char *) "smh", (const char *) "src/switch_core_media.c", 1545, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  return smh->mparams;
}



;; Function switch_core_media_prepare_codecs (null)
;; enabled by -tree-original

{
  const char * abs;
  const char * codec_string = 0B;
  const char * ocodec = 0B;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_prepare_codecs";
  void ready = <<< error >>>;
  static const char __func__[33] = "switch_core_media_prepare_codecs";

    static const char __func__[33] = "switch_core_media_prepare_codecs";
    static const char __PRETTY_FUNCTION__[33] = "switch_core_media_prepare_codecs";
    const char * abs;
    const char * codec_string = 0B;
    const char * ocodec = 0B;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 1555, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned int) force == 0 && (switch_channel_test_flag (session->channel, 15) != 0 || switch_channel_test_flag (session->channel, 29) != 0))
    {
      return;
    }
  if ((unsigned int) force != 0)
    {
      smh->mparams->num_codecs = 0;
    }
  if (smh->mparams->num_codecs != 0)
    {
      return;
    }
  smh->payload_space = 0;
  if (smh->session == 0B)
    {
      __assert_fail ((const char *) "smh->session != ((void *)0)", (const char *) "src/switch_core_media.c", 1575, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((abs = switch_channel_get_variable_dup (session->channel, (const char *) "absolute_codec_string", 1, -1)) != 0B)
    {
      codec_string = abs;
      goto ready;
    }
  if ((codec_string = switch_channel_get_variable_dup (session->channel, (const char *) "codec_string", 1, -1)) == 0B)
    {
      codec_string = switch_core_media_get_codec_string (smh->session);
    }
  if (codec_string != 0B && (unsigned char) *codec_string == 61)
    {
      codec_string++ ;
      goto ready;
    }
  if ((ocodec = switch_channel_get_variable_dup (session->channel, (const char *) "originator_codec", 1, -1)) != 0B)
    {
      if (codec_string == 0B || (unsigned int) smh->media_flags[1] != 0)
        {
          codec_string = ocodec;
        }
      else
        {
          if ((codec_string = (const char *) switch_core_session_sprintf (smh->session, (const char *) "%s,%s", ocodec, codec_string)) == 0B)
            {
              codec_string = ocodec;
            }
        }
    }
  ready:;
  if (codec_string != 0B)
    {
      {
        char * tmp_codec_string = switch_core_perform_session_strdup (smh->session, codec_string, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1603);

                char * tmp_codec_string = switch_core_perform_session_strdup (smh->session, codec_string, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1603);
        switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_use_codec_string", codec_string, 1);
        smh->codec_order_last = (int) switch_separate_string (tmp_codec_string, 44, (char * *) &smh->codec_order, 50);
        smh->mparams->num_codecs = switch_loadable_module_get_codecs_sorted ((const struct switch_codec_implementation_t * *) &smh->codecs, 50, (char * *) &smh->codec_order, smh->codec_order_last);
      }
    }
  else
    {
      smh->mparams->num_codecs = switch_loadable_module_get_codecs ((const struct switch_codec_implementation_t * *) &smh->codecs, 50);
    }
}



;; Function switch_core_media_read_frame (null)
;; enabled by -tree-original

{
  struct switch_rtcp_frame_t rtcp_frame;
  struct switch_rtp_engine_t * engine;
  switch_status_t status;
  struct switch_media_handle_t * smh;
  int do_cng = 0;
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_read_frame";
  static const char __func__[29] = "switch_core_media_read_frame";
  void end = <<< error >>>;
  void skip = <<< error >>>;

    static const char __func__[29] = "switch_core_media_read_frame";
    static const char __PRETTY_FUNCTION__[29] = "switch_core_media_read_frame";
    struct switch_rtcp_frame_t rtcp_frame;
    struct switch_rtp_engine_t * engine;
    switch_status_t status;
    struct switch_media_handle_t * smh;
    int do_cng = 0;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 1623, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if ((unsigned int) smh->media_flags[0] == 0)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  engine->read_frame.datalen = 0;
  if (engine->read_codec.implementation == 0B || (unsigned int) switch_core_codec_ready (&engine->read_codec) == 0)
    {
      return 1;
    }
  if (engine->rtp_session == 0B)
    {
      __assert_fail ((const char *) "engine->rtp_session != ((void *)0)", (const char *) "src/switch_core_media.c", 1641, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  engine->read_frame.datalen = 0;
  if (((unsigned int) switch_channel_get_state (session->channel) > 9 || (unsigned char) switch_rtp_ready (engine->rtp_session) == 0) || switch_channel_test_flag (session->channel, 45) != 0)
    {
      return 1;
    }
  if (engine->read_mutex[(unsigned int) type] != 0B && (unsigned int) switch_mutex_trylock (engine->read_mutex[(unsigned int) type]) != 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1650, (const char *) session, 101, (const char *) "%s is already being read for %s\n", switch_channel_get_name (session->channel), (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
      return 10;
    }
  goto <D.38757>;
  <D.38759>:;
  engine->read_frame.flags = 0;
  status = switch_rtp_zerocopy_read_frame (engine->rtp_session, &engine->read_frame, flags);
  if ((unsigned int) status != 0 && (unsigned int) status != 11)
    {
      if ((unsigned int) status == 2)
        {
          if (switch_channel_get_variable_dup (session->channel, (const char *) "execute_on_media_timeout", 1, -1) != 0B)
            {
              *frame = &engine->read_frame;
              (*frame)->flags = (*frame)->flags | 1;
              (*frame)->datalen = engine->read_impl.encoded_bytes_per_packet;
              memset ((*frame)->data, 0, (*frame)->datalen);
              switch_channel_execute_on (session->channel, (const char *) "execute_on_media_timeout");
              status = 0;
              goto end;
            }
          switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1674, 604);
        }
      goto end;
    }
  if ((unsigned char) engine->reset_codec != 0)
    {
      {
        const char * val;
        int rtp_timeout_sec = 0;
        int rtp_hold_timeout_sec = 0;

                const char * val;
                int rtp_timeout_sec = 0;
                int rtp_hold_timeout_sec = 0;
        engine->reset_codec = 0;
        if ((unsigned char) switch_rtp_ready (engine->rtp_session) != 0)
          {
            if ((unsigned int) type == 1)
              {
                switch_core_media_set_video_codec (session, 1);
              }
            else
              {
                if ((unsigned int) switch_core_media_set_codec (session, 1, 0) != 0)
                  {
                    *frame = 0B;
                    status = 9;
                    goto end;
                  }
              }
            if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_timeout_sec", 1, -1)) != 0B)
              {
                {
                  int v = atoi (val);

                                    int v = atoi (val);
                  if (v >= 0)
                    {
                      rtp_timeout_sec = v;
                    }
                }
              }
            if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_hold_timeout_sec", 1, -1)) != 0B)
              {
                {
                  int v = atoi (val);

                                    int v = atoi (val);
                  if (v >= 0)
                    {
                      rtp_hold_timeout_sec = v;
                    }
                }
              }
            if (rtp_timeout_sec != 0)
              {
                engine->max_missed_packets = (engine->read_impl.samples_per_second * (uint32_t) rtp_timeout_sec) / engine->read_impl.samples_per_packet;
                switch_rtp_set_max_missed_packets (engine->rtp_session, engine->max_missed_packets);
                if (rtp_hold_timeout_sec == 0)
                  {
                    rtp_hold_timeout_sec = rtp_timeout_sec * 10;
                  }
              }
            if (rtp_hold_timeout_sec != 0)
              {
                engine->max_missed_hold_packets = (engine->read_impl.samples_per_second * (uint32_t) rtp_hold_timeout_sec) / engine->read_impl.samples_per_packet;
              }
          }
        engine->check_frames = 0;
        engine->last_ts = 0;
        do_cng = 1;
      }
    }
  if (do_cng != 0)
    {
      *frame = &engine->read_frame;
      (*frame)->flags = (*frame)->flags | 1;
      (*frame)->datalen = engine->read_impl.encoded_bytes_per_packet;
      memset ((*frame)->data, 0, (*frame)->datalen);
      status = 0;
      goto end;
    }
  if ((unsigned int) switch_rtcp_zerocopy_read_frame (engine->rtp_session, &rtcp_frame) == 0)
    {
      {
        struct switch_event_t * event;

                struct switch_event_t * event;
        if ((unsigned int) switch_event_create_subclass_detailed ((const char *) "src/switch_core_media.c", (const char *) &__func__, 1747, &event, 71, 0B) == 0)
          {
            {
              char value[30];
              char header[50];
              int i;
              char * uuid = switch_core_session_get_uuid (session);

                            char value[30];
                            char header[50];
                            int i;
                            char * uuid = switch_core_session_get_uuid (session);
              if (uuid != 0B)
                {
                  switch_event_add_header_string (event, 1, (const char *) "Unique-ID", (const char *) switch_core_session_get_uuid (session));
                }
              snprintf ((char *) &value, 30, (const char * restrict) "%.8x", rtcp_frame.ssrc);
              switch_event_add_header_string (event, 1, (const char *) "SSRC", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.ntp_msw);
              switch_event_add_header_string (event, 1, (const char *) "NTP-Most-Significant-Word", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.ntp_lsw);
              switch_event_add_header_string (event, 1, (const char *) "NTP-Least-Significant-Word", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.timestamp);
              switch_event_add_header_string (event, 1, (const char *) "RTP-Timestamp", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.packet_count);
              switch_event_add_header_string (event, 1, (const char *) "Sender-Packet-Count", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.octect_count);
              switch_event_add_header_string (event, 1, (const char *) "Octect-Packet-Count", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%d", engine->read_frame.timestamp);
              switch_event_add_header_string (event, 1, (const char *) "Last-RTP-Timestamp", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", engine->read_frame.rate);
              switch_event_add_header_string (event, 1, (const char *) "RTP-Rate", (const char *) &value);
              snprintf ((char *) &value, 30, (const char * restrict) "%lld", switch_time_now ());
              switch_event_add_header_string (event, 1, (const char *) "Capture-Time", (const char *) &value);
              i = 0;
              goto <D.38746>;
              <D.38745>:;
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-SSRC", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%.8x", rtcp_frame.reports[i].ssrc);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-Fraction", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", (int) rtcp_frame.reports[i].fraction);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-Lost", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.reports[i].lost);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-Highest-Sequence-Number-Received", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.reports[i].highest_sequence_number_received);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-Jitter", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.reports[i].jitter);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-LSR", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.reports[i].lsr);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              snprintf ((char *) &header, 50, (const char * restrict) "Source%u-DLSR", i);
              snprintf ((char *) &value, 30, (const char * restrict) "%u", rtcp_frame.reports[i].dlsr);
              switch_event_add_header_string (event, 1, (const char *) &header, (const char *) &value);
              i++ ;
              <D.38746>:;
              if ((int) rtcp_frame.report_count > i) goto <D.38745>; else goto <D.38747>;
              <D.38747>:;
              switch_event_fire_detailed ((const char *) "src/switch_core_media.c", (const char *) &__func__, 1809, &event, 0B);
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1810, (const char *) session, 110, (const char *) "Dispatched RTCP event\n");
            }
          }
      }
    }
  if ((engine->read_frame.flags & 32) != 0)
    {
      *frame = &engine->read_frame;
      status = 0;
      goto end;
    }
  if (switch_rtp_has_dtmf (engine->rtp_session) != 0)
    {
      {
        struct switch_dtmf_t dtmf = {.digit=0};

                struct switch_dtmf_t dtmf = {.digit=0};
        switch_rtp_dequeue_dtmf (engine->rtp_session, &dtmf);
        switch_channel_queue_dtmf (session->channel, (const struct switch_dtmf_t *) &dtmf);
      }
    }
  if (engine->read_frame.datalen != 0)
    {
      {
        uint32_t bytes = 0;
        int frames = 1;

                uint32_t bytes = 0;
                int frames = 1;
        if ((engine->read_frame.flags & 1) == 0)
          {
            if (engine->read_codec.implementation == 0B || (unsigned int) switch_core_codec_ready (&engine->read_codec) == 0)
              {
                *frame = 0B;
                status = 9;
                goto end;
              }
            if ((unsigned int) smh->media_flags[2] != 0 && engine->check_frames <= 49)
              {
                engine->check_frames++ ;
                if (engine->read_impl.encoded_bytes_per_packet == 0)
                  {
                    engine->check_frames = 50;
                    goto skip;
                  }
                if ((unsigned int) smh->media_flags[2] != 0 && engine->read_frame.datalen % 10 == 0)
                  {
                    if (engine->last_ts != 0 && engine->read_frame.datalen != engine->read_impl.encoded_bytes_per_packet)
                      {
                        {
                          uint32_t codec_ms = (uint32_t) (engine->read_frame.timestamp - engine->last_ts) / (engine->read_impl.samples_per_second / 1000);

                                                    uint32_t codec_ms = (uint32_t) (engine->read_frame.timestamp - engine->last_ts) / (engine->read_impl.samples_per_second / 1000);
                          if (codec_ms % 10 != 0 || engine->read_impl.samples_per_packet * 10 < codec_ms)
                            {
                              engine->last_ts = 0;
                              goto skip;
                            }
                          if (engine->last_codec_ms != 0 && engine->last_codec_ms == codec_ms)
                            {
                              engine->mismatch_count++ ;
                            }
                          engine->last_codec_ms = codec_ms;
                          if (engine->mismatch_count > 5)
                            {
                              if (engine->cur_payload_map->codec_ms != codec_ms)
                                {
                                  if (codec_ms > 120)
                                    {
                                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1871, (const char *) session, 4, (const char *) "Your phone is trying to send timestamps that suggest an increment of %dms per packet\nThat seems hard to believe so I am going to go on ahead and um ignore that, mmkay?\n", (int) codec_ms);
                                      engine->check_frames = 50;
                                      goto skip;
                                    }
                                  engine->read_frame.datalen = 0;
                                  if (engine->cur_payload_map->codec_ms != codec_ms)
                                    {
                                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1882, (const char *) session, 4, (const char *) "Asynchronous PTIME not supported, changing our end from %d to %d\n", (int) engine->cur_payload_map->codec_ms, (int) codec_ms);
                                      switch_channel_set_variable_printf (session->channel, (const char *) "rtp_h_X-Broken-PTIME", (const char *) "Adv=%d;Sent=%d", (int) engine->cur_payload_map->codec_ms, (int) codec_ms);
                                      engine->cur_payload_map->codec_ms = codec_ms;
                                      engine->reset_codec = 2;
                                    }
                                }
                            }
                        }
                      }
                    else
                      {
                        engine->mismatch_count = 0;
                      }
                    engine->last_ts = engine->read_frame.timestamp;
                  }
                else
                  {
                    engine->mismatch_count = 0;
                    engine->last_ts = 0;
                  }
              }
            if ((((((((unsigned char) engine->reset_codec == 0 && (unsigned char) engine->codec_negotiated != 0) && ((unsigned char) smh->mparams->cng_pt == 0 || (unsigned char) engine->read_frame.payload != (unsigned char) smh->mparams->cng_pt)) && ((unsigned char) smh->mparams->recv_te == 0 || (unsigned char) engine->read_frame.payload != (unsigned char) smh->mparams->recv_te)) && ((unsigned char) smh->mparams->te == 0 || (unsigned char) engine->read_frame.payload != (unsigned char) smh->mparams->te)) && (unsigned char) engine->read_frame.payload != (unsigned char) engine->cur_payload_map->recv_pt) && (unsigned char) engine->read_frame.payload != (unsigned char) engine->cur_payload_map->agreed_pt) && (unsigned char) engine->read_frame.payload != (unsigned char) engine->cur_payload_map->pt)
              {
                {
                  struct payload_map_t * pmap;

                                    struct payload_map_t * pmap;
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1926, (const char *) session, 7, (const char *) "alternate payload received (received %d, expecting %d)\n", (int) engine->read_frame.payload, (int) engine->cur_payload_map->agreed_pt);
                  switch_mutex_lock (smh->sdp_mutex);
                  pmap = engine->payload_map;
                  goto <D.38756>;
                  <D.38755>:;
                  if ((unsigned char) engine->read_frame.payload == (unsigned char) pmap->recv_pt && (unsigned char) pmap->negotiated != 0)
                    {
                      engine->cur_payload_map = pmap;
                      engine->cur_payload_map->current = 1;
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1937, (const char *) session, 4, (const char *) "Changing current codec to %s (payload type %d).\n", pmap->iananame, (int) pmap->pt);
                      engine->reset_codec = 1;
                      goto <D.38754>;
                    }
                  pmap = (struct payload_map_t *) pmap->next;
                  <D.38756>:;
                  if (pmap != 0B) goto <D.38755>; else goto <D.38754>;
                  <D.38754>:;
                  switch_mutex_unlock (smh->sdp_mutex);
                  if ((unsigned char) engine->reset_codec == 0)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 1949, (const char *) session, 4, (const char *) "Could not change to payload type %d, ignoring...\n", (int) engine->read_frame.payload);
                    }
                }
              }
            skip:;
            if ((bytes = engine->read_impl.encoded_bytes_per_packet) != 0)
              {
                frames = (int) (engine->read_frame.datalen / bytes);
              }
            engine->read_frame.samples = engine->read_impl.samples_per_packet * (uint32_t) frames;
            if (engine->read_frame.datalen == 0)
              {
                // predicted unlikely by continue predictor.;
                goto <D.38757>;
              }
          }
        goto <D.38758>;
      }
    }
  <D.38757>:;
  if ((unsigned int) smh->media_flags[0] != 0 && engine->read_frame.datalen == 0) goto <D.38759>; else goto <D.38758>;
  <D.38758>:;
  if (engine->read_frame.datalen == 0)
    {
      *frame = 0B;
    }
  *frame = &engine->read_frame;
  status = 0;
  end:;
  if (engine->read_mutex[(unsigned int) type] != 0B)
    {
      switch_mutex_unlock (engine->read_mutex[(unsigned int) type]);
    }
  return status;
}



;; Function switch_core_media_write_frame (null)
;; enabled by -tree-original

{
  switch_status_t status = 0;
  int bytes = 0;
  int samples = 0;
  int frames = 0;
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_write_frame";

    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_write_frame";
    switch_status_t status = 0;
    int bytes = 0;
    int samples = 0;
    int frames = 0;
    struct switch_rtp_engine_t * engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 1996, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if ((unsigned int) smh->media_flags[0] == 0)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  goto <D.38775>;
  <D.38774>:;
  if (switch_channel_test_ready (session->channel, 1, 0) != 0)
    {
      switch_sleep (10000);
    }
  else
    {
      return 9;
    }
  <D.38775>:;
  if (engine->read_codec.implementation == 0B || (unsigned char) switch_rtp_ready (engine->rtp_session) == 0) goto <D.38774>; else goto <D.38776>;
  <D.38776>:;
  if (engine->read_codec.implementation == 0B || (unsigned int) switch_core_codec_ready (&engine->read_codec) == 0)
    {
      return 9;
    }
  if (engine->read_codec.implementation == 0B || (unsigned int) switch_core_codec_ready (&engine->read_codec) == 0)
    {
      return 1;
    }
  if ((BIT_FIELD_REF <*frame, 32, 480> & 33) == 0)
    {
      if (engine->read_impl.encoded_bytes_per_packet != 0)
        {
          bytes = (int) engine->read_impl.encoded_bytes_per_packet;
          frames = (int) frame->datalen / bytes;
        }
      else
        {
          frames = 1;
        }
      samples = (int) (engine->read_impl.samples_per_packet * (uint32_t) frames);
    }
  engine->timestamp_send = engine->timestamp_send + (uint32_t) samples;
  if (switch_rtp_write_frame (engine->rtp_session, frame) < 0)
    {
      status = 1;
    }
  return status;
}



;; Function switch_core_media_copy_t38_options (null)
;; enabled by -tree-original

{
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  struct switch_t38_options_t * local_t38_options = (struct switch_t38_options_t *) switch_channel_get_private (channel, (const char *) "t38_options");
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_copy_t38_options";
  static const char __func__[35] = "switch_core_media_copy_t38_options";

    static const char __func__[35] = "switch_core_media_copy_t38_options";
    static const char __PRETTY_FUNCTION__[35] = "switch_core_media_copy_t38_options";
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    struct switch_t38_options_t * local_t38_options = (struct switch_t38_options_t *) switch_channel_get_private (channel, (const char *) "t38_options");
  if (t38_options == 0B)
    {
      __assert_fail ((const char *) "t38_options", (const char *) "src/switch_core_media.c", 2052, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if (local_t38_options == 0B)
    {
      local_t38_options = (struct switch_t38_options_t *) switch_core_perform_session_alloc (session, 60, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2055);
    }
  local_t38_options->T38MaxBitRate = t38_options->T38MaxBitRate;
  local_t38_options->T38FaxFillBitRemoval = t38_options->T38FaxFillBitRemoval;
  local_t38_options->T38FaxTranscodingMMR = t38_options->T38FaxTranscodingMMR;
  local_t38_options->T38FaxTranscodingJBIG = t38_options->T38FaxTranscodingJBIG;
  local_t38_options->T38FaxRateManagement = (const char *) switch_core_perform_session_strdup (session, t38_options->T38FaxRateManagement, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2062);
  local_t38_options->T38FaxMaxBuffer = t38_options->T38FaxMaxBuffer;
  local_t38_options->T38FaxMaxDatagram = t38_options->T38FaxMaxDatagram;
  local_t38_options->T38FaxUdpEC = (const char *) switch_core_perform_session_strdup (session, t38_options->T38FaxUdpEC, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2065);
  local_t38_options->T38VendorInfo = (const char *) switch_core_perform_session_strdup (session, t38_options->T38VendorInfo, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2066);
  local_t38_options->remote_ip = (const char *) switch_core_perform_session_strdup (session, t38_options->remote_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2067);
  local_t38_options->remote_port = t38_options->remote_port;
  switch_channel_set_private (channel, (const char *) "t38_options", (const void *) local_t38_options);
}



;; Function switch_core_media_get_offered_pt (null)
;; enabled by -tree-original

{
  int i = 0;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_get_offered_pt";

    static const char __PRETTY_FUNCTION__[33] = "switch_core_media_get_offered_pt";
    int i = 0;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2081, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B || mimp == 0B)
    {
      return 1;
    }
  i = 0;
  goto <D.38795>;
  <D.38794>:;
  {
    const struct switch_codec_implementation_t * imp = smh->codecs[i];

        const struct switch_codec_implementation_t * imp = smh->codecs[i];
    if (strcasecmp ((const char *) imp->iananame, (const char *) mimp->iananame) == 0 && (unsigned int) imp->actual_samples_per_second == (unsigned int) mimp->actual_samples_per_second)
      {
        *pt = smh->ianacodes[i];
        return 0;
      }
  }
  i++ ;
  <D.38795>:;
  if (smh->mparams->num_codecs > i) goto <D.38794>; else goto <D.38796>;
  <D.38796>:;
  return 1;
}



;; Function switch_core_media_set_video_codec (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_set_video_codec";
  static const char __func__[34] = "switch_core_media_set_video_codec";

    static const char __func__[34] = "switch_core_media_set_video_codec";
    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_set_video_codec";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * v_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2109, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if ((unsigned char) v_engine->codec_negotiated == 0)
    {
      return 1;
    }
  if (v_engine->read_codec.implementation != 0B && (unsigned int) switch_core_codec_ready (&v_engine->read_codec) != 0)
    {
      if (force == 0)
        {
          return 0;
        }
      if (strcasecmp ((const char *) v_engine->read_codec.implementation->iananame, (const char *) v_engine->cur_payload_map->rm_encoding) != 0 || (long unsigned int) v_engine->read_codec.implementation->samples_per_second != v_engine->cur_payload_map->rm_rate)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2128, (const char *) session, 7, (const char *) "Changing Codec from %s to %s\n", v_engine->read_codec.implementation->iananame, v_engine->cur_payload_map->rm_encoding);
          switch_core_codec_destroy (&v_engine->read_codec);
          switch_core_codec_destroy (&v_engine->write_codec);
        }
      else
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2133, (const char *) session, 7, (const char *) "Already using %s\n", v_engine->read_codec.implementation->iananame);
          return 0;
        }
    }
  if ((unsigned int) switch_core_codec_init_with_bitrate (&v_engine->read_codec, (const char *) v_engine->cur_payload_map->rm_encoding, (const char *) v_engine->cur_payload_map->rm_fmtp, (uint32_t) v_engine->cur_payload_map->rm_rate, 0, 1, 0, 3, 0B, switch_core_session_get_pool (session)) != 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2149, (const char *) session, 3, (const char *) "Can\'t load codec?\n");
      return 1;
    }
  else
    {
      if ((unsigned int) switch_core_codec_init_with_bitrate (&v_engine->write_codec, (const char *) v_engine->cur_payload_map->rm_encoding, (const char *) v_engine->cur_payload_map->rm_fmtp, (uint32_t) v_engine->cur_payload_map->rm_rate, 0, 1, 0, 3, 0B, switch_core_session_get_pool (session)) != 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2160, (const char *) session, 3, (const char *) "Can\'t load codec?\n");
          return 1;
        }
      else
        {
          v_engine->read_frame.rate = (uint32_t) v_engine->cur_payload_map->rm_rate;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2164, (const char *) session, 7, (const char *) "Set VIDEO Codec %s %s/%ld %d ms\n", switch_channel_get_name (session->channel), v_engine->cur_payload_map->rm_encoding, v_engine->cur_payload_map->rm_rate, v_engine->cur_payload_map->codec_ms);
          v_engine->read_frame.codec = &v_engine->read_codec;
          v_engine->write_codec.fmtp_out = switch_core_perform_session_strdup (session, (const char *) v_engine->write_codec.fmtp_out, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2169);
          v_engine->write_codec.agreed_pt = v_engine->cur_payload_map->agreed_pt;
          v_engine->read_codec.agreed_pt = v_engine->cur_payload_map->agreed_pt;
          switch_core_session_set_video_read_codec (session, &v_engine->read_codec);
          switch_core_session_set_video_write_codec (session, &v_engine->write_codec);
          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_last_video_codec_string", (const char *) "%s@%dh", v_engine->cur_payload_map->rm_encoding, v_engine->cur_payload_map->rm_rate);
          if ((unsigned char) switch_rtp_ready (v_engine->rtp_session) != 0)
            {
              {
                struct switch_core_session_message_t msg = {.from=0B};

                                struct switch_core_session_message_t msg = {.from=0B};
                msg.from = (char *) "src/switch_core_media.c";
                msg.message_id = 17;
                switch_rtp_set_default_payload (v_engine->rtp_session, v_engine->cur_payload_map->agreed_pt);
                switch_core_session_perform_receive_message (session, &msg, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2191);
              }
            }
          switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_use_video_codec_name", (const char *) v_engine->cur_payload_map->rm_encoding, 1);
          switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_use_video_codec_fmtp", (const char *) v_engine->cur_payload_map->rm_fmtp, 1);
          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_video_codec_rate", (const char *) "%d", v_engine->cur_payload_map->rm_rate);
          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_video_codec_ptime", (const char *) "%d", 0);
        }
    }
  return 0;
}



;; Function switch_core_media_set_codec (null)
;; enabled by -tree-original

{
  switch_status_t status = 0;
  int resetting = 0;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_set_codec";
  static const char __func__[28] = "switch_core_media_set_codec";
  void end = <<< error >>>;

    static const char __func__[28] = "switch_core_media_set_codec";
    static const char __PRETTY_FUNCTION__[28] = "switch_core_media_set_codec";
    switch_status_t status = 0;
    int resetting = 0;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2215, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  if (a_engine->cur_payload_map->iananame == 0B)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2223, (const char *) session, 7, (const char *) "No audio codec available\n");
      status = 1;
      goto end;
    }
  if ((unsigned int) switch_core_codec_ready (&a_engine->read_codec) != 0)
    {
      if (force == 0)
        {
          status = 0;
          goto end;
        }
      if ((strcasecmp ((const char *) a_engine->read_impl.iananame, (const char *) a_engine->cur_payload_map->iananame) != 0 || (unsigned int) a_engine->read_impl.microseconds_per_packet / 1000 != (unsigned int) a_engine->cur_payload_map->codec_ms) || (long unsigned int) a_engine->read_impl.samples_per_second != a_engine->cur_payload_map->rm_rate)
        {
          if (session->read_resampler != 0B)
            {
              switch_mutex_lock (session->resample_mutex);
              switch_resample_destroy (&session->read_resampler);
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2238, (const char *) session, 5, (const char *) "Deactivating read resampler\n");
              switch_mutex_unlock (session->resample_mutex);
            }
          if (session->write_resampler != 0B)
            {
              switch_mutex_lock (session->resample_mutex);
              switch_resample_destroy (&session->write_resampler);
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2245, (const char *) session, 5, (const char *) "Deactivating write resampler\n");
              switch_mutex_unlock (session->resample_mutex);
            }
          switch_core_session_reset (session, 0, 0);
          switch_channel_perform_audio_sync (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2250);
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2252, (const char *) session, 7, (const char *) "Changing Codec from %s@%dms@%dhz to %s@%dms@%luhz\n", a_engine->read_impl.iananame, a_engine->read_impl.microseconds_per_packet / 1000, a_engine->read_impl.samples_per_second, a_engine->cur_payload_map->iananame, a_engine->cur_payload_map->codec_ms, a_engine->cur_payload_map->rm_rate);
          switch_sleep ((switch_interval_time_t) a_engine->read_impl.microseconds_per_packet);
          switch_core_session_lock_codec_write (session);
          switch_core_session_lock_codec_read (session);
          resetting = 1;
          switch_sleep ((switch_interval_time_t) a_engine->read_impl.microseconds_per_packet);
          switch_core_codec_destroy (&a_engine->read_codec);
          switch_core_codec_destroy (&a_engine->write_codec);
          switch_channel_perform_audio_sync (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2269);
        }
      else
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2271, (const char *) session, 7, (const char *) "Already using %s\n", a_engine->read_impl.iananame);
          status = 0;
          goto end;
        }
    }
  if ((unsigned int) switch_core_codec_init_with_bitrate (&a_engine->read_codec, (const char *) a_engine->cur_payload_map->iananame, (const char *) a_engine->cur_payload_map->rm_fmtp, (uint32_t) a_engine->cur_payload_map->rm_rate, (int) a_engine->cur_payload_map->codec_ms, a_engine->cur_payload_map->channels, a_engine->cur_payload_map->bitrate, codec_flags | 3, 0B, switch_core_session_get_pool (session)) != 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2285, (const char *) session, 3, (const char *) "Can\'t load codec?\n");
      switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2286, 88);
      status = 1;
      goto end;
    }
  a_engine->read_codec.session = session;
  if ((unsigned int) switch_core_codec_init_with_bitrate (&a_engine->write_codec, (const char *) a_engine->cur_payload_map->iananame, (const char *) a_engine->cur_payload_map->rm_fmtp, (uint32_t) a_engine->cur_payload_map->rm_rate, (int) a_engine->cur_payload_map->codec_ms, a_engine->cur_payload_map->channels, a_engine->cur_payload_map->bitrate, codec_flags | 3, 0B, switch_core_session_get_pool (session)) != 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2302, (const char *) session, 3, (const char *) "Can\'t load codec?\n");
      switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2303, 88);
      status = 1;
      goto end;
    }
  a_engine->write_codec.session = session;
  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_use_codec_name", (const char *) a_engine->cur_payload_map->iananame, 1);
  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_use_codec_fmtp", (const char *) a_engine->cur_payload_map->rm_fmtp, 1);
  switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_codec_rate", (const char *) "%d", a_engine->cur_payload_map->rm_rate);
  switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_codec_ptime", (const char *) "%d", a_engine->cur_payload_map->codec_ms);
  switch_channel_set_variable_printf (session->channel, (const char *) "rtp_last_audio_codec_string", (const char *) "%s@%dh@%di", a_engine->cur_payload_map->iananame, a_engine->cur_payload_map->rm_rate, a_engine->cur_payload_map->codec_ms);
  if (a_engine->read_codec.implementation == 0B)
    {
      __assert_fail ((const char *) "a_engine->read_codec.implementation", (const char *) "src/switch_core_media.c", 2316, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if (a_engine->write_codec.implementation == 0B)
    {
      __assert_fail ((const char *) "a_engine->write_codec.implementation", (const char *) "src/switch_core_media.c", 2317, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  a_engine->read_impl = *a_engine->read_codec.implementation;
  a_engine->write_impl = *a_engine->write_codec.implementation;
  switch_core_session_set_read_impl (session, a_engine->read_codec.implementation);
  switch_core_session_set_write_impl (session, a_engine->write_codec.implementation);
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      if (a_engine->read_codec.implementation == 0B)
        {
          __assert_fail ((const char *) "a_engine->read_codec.implementation", (const char *) "src/switch_core_media.c", 2326, (const char *) &__PRETTY_FUNCTION__);
        }
      else
        {
          (void) 0;
        }
      if ((unsigned int) switch_rtp_change_interval (a_engine->rtp_session, (uint32_t) a_engine->read_impl.microseconds_per_packet, a_engine->read_impl.samples_per_packet) != 0)
        {
          switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2331, 27);
          status = 1;
          goto end;
        }
    }
  a_engine->read_frame.rate = (uint32_t) a_engine->cur_payload_map->rm_rate;
  if ((unsigned int) switch_core_codec_ready (&a_engine->read_codec) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2339, (const char *) session, 3, (const char *) "Can\'t load codec?\n");
      status = 1;
      goto end;
    }
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2343, (const char *) session, 7, (const char *) "Set Codec %s %s/%ld %d ms %d samples %d bits\n", switch_channel_get_name (session->channel), a_engine->cur_payload_map->iananame, a_engine->cur_payload_map->rm_rate, a_engine->cur_payload_map->codec_ms, a_engine->read_impl.samples_per_packet, a_engine->read_impl.bits_per_second);
  a_engine->read_frame.codec = &a_engine->read_codec;
  a_engine->write_codec.agreed_pt = a_engine->cur_payload_map->agreed_pt;
  a_engine->read_codec.agreed_pt = a_engine->cur_payload_map->agreed_pt;
  if (force != 2)
    {
      switch_core_session_set_real_read_codec (session, &a_engine->read_codec);
      switch_core_session_set_write_codec (session, &a_engine->write_codec);
    }
  a_engine->cur_payload_map->fmtp_out = switch_core_perform_session_strdup (session, (const char *) a_engine->write_codec.fmtp_out, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2357);
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      switch_rtp_set_default_payload (a_engine->rtp_session, a_engine->cur_payload_map->pt);
    }
  end:;
  if (resetting != 0)
    {
      switch_core_session_unlock_codec_write (session);
      switch_core_session_unlock_codec_read (session);
    }
  return status;
}



;; Function switch_core_media_add_ice_acl (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_add_ice_acl";
  static const char __func__[30] = "switch_core_media_add_ice_acl";

    static const char __func__[30] = "switch_core_media_add_ice_acl";
    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_add_ice_acl";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2379, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  if (engine->cand_acl_count <= 24)
    {
      engine->cand_acl[engine->cand_acl_count++ ] = switch_core_perform_session_strdup (session, acl_name, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2388);
      return 0;
    }
  return 1;
}



;; Function switch_core_media_check_video_codecs (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_check_video_codecs";

    static const char __PRETTY_FUNCTION__[37] = "switch_core_media_check_video_codecs";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2400, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if (smh->mparams->num_codecs != 0 && switch_channel_test_flag (session->channel, 98) == 0)
    {
      {
        int i;

                int i;
        smh->video_count = 0;
        i = 0;
        goto <D.38835>;
        <D.38834>:;
        if ((unsigned int) smh->codecs[i]->codec_type == 1)
          {
            if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 114) != 0)
              {
                // predicted unlikely by continue predictor.;
                goto <D.38833>;
              }
            smh->video_count++ ;
          }
        <D.38833>:;
        i++ ;
        <D.38835>:;
        if (smh->mparams->num_codecs > i) goto <D.38834>; else goto <D.38836>;
        <D.38836>:;
        if (smh->video_count != 0)
          {
            switch_channel_set_flag_value (session->channel, 98, 1);
          }
      }
    }
}



;; Function generate_local_fingerprint (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);

    struct switch_rtp_engine_t * engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  if (engine->local_dtls_fingerprint.len == 0)
    {
      if (engine->remote_dtls_fingerprint.type != 0B)
        {
          engine->local_dtls_fingerprint.type = engine->remote_dtls_fingerprint.type;
        }
      else
        {
          engine->local_dtls_fingerprint.type = (char *) "sha-256";
        }
      switch_core_cert_gen_fingerprint ((const char *) "dtls-srtp", &engine->local_dtls_fingerprint);
    }
}



;; Function dtls_ok (null)
;; enabled by -tree-original

{
  return (int) switch_channel_test_flag (session->channel, 111);
}



;; Function switch_ice_direction (null)
;; enabled by -tree-original

{
  switch_call_direction_t r = switch_channel_direction (session->channel);

    switch_call_direction_t r = switch_channel_direction (session->channel);
  if (switch_channel_test_flag (session->channel, 112) != 0)
    {
      r = (unsigned int) r == 0;
    }
  if ((switch_channel_test_flag (session->channel, 103) != 0 || switch_channel_test_flag (session->channel, 84) != 0) && switch_channel_test_flag (session->channel, 106) != 0)
    {
      r = 1;
    }
  return r;
}



;; Function check_ice (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  struct sdp_attribute_t * attr;
  int i = 0;
  int got_rtcp_mux = 0;
  const char * val;
  static const char __func__[10] = "check_ice";

    static const char __func__[10] = "check_ice";
    struct switch_rtp_engine_t * engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
    struct sdp_attribute_t * attr;
    int i = 0;
    int got_rtcp_mux = 0;
    const char * val;
  if ((engine->ice_in.chosen[0] != 0 && engine->ice_in.chosen[1] != 0) && switch_channel_test_flag (smh->session->channel, 103) == 0)
    {
      return;
    }
  engine->ice_in.chosen[0] = 0;
  engine->ice_in.chosen[1] = 0;
  engine->ice_in.cand_idx = 0;
  if (m != 0B)
    {
      attr = m->m_attributes;
    }
  else
    {
      attr = sdp->sdp_attributes;
    }
  goto <D.38878>;
  <D.38877>:;
  {
    char * data;
    char * fields[15];
    int argc = 0;
    int j = 0;
    int cid = 0;

        char * data;
        char * fields[15];
        int argc = 0;
        int j = 0;
        int cid = 0;
    if (_zstr (attr->a_name) != 0)
      {
        // predicted unlikely by continue predictor.;
        goto <D.38865>;
      }
    if (strcasecmp (attr->a_name, (const char *) "ice-ufrag") == 0)
      {
        engine->ice_in.ufrag = switch_core_perform_session_strdup (smh->session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2503);
      }
    else
      {
        if (strcasecmp (attr->a_name, (const char *) "ice-pwd") == 0)
          {
            engine->ice_in.pwd = switch_core_perform_session_strdup (smh->session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2505);
          }
        else
          {
            if (strcasecmp (attr->a_name, (const char *) "ice-options") == 0)
              {
                engine->ice_in.options = switch_core_perform_session_strdup (smh->session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2507);
              }
            else
              {
                if (((switch_rtp_has_dtls () != 0 && dtls_ok (smh->session) != 0) && strcasecmp (attr->a_name, (const char *) "fingerprint") == 0) && _zstr (attr->a_value) == 0)
                  {
                    {
                      char * p;

                                            char * p;
                      engine->remote_dtls_fingerprint.type = switch_core_perform_session_strdup (smh->session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2512);
                      if ((p = __builtin_strchr ((const char *) engine->remote_dtls_fingerprint.type, 32)) != 0B)
                        {
                          *p++  = 0;
                          switch_copy_string ((char *) &engine->local_dtls_fingerprint.str, (const char *) p, 192);
                        }
                      generate_local_fingerprint (smh, type);
                      switch_channel_set_flag_value (smh->session->channel, 109, 1);
                    }
                  }
                else
                  {
                    if ((engine->remote_ssrc == 0 && strcasecmp (attr->a_name, (const char *) "ssrc") == 0) && attr->a_value != 0B)
                      {
                        engine->remote_ssrc = (unsigned int) atol (attr->a_value);
                        if (engine->rtp_session != 0B && engine->remote_ssrc != 0)
                          {
                            switch_rtp_set_remote_ssrc (engine->rtp_session, engine->remote_ssrc);
                          }
                      }
                    else
                      {
                        if (strcasecmp (attr->a_name, (const char *) "rtcp-mux") == 0)
                          {
                            engine->rtcp_mux = 1;
                            engine->remote_rtcp_port = engine->cur_payload_map->remote_sdp_port;
                            got_rtcp_mux++ ;
                          }
                        else
                          {
                            if (strcasecmp (attr->a_name, (const char *) "candidate") == 0)
                              {
                                switch_channel_set_flag_value (smh->session->channel, 108, 1);
                                if (engine->cand_acl_count == 0)
                                  {
                                    engine->cand_acl[engine->cand_acl_count++ ] = (char *) "wan.auto";
                                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2548, (const char *) smh->session, 4, (const char *) "NO candidate ACL defined, Defaulting to wan.auto\n");
                                  }
                                if (switch_stristr ((const char *) " udp ", attr->a_value) == 0B)
                                  {
                                    // predicted unlikely by continue predictor.;
                                    goto <D.38865>;
                                  }
                                data = switch_core_perform_session_strdup (smh->session, attr->a_value, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2556);
                                argc = (int) switch_separate_string (data, 32, (char * *) &fields, 15);
                                if (argc <= 4 || engine->ice_in.cand_idx > 48)
                                  {
                                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2561, (const char *) smh->session, 4, (const char *) "Invalid data\n");
                                    // predicted unlikely by continue predictor.;
                                    goto <D.38865>;
                                  }
                                cid = atoi ((const char *) fields[1]) + -1;
                                i = 0;
                                goto <D.38869>;
                                <D.38868>:;
                                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2569, (const char *) smh->session, 101, (const char *) "CAND %d [%s]\n", i, fields[i]);
                                i++ ;
                                <D.38869>:;
                                if (i < argc) goto <D.38868>; else goto <D.38870>;
                                <D.38870>:;
                                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2572, (const char *) smh->session, 7, (const char *) "Checking Candidate cid: %d proto: %s type: %s addr: %s:%s\n", cid + 1, fields[2], fields[7], fields[4], fields[5]);
                                engine->ice_in.cand_idx++ ;
                                i = 0;
                                goto <D.38876>;
                                <D.38875>:;
                                if (engine->ice_in.chosen[cid] == 0 && (unsigned int) switch_check_network_list_ip_token ((const char *) fields[4], (const char *) engine->cand_acl[i], 0B) != 0)
                                  {
                                    engine->ice_in.chosen[cid] = engine->ice_in.cand_idx;
                                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2581, (const char *) smh->session, 5, (const char *) "Choose %s Candidate cid: %d proto: %s type: %s addr: %s:%s\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", cid + 1, fields[2], fields[7], fields[4], fields[5]);
                                  }
                                else
                                  {
                                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2586, (const char *) smh->session, 5, (const char *) "Save %s Candidate cid: %d proto: %s type: %s addr: %s:%s\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", cid + 1, fields[2], fields[7], fields[4], fields[5]);
                                  }
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].foundation = switch_core_perform_session_strdup (smh->session, (const char *) fields[0], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2592);
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].component_id = atoi ((const char *) fields[1]);
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].transport = switch_core_perform_session_strdup (smh->session, (const char *) fields[2], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2594);
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].priority = (uint32_t) atol ((const char *) fields[3]);
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].con_addr = switch_core_perform_session_strdup (smh->session, (const char *) fields[4], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2596);
                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].con_port = (short unsigned int) atoi ((const char *) fields[5]);
                                j = 6;
                                goto <D.38872>;
                                <D.38871>:;
                                if (strcasecmp ((const char *) fields[j], (const char *) "typ") == 0)
                                  {
                                    engine->ice_in.cands[engine->ice_in.cand_idx][cid].cand_type = switch_core_perform_session_strdup (smh->session, (const char *) fields[j + 1], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2604);
                                  }
                                else
                                  {
                                    if (strcasecmp ((const char *) fields[j], (const char *) "raddr") == 0)
                                      {
                                        engine->ice_in.cands[engine->ice_in.cand_idx][cid].raddr = switch_core_perform_session_strdup (smh->session, (const char *) fields[j + 1], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2606);
                                      }
                                    else
                                      {
                                        if (strcasecmp ((const char *) fields[j], (const char *) "rport") == 0)
                                          {
                                            engine->ice_in.cands[engine->ice_in.cand_idx][cid].rport = (short unsigned int) atoi ((const char *) fields[j + 1]);
                                          }
                                        else
                                          {
                                            if (strcasecmp ((const char *) fields[j], (const char *) "generation") == 0)
                                              {
                                                engine->ice_in.cands[engine->ice_in.cand_idx][cid].generation = switch_core_perform_session_strdup (smh->session, (const char *) fields[j + 1], (const char *) "src/switch_core_media.c", (const char *) &__func__, 2610);
                                              }
                                          }
                                      }
                                  }
                                j = j + 2;
                                <D.38872>:;
                                if (j < argc && fields[j + 1] != 0B) goto <D.38871>; else goto <D.38873>;
                                <D.38873>:;
                                if (engine->ice_in.chosen[cid] != 0)
                                  {
                                    engine->ice_in.cands[engine->ice_in.chosen[cid]][cid].ready++ ;
                                  }
                                goto <D.38874>;
                                i++ ;
                                <D.38876>:;
                                if (engine->cand_acl_count > i) goto <D.38875>; else goto <D.38874>;
                                <D.38874>:;
                              }
                          }
                      }
                  }
              }
          }
      }
  }
  <D.38865>:;
  attr = attr->a_next;
  <D.38878>:;
  if (attr != 0B) goto <D.38877>; else goto <D.38879>;
  <D.38879>:;
  if (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)
    {
      i = 0;
      goto <D.38881>;
      <D.38880>:;
      if (((engine->ice_in.chosen[0] == 0 && engine->ice_in.cands[i][0].component_id == 1) && (short unsigned int) engine->ice_in.cands[i][0].rport == 0) && (unsigned int) switch_check_network_list_ip_token ((const char *) engine->ice_in.cands[i][0].con_addr, (const char *) "localnet.auto", 0B) != 0)
        {
          engine->ice_in.chosen[0] = i;
          engine->ice_in.cands[engine->ice_in.chosen[0]][0].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2636, (const char *) smh->session, 5, (const char *) "No %s RTP candidate found; defaulting to the first local one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      if (((engine->ice_in.chosen[1] == 0 && engine->ice_in.cands[i][1].component_id == 2) && (short unsigned int) engine->ice_in.cands[i][1].rport == 0) && (unsigned int) switch_check_network_list_ip_token ((const char *) engine->ice_in.cands[i][1].con_addr, (const char *) "localnet.auto", 0B) != 0)
        {
          engine->ice_in.chosen[1] = i;
          engine->ice_in.cands[engine->ice_in.chosen[1]][1].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2643, (const char *) smh->session, 5, (const char *) "No %s RTCP candidate found; defaulting to the first local one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      i++ ;
      <D.38881>:;
      if (engine->ice_in.cand_idx >= i && (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)) goto <D.38880>; else goto <D.38882>;
      <D.38882>:;
    }
  if (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)
    {
      i = 0;
      goto <D.38884>;
      <D.38883>:;
      if ((engine->ice_in.chosen[0] == 0 && engine->ice_in.cands[i][0].component_id == 1) && (short unsigned int) engine->ice_in.cands[i][0].rport != 0)
        {
          engine->ice_in.chosen[0] = i;
          engine->ice_in.cands[engine->ice_in.chosen[0]][0].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2655, (const char *) smh->session, 5, (const char *) "No %s RTP candidate found; defaulting to the first srflx one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      if ((engine->ice_in.chosen[1] == 0 && engine->ice_in.cands[i][1].component_id == 2) && (short unsigned int) engine->ice_in.cands[i][1].rport != 0)
        {
          engine->ice_in.chosen[1] = i;
          engine->ice_in.cands[engine->ice_in.chosen[1]][1].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2661, (const char *) smh->session, 5, (const char *) "No %s RTCP candidate found; defaulting to the first srflx one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      i++ ;
      <D.38884>:;
      if (engine->ice_in.cand_idx >= i && (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)) goto <D.38883>; else goto <D.38885>;
      <D.38885>:;
    }
  if (engine->ice_in.chosen[0] != 0 && (engine->ice_in.chosen[1] == 0 && got_rtcp_mux != 0))
    {
      engine->ice_in.chosen[1] = engine->ice_in.chosen[0];
      memcpy ((void * restrict) &engine->ice_in.cands + ((unsigned int) ((unsigned int) engine->ice_in.chosen[1] * 88) + 44), (const void * restrict) &engine->ice_in.cands + (unsigned int) ((unsigned int) engine->ice_in.chosen[0] * 88), 44);
      engine->ice_in.cands[engine->ice_in.chosen[1]][1].ready++ ;
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2675, (const char *) smh->session, 5, (const char *) "No %s RTCP candidate found; defaulting to the same as RTP [%s:%d]\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_addr, (int) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port);
    }
  if (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)
    {
      i = 0;
      goto <D.38887>;
      <D.38886>:;
      if (engine->ice_in.chosen[0] == 0 && engine->ice_in.cands[i][0].component_id == 1)
        {
          engine->ice_in.chosen[0] = i;
          engine->ice_in.cands[engine->ice_in.chosen[0]][0].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2686, (const char *) smh->session, 5, (const char *) "No %s RTP candidate found; defaulting to the first one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      if (engine->ice_in.chosen[1] == 0 && engine->ice_in.cands[i][1].component_id == 2)
        {
          engine->ice_in.chosen[1] = i;
          engine->ice_in.cands[engine->ice_in.chosen[1]][1].ready++ ;
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2692, (const char *) smh->session, 5, (const char *) "No %s RTCP candidate found; defaulting to the first one.\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
        }
      i++ ;
      <D.38887>:;
      if (engine->ice_in.cand_idx >= i && (engine->ice_in.chosen[0] == 0 || engine->ice_in.chosen[1] == 0)) goto <D.38886>; else goto <D.38888>;
      <D.38888>:;
    }
  i = 0;
  goto <D.38890>;
  <D.38889>:;
  if ((unsigned char) engine->ice_in.cands[engine->ice_in.chosen[i]][i].ready != 0)
    {
      if (_zstr ((const char *) engine->ice_in.ufrag) != 0 || _zstr ((const char *) engine->ice_in.pwd) != 0)
        {
          engine->ice_in.cands[engine->ice_in.chosen[i]][i].ready = 0;
        }
    }
  i++ ;
  <D.38890>:;
  if (i <= 1) goto <D.38889>; else goto <D.38891>;
  <D.38891>:;
  if (engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr != 0B && (short unsigned int) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_port != 0)
    {
      {
        char tmp[80] = "";

                char tmp[80] = "";
        engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (smh->session, (const char *) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2709);
        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2710, (const char *) smh->session, 5, (const char *) "setting remote %s ice addr to %s:%d based on candidate\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr, (int) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_port);
        engine->ice_in.cands[engine->ice_in.chosen[0]][0].ready++ ;
        engine->remote_rtp_ice_port = engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_port;
        engine->remote_rtp_ice_addr = switch_core_perform_session_strdup (smh->session, (const char *) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2716);
        engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (smh->session, (const char *) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2718);
        engine->cur_payload_map->remote_sdp_port = engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_port;
        if ((short unsigned int) engine->remote_rtcp_port != 0)
          {
            engine->remote_rtcp_port = engine->cur_payload_map->remote_sdp_port;
          }
        switch_snprintf ((char *) &tmp, 80, (const char *) "%d", (int) engine->cur_payload_map->remote_sdp_port);
        switch_channel_set_variable_var_check (smh->session->channel, (const char *) "remote_media_ip", (const char *) engine->cur_payload_map->remote_sdp_ip, 1);
        switch_channel_set_variable_var_check (smh->session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
      }
    }
  if ((short unsigned int) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port != 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2730, (const char *) smh->session, 5, (const char *) "setting remote rtcp %s addr to %s:%d based on candidate\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_addr, (int) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port);
      engine->remote_rtcp_ice_port = engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port;
      engine->remote_rtcp_ice_addr = switch_core_perform_session_strdup (smh->session, (const char *) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_addr, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2734);
      engine->remote_rtcp_port = engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port;
    }
  if (m != 0B && got_rtcp_mux == 0)
    {
      engine->rtcp_mux = -1;
    }
  if (switch_channel_test_flag (smh->session->channel, 103) != 0)
    {
      if ((unsigned char) switch_rtp_ready (engine->rtp_session) != 0 && (unsigned char) engine->ice_in.cands[engine->ice_in.chosen[0]][0].ready != 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2749, (const char *) smh->session, 6, (const char *) "RE-Activating %s ICE\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
          switch_rtp_activate_ice (engine->rtp_session, engine->ice_in.ufrag, engine->ice_out.ufrag, (const char *) engine->ice_out.pwd, (const char *) engine->ice_in.pwd, 0, (unsigned int) switch_ice_direction (smh->session) == 1 ? 2 : 6, &engine->ice_in);
        }
      if (engine->rtp_session != 0B && ((val = switch_channel_get_variable_dup (smh->session->channel, (const char *) ((unsigned int) type == 1 ? "rtcp_video_interval_msec" : "rtcp_audio_interval_msec"), 1, -1)) != 0B || (val = (const char *) ((unsigned int) type == 1 ? smh->mparams->rtcp_video_interval_msec : smh->mparams->rtcp_audio_interval_msec)) != 0B))
        {
          {
            const char * rport = switch_channel_get_variable_dup (smh->session->channel, (const char *) ((unsigned int) type == 1 ? "rtp_remote_video_rtcp_port" : "rtp_remote_audio_rtcp_port"), 1, -1);
            switch_port_t remote_rtcp_port = engine->remote_rtcp_port;

                        const char * rport = switch_channel_get_variable_dup (smh->session->channel, (const char *) ((unsigned int) type == 1 ? "rtp_remote_video_rtcp_port" : "rtp_remote_audio_rtcp_port"), 1, -1);
                        switch_port_t remote_rtcp_port = engine->remote_rtcp_port;
            if ((short unsigned int) remote_rtcp_port == 0 && rport != 0B)
              {
                remote_rtcp_port = (short unsigned int) atoi (rport);
              }
            if (strcasecmp (val, (const char *) "passthru") == 0)
              {
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2787, (const char *) smh->session, 6, (const char *) "Activating %s RTCP PASSTHRU PORT %d\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", (int) remote_rtcp_port);
                switch_rtp_activate_rtcp (engine->rtp_session, -1, remote_rtcp_port, (signed char) engine->rtcp_mux > 0);
              }
            else
              {
                {
                  int interval = atoi (val);

                                    int interval = atoi (val);
                  if ((unsigned int) interval + 4294967196 > 499900)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2793, (const char *) smh->session, 3, (const char *) "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);
                      interval = 10000;
                    }
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2798, (const char *) smh->session, 6, (const char *) "Activating %s RTCP PORT %d\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio", (int) remote_rtcp_port);
                  switch_rtp_activate_rtcp (engine->rtp_session, interval, remote_rtcp_port, (signed char) engine->rtcp_mux > 0);
                }
              }
          }
        }
      if ((unsigned char) engine->ice_in.cands[engine->ice_in.chosen[1]][1].ready != 0)
        {
          if (((signed char) engine->rtcp_mux > 0 && TARGET_EXPR <D.38904, {
            size_t __s1_len;
            size_t __s2_len;

                        size_t __s1_len;
                        size_t __s2_len;
            D.38904 = __builtin_strcmp ((const char *) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_addr, (const char *) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_addr);
          }> == 0) && (short unsigned int) engine->ice_in.cands[engine->ice_in.chosen[1]][1].con_port == (short unsigned int) engine->ice_in.cands[engine->ice_in.chosen[0]][0].con_port)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2806, (const char *) smh->session, 6, (const char *) "Skipping %s RTCP ICE (Same as RTP)\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
            }
          else
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2808, (const char *) smh->session, 6, (const char *) "Activating %s RTCP ICE\n", (unsigned int) type == 1 ? (char *) "video" : (char *) "audio");
              switch_rtp_activate_ice (engine->rtp_session, engine->ice_in.ufrag, engine->ice_out.ufrag, (const char *) engine->ice_out.pwd, (const char *) engine->ice_in.pwd, 1, (unsigned int) switch_ice_direction (smh->session) == 1 ? 2 : 6, &engine->ice_in);
            }
        }
    }
}



;; Function switch_core_session_set_ice (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[28] = "switch_core_session_set_ice";

    static const char __PRETTY_FUNCTION__[28] = "switch_core_session_set_ice";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2840, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  switch_channel_set_flag_value (session->channel, 110, 1);
  switch_channel_set_flag_value (session->channel, 106, 1);
  switch_channel_set_flag_value (session->channel, 108, 1);
  smh->mparams->rtcp_audio_interval_msec = (char *) "10000";
  smh->mparams->rtcp_video_interval_msec = (char *) "10000";
}



;; Function greedy_sort (null)
;; enabled by -tree-original

{
  int j = 0;
  int f = 0;
  int g;
  struct matches mtmp[30] = {{.imp=0B}};

    int j = 0;
    int f = 0;
    int g;
    struct matches mtmp[30] = {{.imp=0B}};
  j = 0;
  goto <D.38927>;
  <D.38926>:;
  *((struct matches *) &mtmp + (unsigned int) ((unsigned int) j * 16)) = *(matches + (unsigned int) ((unsigned int) j * 16));
  j++ ;
  <D.38927>:;
  if (j < m_idx) goto <D.38926>; else goto <D.38928>;
  <D.38928>:;
  g = 0;
  goto <D.38934>;
  <D.38933>:;
  {
    const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) g * 4));

        const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) g * 4));
    j = 0;
    goto <D.38931>;
    <D.38930>:;
    if (mtmp[j].imp == imp)
      {
        *(matches + (unsigned int) ((unsigned int) f++  * 16)) = *((struct matches *) &mtmp + (unsigned int) ((unsigned int) j * 16));
      }
    j++ ;
    <D.38931>:;
    if (j < m_idx) goto <D.38930>; else goto <D.38932>;
    <D.38932>:;
  }
  g++ ;
  <D.38934>:;
  if (smh->mparams->num_codecs > g && g < total_codecs) goto <D.38933>; else goto <D.38935>;
  <D.38935>:;
}



;; Function clear_pmaps (null)
;; enabled by -tree-original

{
  struct payload_map_t * pmap;

    struct payload_map_t * pmap;
  pmap = engine->payload_map;
  goto <D.38941>;
  <D.38940>:;
  pmap->negotiated = 0;
  pmap->current = 0;
  pmap = (struct payload_map_t *) pmap->next;
  <D.38941>:;
  if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.38940>; else goto <D.38942>;
  <D.38942>:;
}



;; Function switch_core_media_negotiate_sdp (null)
;; enabled by -tree-original

{
  uint8_t match = 0;
  switch_payload_t best_te = 0;
  switch_payload_t te = 0;
  switch_payload_t cng_pt = 0;
  struct sdp_media_t * m;
  struct sdp_attribute_t * attr;
  int ptime = 0;
  int dptime = 0;
  int maxptime = 0;
  int dmaxptime = 0;
  int sendonly = 0;
  int recvonly = 0;
  int greedy = 0;
  int x = 0;
  int skip = 0;
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  const char * val;
  const char * crypto = 0B;
  int got_crypto = 0;
  int got_video_crypto = 0;
  int got_audio = 0;
  int got_avp = 0;
  int got_video_avp = 0;
  int got_video_savp = 0;
  int got_savp = 0;
  int got_udptl = 0;
  int got_webrtc = 0;
  int scrooge = 0;
  struct sdp_parser_t * parser = 0B;
  struct sdp_session_t * sdp;
  int reneg = 1;
  const struct switch_codec_implementation_t * * codec_array;
  int total_codecs;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  uint32_t near_rate = 0;
  const struct switch_codec_implementation_t * mimp = 0B;
  const struct switch_codec_implementation_t * near_match = 0B;
  struct sdp_rtpmap_t * mmap = 0B;
  struct sdp_rtpmap_t * near_map = 0B;
  struct matches matches[30] = {{.imp=0B}};
  struct matches near_matches[30] = {{.imp=0B}};
  int codec_ms = 0;
  uint32_t remote_codec_rate = 0;
  uint32_t fmtp_remote_codec_rate = 0;
  const char * tmp;
  int m_idx = 0;
  int nm_idx = 0;
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_negotiate_sdp";
  static const char __func__[32] = "switch_core_media_negotiate_sdp";
  void done = <<< error >>>;

    static const char __func__[32] = "switch_core_media_negotiate_sdp";
    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_negotiate_sdp";
    uint8_t match = 0;
    switch_payload_t best_te = 0;
    switch_payload_t te = 0;
    switch_payload_t cng_pt = 0;
    struct sdp_media_t * m;
    struct sdp_attribute_t * attr;
    int ptime = 0;
    int dptime = 0;
    int maxptime = 0;
    int dmaxptime = 0;
    int sendonly = 0;
    int recvonly = 0;
    int greedy = 0;
    int x = 0;
    int skip = 0;
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    const char * val;
    const char * crypto = 0B;
    int got_crypto = 0;
    int got_video_crypto = 0;
    int got_audio = 0;
    int got_avp = 0;
    int got_video_avp = 0;
    int got_video_savp = 0;
    int got_savp = 0;
    int got_udptl = 0;
    int got_webrtc = 0;
    int scrooge = 0;
    struct sdp_parser_t * parser = 0B;
    struct sdp_session_t * sdp;
    int reneg = 1;
    const struct switch_codec_implementation_t * * codec_array;
    int total_codecs;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
    uint32_t near_rate = 0;
    const struct switch_codec_implementation_t * mimp = 0B;
    const struct switch_codec_implementation_t * near_match = 0B;
    struct sdp_rtpmap_t * mmap = 0B;
    struct sdp_rtpmap_t * near_map = 0B;
    struct matches matches[30] = {{.imp=0B}};
    struct matches near_matches[30] = {{.imp=0B}};
    int codec_ms = 0;
    uint32_t remote_codec_rate = 0;
    uint32_t fmtp_remote_codec_rate = 0;
    const char * tmp;
    int m_idx = 0;
    int nm_idx = 0;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 2922, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  codec_array = (const struct switch_codec_implementation_t * *) &smh->codecs;
  total_codecs = smh->mparams->num_codecs;
  if ((parser = sdp_parse (0B, r_sdp, (int) strlen (r_sdp), 0)) == 0B)
    {
      return 0;
    }
  if ((sdp = sdp_session (parser)) == 0B)
    {
      sdp_parser_free (parser);
      return 0;
    }
  if ((dtls_ok (session) != 0 && (tmp = switch_channel_get_variable_dup (smh->session->channel, (const char *) "webrtc_enable_dtls", 1, -1)) != 0B) && switch_false (tmp) != 0)
    {
      switch_channel_clear_flag (smh->session->channel, 111);
      switch_channel_clear_flag (smh->session->channel, 109);
    }
  switch_core_session_parse_crypto_prefs (session);
  clear_pmaps (a_engine);
  clear_pmaps (v_engine);
  if (proceed != 0B)
    {
      *proceed = 1;
    }
  greedy = (int) switch_media_handle_test_media_flag (smh, 3) != 0;
  scrooge = (int) switch_media_handle_test_media_flag (smh, 4) != 0;
  if ((val = switch_channel_get_variable_dup (channel, (const char *) "rtp_codec_negotiation", 1, -1)) != 0B)
    {
      if (strcasecmp (val, (const char *) "generous") == 0)
        {
          greedy = 0;
          scrooge = 0;
        }
      else
        {
          if (strcasecmp (val, (const char *) "greedy") == 0)
            {
              greedy = 1;
              scrooge = 0;
            }
          else
            {
              if (strcasecmp (val, (const char *) "scrooge") == 0)
                {
                  scrooge = 1;
                  greedy = 1;
                }
              else
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2969, (const char *) session, 7, (const char *) "rtp_codec_negotiation ignored invalid value : \'%s\' \n", val);
                }
            }
        }
    }
  if ((smh->origin = switch_core_perform_session_strdup (session, sdp->sdp_origin->o_username, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2973)) != 0B)
    {
      if ((int) smh->mparams->auto_rtp_bugs & 1)
        {
          if (strstr ((const char *) smh->origin, (const char *) "CiscoSystemsSIP-GW-UserAgent") != 0B)
            {
              a_engine->rtp_bugs = (switch_rtp_bug_flag_t) ((unsigned int) a_engine->rtp_bugs | 1);
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2979, (const char *) session, 7, (const char *) "Activate Buggy RFC2833 Mode!\n");
            }
        }
      if (((unsigned int) smh->mparams->auto_rtp_bugs & 2) != 0)
        {
          if (strstr ((const char *) smh->origin, (const char *) "Sonus_UAC") != 0B)
            {
              a_engine->rtp_bugs = (switch_rtp_bug_flag_t) ((unsigned int) a_engine->rtp_bugs | 2);
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 2986, (const char *) session, 4, (const char *) "Hello,\nI see you have a Sonus!\nFYI, Sonus cannot follow the RFC on the proper way to send DTMF.\nSadly, my creator had to spend several hours figuring this out so I thought you\'d like to know that!\nDon\'t worry, DTMF will work but you may want to ask them to fix it......\n");
            }
        }
    }
  if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_liberal_dtmf", 1, -1)) != 0B && switch_true (val) != 0)
    {
      switch_channel_set_flag_value (session->channel, 93, 1);
    }
  if ((m = sdp->sdp_media) != 0B && (((SAVE_EXPR <BIT_FIELD_REF <*m, 8, 544> & 6>) == 2 || (SAVE_EXPR <BIT_FIELD_REF <*m, 8, 544> & 6>) == 0) || (m->m_connections != 0B && m->m_connections->c_address != 0B) && TARGET_EXPR <D.39008, {
    size_t __s1_len;
    size_t __s2_len;

        size_t __s1_len;
        size_t __s2_len;
    D.39008 = __s2_len = 7;, __s2_len <= 3; ? TARGET_EXPR <D.39007, {
      const unsigned char * __s1 = (const unsigned char *) m->m_connections->c_address;
      register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";

            const unsigned char * __s1 = (const unsigned char *) m->m_connections->c_address;
            register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";
      {
        if (__s2_len != 0 && __result == 0)
          {
            __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "0.0.0.0" + 1);
            if (__s2_len > 1 && __result == 0)
              {
                __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "0.0.0.0" + 2);
                if (__s2_len > 2 && __result == 0)
                  {
                    __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "0.0.0.0" + 3);
                  }
              }
          }
      }
      D.39007 = __result;
    }> : __builtin_strcmp (m->m_connections->c_address, (const char *) "0.0.0.0");
  }> == 0))
    {
      sendonly = 2;
    }
  attr = sdp->sdp_attributes;
  goto <D.39011>;
  <D.39010>:;
  if (_zstr (attr->a_name) != 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.39009>;
    }
  if (strcasecmp (attr->a_name, (const char *) "sendonly") == 0)
    {
      sendonly = 1;
      switch_channel_set_variable_var_check (session->channel, (const char *) "media_audio_mode", (const char *) "recvonly", 1);
    }
  else
    {
      if (strcasecmp (attr->a_name, (const char *) "inactive") == 0)
        {
          sendonly = 1;
          switch_channel_set_variable_var_check (session->channel, (const char *) "media_audio_mode", (const char *) "inactive", 1);
        }
      else
        {
          if (strcasecmp (attr->a_name, (const char *) "recvonly") == 0)
            {
              switch_channel_set_variable_var_check (session->channel, (const char *) "media_audio_mode", (const char *) "sendonly", 1);
              recvonly = 1;
              if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
                {
                  switch_rtp_set_max_missed_packets (a_engine->rtp_session, 0);
                  a_engine->max_missed_hold_packets = 0;
                  a_engine->max_missed_packets = 0;
                }
              else
                {
                  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_timeout_sec", (const char *) "0", 1);
                  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_hold_timeout_sec", (const char *) "0", 1);
                }
            }
          else
            {
              if (sendonly <= 1 && strcasecmp (attr->a_name, (const char *) "sendrecv") == 0)
                {
                  sendonly = 0;
                }
              else
                {
                  if (strcasecmp (attr->a_name, (const char *) "ptime") == 0)
                    {
                      dptime = atoi (attr->a_value);
                    }
                  else
                    {
                      if (strcasecmp (attr->a_name, (const char *) "maxptime") == 0)
                        {
                          dmaxptime = atoi (attr->a_value);
                        }
                    }
                }
            }
        }
    }
  <D.39009>:;
  attr = attr->a_next;
  <D.39011>:;
  if (attr != 0B) goto <D.39010>; else goto <D.39012>;
  <D.39012>:;
  if (sendonly != 1 && recvonly != 1)
    {
      switch_channel_set_variable_var_check (session->channel, (const char *) "media_audio_mode", 0B, 1);
    }
  if (((int) switch_media_handle_test_media_flag (smh, 5) == 0 && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_disable_hold", 1, -1)) == 0B || switch_true (val) == 0)) && smh->mparams->hold_laps == 0)
    {
      smh->mparams->hold_laps++ ;
      if (switch_core_media_toggle_hold (session, sendonly) != 0)
        {
          reneg = switch_media_handle_test_media_flag (smh, 6);
          if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_renegotiate_codec_on_hold", 1, -1)) != 0B)
            {
              reneg = switch_true (val);
            }
        }
    }
  if (reneg != 0)
    {
      reneg = switch_media_handle_test_media_flag (smh, 7);
      if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_renegotiate_codec_on_reinvite", 1, -1)) != 0B)
        {
          reneg = switch_true (val);
        }
    }
  if (session->bugs != 0B)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3063, (const char *) session, 7, (const char *) "Session is connected to a media bug. Re-Negotiation implicitly disabled.\n");
      reneg = 0;
    }
  if (reneg == 0 && smh->num_negotiated_codecs != 0)
    {
      codec_array = (const struct switch_codec_implementation_t * *) &smh->negotiated_codecs;
      total_codecs = smh->num_negotiated_codecs;
    }
  else
    {
      if (reneg != 0)
        {
          smh->mparams->num_codecs = 0;
          switch_core_media_prepare_codecs (session, 0);
          codec_array = (const struct switch_codec_implementation_t * *) &smh->codecs;
          total_codecs = smh->mparams->num_codecs;
        }
    }
  if ((switch_stristr ((const char *) "T38FaxFillBitRemoval:", r_sdp) != 0B || switch_stristr ((const char *) "T38FaxTranscodingMMR:", r_sdp) != 0B) || switch_stristr ((const char *) "T38FaxTranscodingJBIG:", r_sdp) != 0B)
    {
      switch_channel_set_variable_var_check (session->channel, (const char *) "t38_broken_boolean", (const char *) "true", 1);
    }
  switch_core_media_find_zrtp_hash (session, sdp);
  switch_core_media_pass_zrtp_hash (session);
  check_ice (smh, 0, sdp, 0B);
  check_ice (smh, 1, sdp, 0B);
  m = sdp->sdp_media;
  goto <D.39109>;
  <D.39108>:;
  {
    struct sdp_connection_t * connection;
    struct switch_core_session_t * other_session;

        struct sdp_connection_t * connection;
        struct switch_core_session_t * other_session;
    ptime = dptime;
    maxptime = dmaxptime;
    if ((unsigned int) m->m_proto == 261)
      {
        got_webrtc++ ;
        switch_core_session_set_ice (session);
      }
    if (m->m_proto_name != 0B && strcasecmp (m->m_proto_name, (const char *) "UDP/TLS/RTP/SAVPF") == 0)
      {
        switch_channel_set_flag_value (session->channel, 107, 1);
      }
    if (SAVE_EXPR <m->m_proto> == 257 || SAVE_EXPR <m->m_proto> == 261)
      {
        if ((unsigned int) m->m_type == 2)
          {
            got_savp++ ;
          }
        else
          {
            got_video_savp++ ;
          }
      }
    else
      {
        if ((unsigned int) m->m_proto == 256)
          {
            if ((unsigned int) m->m_type == 2)
              {
                got_avp++ ;
              }
            else
              {
                got_video_avp++ ;
              }
          }
        else
          {
            if ((unsigned int) m->m_proto == 258)
              {
                got_udptl++ ;
              }
          }
      }
    if ((got_udptl != 0 && (unsigned int) m->m_type == 8) && m->m_port != 0)
      {
        {
          struct switch_t38_options_t * t38_options = switch_core_media_process_udptl (session, sdp, m);

                    struct switch_t38_options_t * t38_options = switch_core_media_process_udptl (session, sdp, m);
          if (switch_channel_test_app_flag_key ((const char *) "T38", session->channel, 16) != 0)
            {
              match = 1;
              goto done;
            }
          if (switch_true (switch_channel_get_variable_dup (channel, (const char *) "refuse_t38", 1, -1)) != 0)
            {
              switch_channel_clear_app_flag_key ((const char *) "T38", session->channel, 2);
              match = 0;
              goto done;
            }
          else
            {
              {
                const char * var = switch_channel_get_variable_dup (channel, (const char *) "t38_passthru", 1, -1);
                int pass = (int) switch_channel_test_flag (smh->session->channel, 101);

                                const char * var = switch_channel_get_variable_dup (channel, (const char *) "t38_passthru", 1, -1);
                                int pass = (int) switch_channel_test_flag (smh->session->channel, 101);
                if (switch_channel_test_app_flag_key ((const char *) "T38", session->channel, 2) != 0)
                  {
                    if (proceed != 0B)
                      {
                        *proceed = 0;
                      }
                  }
                if (var != 0B)
                  {
                    if ((pass = switch_true (var)) == 0)
                      {
                        if (strcasecmp (var, (const char *) "once") == 0)
                          {
                            pass = 2;
                          }
                      }
                  }
                if ((((pass == 2 && switch_channel_test_flag (smh->session->channel, 101) != 0 || switch_channel_test_flag (session->channel, 103) == 0) || switch_channel_test_flag (session->channel, 15) != 0) || switch_channel_test_flag (session->channel, 29) != 0) || (unsigned char) switch_rtp_ready (a_engine->rtp_session) == 0)
                  {
                    pass = 0;
                  }
                if (pass != 0 && (unsigned int) switch_core_session_perform_get_partner (session, &other_session, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3161) == 0)
                  {
                    {
                      struct switch_channel_t * other_channel = switch_core_session_get_channel (other_session);
                      struct switch_core_session_message_t * msg;
                      char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
                      switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
                      char tmp[32] = "";

                                            struct switch_channel_t * other_channel = switch_core_session_get_channel (other_session);
                                            struct switch_core_session_message_t * msg;
                                            char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
                                            switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
                                            char tmp[32] = "";
                      if (switch_channel_test_flag (other_channel, 1) == 0)
                        {
                          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3170, (const char *) session, 4, (const char *) "%s Error Passing T.38 to unanswered channel %s\n", switch_channel_get_name (session->channel), switch_channel_get_name (other_channel));
                          switch_core_session_rwunlock (other_session);
                          pass = 0;
                          match = 0;
                          goto done;
                        }
                      if (switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "t38_broken_boolean", 1, -1)) != 0 && switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "t38_pass_broken_boolean", 1, -1)) != 0)
                        {
                          switch_channel_set_variable_var_check (other_channel, (const char *) "t38_broken_boolean", (const char *) "true", 1);
                        }
                      a_engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (session, t38_options->remote_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3186);
                      a_engine->cur_payload_map->remote_sdp_port = t38_options->remote_port;
                      if (((remote_host != 0B && (short unsigned int) remote_port != 0) && TARGET_EXPR <D.39032, {
                        size_t __s1_len;
                        size_t __s2_len;

                                                size_t __s1_len;
                                                size_t __s2_len;
                        D.39032 = __builtin_strcmp ((const char *) remote_host, (const char *) a_engine->cur_payload_map->remote_sdp_ip);
                      }> == 0) && (short unsigned int) a_engine->cur_payload_map->remote_sdp_port == (short unsigned int) remote_port)
                        {
                          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3190, (const char *) session, 7, (const char *) "Audio params are unchanged for %s.\n", switch_channel_get_name (session->channel));
                        }
                      else
                        {
                          {
                            const char * err = 0B;

                                                        const char * err = 0B;
                            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3195, (const char *) session, 7, (const char *) "Audio params changed for %s from %s:%d to %s:%d\n", switch_channel_get_name (session->channel), remote_host, (int) remote_port, a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
                            switch_snprintf ((char *) &tmp, 32, (const char *) "%d", (int) a_engine->cur_payload_map->remote_sdp_port);
                            switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_ip", (const char *) a_engine->cur_payload_map->remote_sdp_ip, 1);
                            switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
                            if ((unsigned int) switch_rtp_set_remote_address (a_engine->rtp_session, (const char *) a_engine->cur_payload_map->remote_sdp_ip, a_engine->cur_payload_map->remote_sdp_port, 0, 1, &err) != 0)
                              {
                                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3205, (const char *) session, 3, (const char *) "AUDIO RTP REPORTS ERROR: [%s]\n", err);
                                switch_channel_perform_hangup (channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3206, 88);
                              }
                          }
                        }
                      switch_core_media_copy_t38_options (t38_options, other_session);
                      switch_channel_set_flag_value (smh->session->channel, 101, 1);
                      switch_channel_set_flag_value (other_session->channel, 101, 1);
                      msg = (struct switch_core_session_message_t *) switch_core_perform_session_alloc (other_session, 108, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3218);
                      msg->message_id = 21;
                      msg->from = (char *) "src/switch_core_media.c";
                      msg->string_arg = (const char *) switch_core_perform_session_strdup (other_session, r_sdp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3221);
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3222, (const char *) session, 7, (const char *) "Passing T38 req to other leg.\n%s\n", r_sdp);
                      switch_core_session_queue_message (other_session, msg);
                      switch_core_session_rwunlock (other_session);
                    }
                  }
              }
            }
          match = 1;
          goto done;
        }
      }
    else
      {
        if ((unsigned int) m->m_type == 2 && (m->m_port != 0 && got_audio == 0))
          {
            {
              struct sdp_rtpmap_t * map;

                            struct sdp_rtpmap_t * map;
              if (switch_rtp_has_dtls () != 0 && dtls_ok (session) != 0)
                {
                  attr = m->m_attributes;
                  goto <D.39036>;
                  <D.39035>:;
                  if (strcasecmp (attr->a_name, (const char *) "fingerprint") == 0 && _zstr (attr->a_value) == 0)
                    {
                      got_crypto = 1;
                    }
                  attr = attr->a_next;
                  <D.39036>:;
                  if (attr != 0B) goto <D.39035>; else goto <D.39037>;
                  <D.39037>:;
                }
              attr = m->m_attributes;
              goto <D.39040>;
              <D.39039>:;
              if (strcasecmp (attr->a_name, (const char *) "rtcp") == 0 && attr->a_value != 0B)
                {
                  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_remote_audio_rtcp_port", attr->a_value, 1);
                  a_engine->remote_rtcp_port = (short unsigned int) atoi (attr->a_value);
                  if (smh->mparams->rtcp_audio_interval_msec == 0B)
                    {
                      smh->mparams->rtcp_audio_interval_msec = (char *) "5000";
                    }
                }
              else
                {
                  if (strcasecmp (attr->a_name, (const char *) "ptime") == 0 && attr->a_value != 0B)
                    {
                      ptime = atoi (attr->a_value);
                    }
                  else
                    {
                      if (strcasecmp (attr->a_name, (const char *) "maxptime") == 0 && attr->a_value != 0B)
                        {
                          maxptime = atoi (attr->a_value);
                        }
                      else
                        {
                          if ((got_crypto <= 0 && strcasecmp (attr->a_name, (const char *) "crypto") == 0) && _zstr (attr->a_value) == 0)
                            {
                              {
                                int crypto_tag;

                                                                int crypto_tag;
                                if (((unsigned int) smh->mparams->ndlb & 4) == 0 && switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "rtp_allow_crypto_in_avp", 1, -1)) == 0)
                                  {
                                    if ((unsigned int) m->m_proto != 257 && got_webrtc == 0)
                                      {
                                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3262, (const char *) session, 3, (const char *) "a=crypto in RTP/AVP, refer to rfc3711\n");
                                        match = 0;
                                        goto done;
                                      }
                                  }
                                crypto = attr->a_value;
                                crypto_tag = atoi (crypto);
                                got_crypto = switch_core_session_check_incoming_crypto (session, (const char *) "rtp_has_crypto", 0, crypto, crypto_tag, sdp_type);
                              }
                            }
                        }
                    }
                }
              attr = attr->a_next;
              <D.39040>:;
              if (attr != 0B) goto <D.39039>; else goto <D.39041>;
              <D.39041>:;
              if ((got_crypto == -1 && got_savp != 0) && (got_avp | got_webrtc) == 0)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3277, (const char *) session, 4, (const char *) "Declining invite with only SAVP because secure media is administratively disabled\n");
                  match = 0;
                  goto <D.39042>;
                }
              connection = sdp->sdp_connection;
              if (m->m_connections != 0B)
                {
                  connection = m->m_connections;
                }
              if (connection == 0B)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3288, (const char *) session, 3, (const char *) "Cannot find a c= line in the sdp at media or session level!\n");
                  match = 0;
                  goto <D.39042>;
                }
              x = 0;
              map = m->m_rtpmaps;
              goto <D.39057>;
              <D.39056>:;
              {
                int32_t i;
                const char * rm_encoding;
                uint32_t map_bit_rate = 0;
                struct switch_codec_fmtp_t codec_fmtp = {.actual_samples_per_second=0};

                                int32_t i;
                                const char * rm_encoding;
                                uint32_t map_bit_rate = 0;
                                struct switch_codec_fmtp_t codec_fmtp = {.actual_samples_per_second=0};
                if ((rm_encoding = map->rm_encoding) == 0B)
                  {
                    rm_encoding = (const char *) "";
                  }
                if (strcasecmp (rm_encoding, (const char *) "telephone-event") == 0)
                  {
                    if ((unsigned char) best_te == 0 || map->rm_rate == a_engine->cur_payload_map->rm_rate)
                      {
                        best_te = (unsigned char) map->rm_pt;
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3309, (const char *) session, 7, (const char *) "Set telephone-event payload to %u\n", (int) best_te);
                      }
                    // predicted unlikely by continue predictor.;
                    goto <D.39047>;
                  }
                if (((int) switch_media_handle_test_media_flag (smh, 9) == 0 && (unsigned char) cng_pt == 0) && strcasecmp (rm_encoding, (const char *) "CN") == 0)
                  {
                    cng_pt = (unsigned char) map->rm_pt;
                    if (a_engine->rtp_session != 0B)
                      {
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3317, (const char *) session, 7, (const char *) "Set comfort noise payload to %u\n", (int) cng_pt);
                        switch_rtp_set_cng_pt (a_engine->rtp_session, smh->mparams->cng_pt);
                      }
                    // predicted unlikely by continue predictor.;
                    goto <D.39047>;
                  }
                if (x++  < skip)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.39047>;
                  }
                if ((unsigned char) match != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.39047>;
                  }
                codec_ms = ptime;
                if (maxptime != 0 && (codec_ms == 0 || codec_ms > maxptime))
                  {
                    codec_ms = maxptime;
                  }
                if (codec_ms == 0)
                  {
                    codec_ms = (int) switch_default_ptime (rm_encoding, (uint32_t) map->rm_pt);
                  }
                map_bit_rate = switch_known_bitrate ((unsigned char) map->rm_pt);
                if (ptime == 0 && strcasecmp (map->rm_encoding, (const char *) "g723") == 0)
                  {
                    codec_ms = 33;
                  }
                remote_codec_rate = (uint32_t) map->rm_rate;
                fmtp_remote_codec_rate = 0;
                memset ((void *) &codec_fmtp, 0, 16);
                if (_zstr (map->rm_fmtp) != 0)
                  {
                    if (strcasecmp (map->rm_encoding, (const char *) "ilbc") == 0)
                      {
                        codec_ms = 32;
                        map_bit_rate = 13332;
                      }
                    else
                      {
                        if (strcasecmp (map->rm_encoding, (const char *) "isac") == 0)
                          {
                            codec_ms = 39;
                            map_bit_rate = 32001;
                          }
                        else
                          {
                            map_bit_rate = 32099;
                          }
                      }
                  }
                else
                  {
                    if ((unsigned int) switch_core_codec_parse_fmtp (map->rm_encoding, map->rm_fmtp, (uint32_t) map->rm_rate, &codec_fmtp) == 0)
                      {
                        if (codec_fmtp.bits_per_second != 0)
                          {
                            map_bit_rate = (uint32_t) codec_fmtp.bits_per_second;
                          }
                        if (codec_fmtp.microseconds_per_packet != 0)
                          {
                            codec_ms = codec_fmtp.microseconds_per_packet / 1000;
                          }
                        if (codec_fmtp.actual_samples_per_second != 0)
                          {
                            fmtp_remote_codec_rate = codec_fmtp.actual_samples_per_second;
                          }
                      }
                  }
                i = 0;
                goto <D.39054>;
                <D.39053>:;
                {
                  const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) i * 4));
                  uint32_t bit_rate = (uint32_t) imp->bits_per_second;
                  uint32_t codec_rate = imp->samples_per_second;

                                    const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) i * 4));
                                    uint32_t bit_rate = (uint32_t) imp->bits_per_second;
                                    uint32_t codec_rate = imp->samples_per_second;
                  if ((unsigned int) imp->codec_type != 0)
                    {
                      // predicted unlikely by continue predictor.;
                      goto <D.39051>;
                    }
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3383, (const char *) session, 7, (const char *) "Audio Codec Compare [%s:%d:%u:%d:%u]/[%s:%d:%u:%d:%u]\n", rm_encoding, (int) map->rm_pt, (int) remote_codec_rate, codec_ms, map_bit_rate, imp->iananame, (int) imp->ianacode, codec_rate, (int) imp->microseconds_per_packet / 1000, bit_rate);
                  if ((_zstr (map->rm_encoding) != 0 || (int) smh->mparams->ndlb & 1) && (int) map->rm_pt <= 95)
                    {
                      match = (int) map->rm_pt == (int) imp->ianacode;
                    }
                  else
                    {
                      match = (uint8_t) (strcasecmp (rm_encoding, (const char *) imp->iananame) == 0 && (remote_codec_rate == codec_rate || (uint32_t) imp->actual_samples_per_second == fmtp_remote_codec_rate));
                      if (fmtp_remote_codec_rate != 0)
                        {
                          remote_codec_rate = fmtp_remote_codec_rate;
                        }
                    }
                  if (((((unsigned char) match != 0 && bit_rate != 0) && (map_bit_rate != 0 && map_bit_rate != bit_rate)) && strcasecmp (map->rm_encoding, (const char *) "ilbc") != 0) && strcasecmp (map->rm_encoding, (const char *) "isac") != 0)
                    {
                      match = 0;
                    }
                  if ((((unsigned char) match != 0 && remote_codec_rate != 0) && (codec_rate != 0 && remote_codec_rate != codec_rate)) && (strcasecmp (map->rm_encoding, (const char *) "pcma") == 0 || strcasecmp (map->rm_encoding, (const char *) "pcmu") == 0))
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3405, (const char *) session, 7, (const char *) "sampling rates have to match for G.711\n");
                      match = 0;
                    }
                  if ((unsigned char) match != 0)
                    {
                      if (scrooge != 0)
                        {
                          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3411, (const char *) session, 7, (const char *) "Bah HUMBUG! Sticking with %s@%uh@%ui\n", imp->iananame, imp->samples_per_second, (int) imp->microseconds_per_packet / 1000);
                        }
                      else
                        {
                          if ((ptime != 0 && codec_ms != 0) && codec_ms * 1000 != (int) imp->microseconds_per_packet || remote_codec_rate != codec_rate)
                            {
                              match = 0;
                              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3418, (const char *) session, 7, (const char *) "Audio Codec Compare [%s:%d:%u:%d:%u] is saved as a near-match\n", imp->iananame, (int) imp->ianacode, codec_rate, (int) imp->microseconds_per_packet / 1000, bit_rate);
                              near_matches[nm_idx].codec_idx = i;
                              near_matches[nm_idx].rate = (int) remote_codec_rate;
                              near_matches[nm_idx].imp = imp;
                              near_matches[nm_idx].map = map;
                              nm_idx++ ;
                              // predicted unlikely by continue predictor.;
                              goto <D.39051>;
                            }
                        }
                      matches[m_idx].codec_idx = i;
                      matches[m_idx].rate = (int) codec_rate;
                      matches[m_idx].imp = imp;
                      matches[m_idx].map = map;
                      m_idx++ ;
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3437, (const char *) session, 7, (const char *) "Audio Codec Compare [%s:%d:%u:%d:%u] ++++ is saved as a match\n", imp->iananame, (int) imp->ianacode, codec_rate, (int) imp->microseconds_per_packet / 1000, bit_rate);
                      if (m_idx > 29)
                        {
                          goto <D.39052>;
                        }
                      match = 0;
                    }
                }
                <D.39051>:;
                i++ ;
                <D.39054>:;
                if (smh->mparams->num_codecs > (int) i && (int) i < total_codecs) goto <D.39053>; else goto <D.39052>;
                <D.39052>:;
                if (m_idx > 29)
                  {
                    goto <D.39055>;
                  }
              }
              <D.39047>:;
              map = map->rm_next;
              <D.39057>:;
              if (map != 0B) goto <D.39056>; else goto <D.39055>;
              <D.39055>:;
              if ((unsigned int) smh->crypto_mode == 1 && got_crypto <= 0)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3455, (const char *) session, 4, (const char *) "Crypto not negotiated but required.\n");
                  match = 0;
                  m_idx = nm_idx = 0;
                }
              if (m_idx == 0 && nm_idx != 0)
                {
                  {
                    int j;

                                        int j;
                    j = 0;
                    goto <D.39066>;
                    <D.39065>:;
                    {
                      const struct switch_codec_implementation_t * search[1];
                      char * prefs[1];
                      char tmp[80];
                      int num;
                      const struct switch_codec_implementation_t * timp = 0B;

                                            const struct switch_codec_implementation_t * search[1];
                                            char * prefs[1];
                                            char tmp[80];
                                            int num;
                                            const struct switch_codec_implementation_t * timp = 0B;
                      near_rate = (uint32_t) near_matches[j].rate;
                      near_match = near_matches[j].imp;
                      near_map = near_matches[j].map;
                      switch_snprintf ((char *) &tmp, 80, (const char *) "%s@%uh@%ui", near_match->iananame, near_rate == 0 ? (const unsigned int) near_match->samples_per_second : (const unsigned int) near_rate, codec_ms);
                      prefs[0] = (char *) &tmp;
                      num = switch_loadable_module_get_codecs_sorted ((const struct switch_codec_implementation_t * *) &search, 1, (char * *) &prefs, 1);
                      if (num != 0)
                        {
                          timp = search[0];
                        }
                      else
                        {
                          timp = near_match;
                        }
                      if (maxptime == 0 || (int) timp->microseconds_per_packet / 1000 <= maxptime)
                        {
                          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3488, (const char *) session, 7, (const char *) "Substituting codec %s@%ui@%uh\n", timp->iananame, (int) timp->microseconds_per_packet / 1000, timp->actual_samples_per_second);
                          match = 1;
                          matches[m_idx].codec_idx = near_matches[j].codec_idx;
                          matches[m_idx].rate = (int) near_rate;
                          matches[m_idx].imp = timp;
                          matches[m_idx].map = near_map;
                          m_idx++ ;
                          goto <D.39064>;
                        }
                    }
                    j++ ;
                    <D.39066>:;
                    if (j < nm_idx) goto <D.39065>; else goto <D.39064>;
                    <D.39064>:;
                  }
                }
              if (m_idx != 0)
                {
                  {
                    int j;

                                        int j;
                    if (greedy != 0)
                      {
                        greedy_sort (smh, (struct matches *) &matches, m_idx, codec_array, total_codecs);
                      }
                    match = 1;
                    a_engine->codec_negotiated = 1;
                    smh->num_negotiated_codecs = 0;
                    j = 0;
                    goto <D.39070>;
                    <D.39069>:;
                    {
                      struct payload_map_t * pmap = switch_core_media_add_payload_map (session, 0, matches[j].map->rm_encoding, matches[j].map->rm_fmtp, sdp_type, (uint32_t) matches[j].map->rm_pt, matches[j].imp->samples_per_second, (uint32_t) ((int) matches[j].imp->microseconds_per_packet / 1000), 1);

                                            struct payload_map_t * pmap = switch_core_media_add_payload_map (session, 0, matches[j].map->rm_encoding, matches[j].map->rm_fmtp, sdp_type, (uint32_t) matches[j].map->rm_pt, matches[j].imp->samples_per_second, (uint32_t) ((int) matches[j].imp->microseconds_per_packet / 1000), 1);
                      mimp = matches[j].imp;
                      mmap = matches[j].map;
                      if (j == 0)
                        {
                          a_engine->cur_payload_map = pmap;
                          a_engine->cur_payload_map->current = 1;
                          if (a_engine->rtp_session != 0B)
                            {
                              switch_rtp_set_default_payload (a_engine->rtp_session, pmap->pt);
                            }
                        }
                      pmap->rm_encoding = switch_core_perform_session_strdup (session, mmap->rm_encoding, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3535);
                      pmap->iananame = switch_core_perform_session_strdup (session, (const char *) mimp->iananame, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3536);
                      pmap->recv_pt = (unsigned char) mmap->rm_pt;
                      pmap->rm_rate = (long unsigned int) mimp->samples_per_second;
                      pmap->adv_rm_rate = (long unsigned int) mimp->samples_per_second;
                      if (strcasecmp ((const char *) mimp->iananame, (const char *) "g722") != 0)
                        {
                          pmap->rm_rate = (long unsigned int) mimp->actual_samples_per_second;
                        }
                      pmap->codec_ms = (uint32_t) ((int) mimp->microseconds_per_packet / 1000);
                      pmap->bitrate = (uint32_t) mimp->bits_per_second;
                      pmap->channels = mmap->rm_params != 0B ? atoi (mmap->rm_params) : 1;
                      if (strcasecmp (mmap->rm_encoding, (const char *) "opus") == 0)
                        {
                          if (pmap->channels == 1)
                            {
                              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3549, (const char *) session, 4, (const char *) "Invalid SDP for opus.  Don\'t ask.. but it needs a /2\n");
                              pmap->adv_channels = 1;
                            }
                          else
                            {
                              pmap->adv_channels = 2;
                            }
                          if (_zstr (mmap->rm_fmtp) == 0 && switch_stristr ((const char *) "stereo=1", mmap->rm_fmtp) != 0B)
                            {
                              pmap->channels = 2;
                            }
                          else
                            {
                              pmap->channels = 1;
                            }
                        }
                      else
                        {
                          pmap->adv_channels = pmap->channels;
                        }
                      pmap->remote_sdp_ip = switch_core_perform_session_strdup (session, connection->c_address, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3563);
                      pmap->remote_sdp_port = (short unsigned int) m->m_port;
                      pmap->rm_fmtp = switch_core_perform_session_strdup (session, mmap->rm_fmtp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3565);
                      pmap->agreed_pt = (unsigned char) mmap->rm_pt;
                      smh->negotiated_codecs[smh->num_negotiated_codecs++ ] = mimp;
                      pmap->recv_pt = (unsigned char) mmap->rm_pt;
                    }
                    j++ ;
                    <D.39070>:;
                    if (j < m_idx) goto <D.39069>; else goto <D.39071>;
                    <D.39071>:;
                  }
                }
              if ((unsigned char) match != 0)
                {
                  {
                    char tmp[50];

                                        char tmp[50];
                    switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) a_engine->cur_payload_map->remote_sdp_port);
                    switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_ip", (const char *) a_engine->cur_payload_map->remote_sdp_ip, 1);
                    switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
                    switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) a_engine->cur_payload_map->recv_pt);
                    switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_audio_recv_pt", (const char *) &tmp, 1);
                    if ((unsigned int) switch_core_codec_ready (&a_engine->read_codec) != 0)
                      {
                        a_engine->reset_codec = 1;
                      }
                    if ((unsigned int) switch_core_media_set_codec (session, 0, smh->mparams->codec_flags) == 0)
                      {
                        got_audio = 1;
                        check_ice (smh, 0, sdp, m);
                      }
                    else
                      {
                        match = 0;
                      }
                  }
                }
              if ((unsigned char) best_te == 0 && ((int) switch_media_handle_test_media_flag (smh, 8) != 0 || switch_channel_test_flag (session->channel, 93) != 0))
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3609, (const char *) session, 7, (const char *) "No 2833 in SDP. Liberal DTMF mode adding %d as telephone-event.\n", (int) smh->mparams->te);
                  best_te = smh->mparams->te;
                }
              if ((unsigned char) best_te != 0)
                {
                  if ((unsigned int) switch_channel_direction (channel) == 1)
                    {
                      te = smh->mparams->te = best_te;
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3617, (const char *) session, 7, (const char *) "Set 2833 dtmf send payload to %u\n", (int) best_te);
                      switch_channel_set_variable_var_check (session->channel, (const char *) "dtmf_type", (const char *) "rfc2833", 1);
                      smh->mparams->dtmf_type = 0;
                      if (a_engine->rtp_session != 0B)
                        {
                          switch_rtp_set_telephony_event (a_engine->rtp_session, best_te);
                          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_2833_send_payload", (const char *) "%d", (int) best_te);
                        }
                    }
                  else
                    {
                      te = smh->mparams->recv_te = smh->mparams->te = best_te;
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3626, (const char *) session, 7, (const char *) "Set 2833 dtmf send/recv payload to %u\n", (int) te);
                      switch_channel_set_variable_var_check (session->channel, (const char *) "dtmf_type", (const char *) "rfc2833", 1);
                      smh->mparams->dtmf_type = 0;
                      if (a_engine->rtp_session != 0B)
                        {
                          switch_rtp_set_telephony_event (a_engine->rtp_session, te);
                          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_2833_send_payload", (const char *) "%d", (int) te);
                          switch_rtp_set_telephony_recv_event (a_engine->rtp_session, te);
                          switch_channel_set_variable_printf (session->channel, (const char *) "rtp_2833_recv_payload", (const char *) "%d", (int) te);
                        }
                    }
                }
              else
                {
                  if (switch_false (switch_channel_get_variable_dup (channel, (const char *) "rtp_info_when_no_2833", 1, -1)) == 0)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3639, (const char *) session, 7, (const char *) "No 2833 in SDP.  Disable 2833 dtmf and switch to INFO\n");
                      switch_channel_set_variable_var_check (session->channel, (const char *) "dtmf_type", (const char *) "info", 1);
                      smh->mparams->dtmf_type = 1;
                      te = smh->mparams->recv_te = smh->mparams->te = 0;
                    }
                  else
                    {
                      switch_channel_set_variable_var_check (session->channel, (const char *) "dtmf_type", (const char *) "none", 1);
                      smh->mparams->dtmf_type = 2;
                      te = smh->mparams->recv_te = smh->mparams->te = 0;
                    }
                }
            }
          }
        else
          {
            if ((unsigned int) m->m_type == 3 && m->m_port != 0)
              {
                {
                  struct sdp_rtpmap_t * map;
                  const char * rm_encoding;
                  const struct switch_codec_implementation_t * mimp = 0B;
                  int vmatch = 0;
                  int i;

                                    struct sdp_rtpmap_t * map;
                                    const char * rm_encoding;
                                    const struct switch_codec_implementation_t * mimp = 0B;
                                    int vmatch = 0;
                                    int i;
                  nm_idx = 0;
                  m_idx = 0;
                  memset ((void *) &matches, 0, 480);
                  memset ((void *) &near_matches, 0, 480);
                  switch_channel_set_variable_var_check (session->channel, (const char *) "video_possible", (const char *) "true", 1);
                  connection = sdp->sdp_connection;
                  if (m->m_connections != 0B)
                    {
                      connection = m->m_connections;
                    }
                  if (connection == 0B)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3669, (const char *) session, 3, (const char *) "Cannot find a c= line in the sdp at media or session level!\n");
                      match = 0;
                      goto <D.39042>;
                    }
                  map = m->m_rtpmaps;
                  goto <D.39100>;
                  <D.39099>:;
                  if (switch_rtp_has_dtls () != 0 && dtls_ok (session) != 0)
                    {
                      attr = m->m_attributes;
                      goto <D.39079>;
                      <D.39078>:;
                      if (strcasecmp (attr->a_name, (const char *) "fingerprint") == 0 && _zstr (attr->a_value) == 0)
                        {
                          got_video_crypto = 1;
                        }
                      attr = attr->a_next;
                      <D.39079>:;
                      if (attr != 0B) goto <D.39078>; else goto <D.39080>;
                      <D.39080>:;
                    }
                  attr = m->m_attributes;
                  goto <D.39092>;
                  <D.39091>:;
                  if (strcasecmp (attr->a_name, (const char *) "framerate") == 0 && attr->a_value != 0B)
                    {
                      
                    }
                  else
                    {
                      if (strcasecmp (attr->a_name, (const char *) "rtcp-fb") == 0)
                        {
                          if (_zstr (attr->a_value) == 0)
                            {
                              if (switch_stristr ((const char *) "fir", attr->a_value) != 0B)
                                {
                                  v_engine->fir++ ;
                                }
                              smh->mparams->rtcp_video_interval_msec = (char *) "10000";
                            }
                        }
                      else
                        {
                          if ((strcasecmp (attr->a_name, (const char *) "rtcp") == 0 && attr->a_value != 0B) && TARGET_EXPR <D.39089, {
                            size_t __s1_len;
                            size_t __s2_len;

                                                        size_t __s1_len;
                                                        size_t __s2_len;
                            D.39089 = __s2_len = 1;, __s2_len <= 3; ? TARGET_EXPR <D.39088, {
                              const unsigned char * __s1 = (const unsigned char *) attr->a_value;
                              register int __result = (int) *__s1 - (int) *(const unsigned char *) "1";

                                                            const unsigned char * __s1 = (const unsigned char *) attr->a_value;
                                                            register int __result = (int) *__s1 - (int) *(const unsigned char *) "1";
                              {
                                if (__s2_len != 0 && __result == 0)
                                  {
                                    __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "1" + 1);
                                    if (__s2_len > 1 && __result == 0)
                                      {
                                        __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "1" + 2);
                                        if (__s2_len > 2 && __result == 0)
                                          {
                                            __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "1" + 3);
                                          }
                                      }
                                  }
                              }
                              D.39088 = __result;
                            }> : __builtin_strcmp (attr->a_value, (const char *) "1");
                          }> == 0)
                            {
                              switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_remote_video_rtcp_port", attr->a_value, 1);
                              v_engine->remote_rtcp_port = (short unsigned int) atoi (attr->a_value);
                              if (smh->mparams->rtcp_video_interval_msec == 0B)
                                {
                                  smh->mparams->rtcp_video_interval_msec = (char *) "5000";
                                }
                            }
                          else
                            {
                              if ((got_video_crypto == 0 && strcasecmp (attr->a_name, (const char *) "crypto") == 0) && _zstr (attr->a_value) == 0)
                                {
                                  {
                                    int crypto_tag;

                                                                        int crypto_tag;
                                    if (((unsigned int) smh->mparams->ndlb & 4) == 0 && switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "rtp_allow_crypto_in_avp", 1, -1)) == 0)
                                      {
                                        if ((unsigned int) m->m_proto != 257 && got_webrtc == 0)
                                          {
                                            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3711, (const char *) session, 3, (const char *) "a=crypto in RTP/AVP, refer to rfc3711\n");
                                            match = 0;
                                            goto done;
                                          }
                                      }
                                    crypto = attr->a_value;
                                    crypto_tag = atoi (crypto);
                                    got_video_crypto = switch_core_session_check_incoming_crypto (session, (const char *) "rtp_has_video_crypto", 1, crypto, crypto_tag, sdp_type);
                                  }
                                }
                            }
                        }
                    }
                  attr = attr->a_next;
                  <D.39092>:;
                  if (attr != 0B) goto <D.39091>; else goto <D.39093>;
                  <D.39093>:;
                  if ((rm_encoding = map->rm_encoding) == 0B)
                    {
                      rm_encoding = (const char *) "";
                    }
                  i = 0;
                  goto <D.39097>;
                  <D.39096>:;
                  {
                    const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) i * 4));

                                        const struct switch_codec_implementation_t * imp = *(codec_array + (unsigned int) ((unsigned int) i * 4));
                    if ((unsigned int) imp->codec_type != 1)
                      {
                        // predicted unlikely by continue predictor.;
                        goto <D.39095>;
                      }
                    if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 114) != 0)
                      {
                        // predicted unlikely by continue predictor.;
                        goto <D.39095>;
                      }
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3743, (const char *) session, 7, (const char *) "Video Codec Compare [%s:%d]/[%s:%d]\n", rm_encoding, (int) map->rm_pt, imp->iananame, (int) imp->ianacode);
                    if ((_zstr (map->rm_encoding) != 0 || (int) smh->mparams->ndlb & 1) && (int) map->rm_pt <= 95)
                      {
                        vmatch = (int) map->rm_pt == (int) imp->ianacode;
                      }
                    else
                      {
                        vmatch = strcasecmp (rm_encoding, (const char *) imp->iananame) == 0;
                      }
                    if (vmatch != 0 && map->rm_rate == (long unsigned int) imp->samples_per_second)
                      {
                        matches[m_idx].imp = imp;
                        matches[m_idx].map = map;
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3756, (const char *) session, 7, (const char *) "Video Codec Compare [%s:%d] +++ is saved as a match\n", imp->iananame, (int) imp->ianacode);
                        m_idx++ ;
                      }
                    vmatch = 0;
                  }
                  <D.39095>:;
                  i++ ;
                  <D.39097>:;
                  if (i < total_codecs) goto <D.39096>; else goto <D.39098>;
                  <D.39098>:;
                  map = map->rm_next;
                  <D.39100>:;
                  if (map != 0B) goto <D.39099>; else goto <D.39101>;
                  <D.39101>:;
                  if ((unsigned int) smh->crypto_mode == 1 && got_video_crypto <= 0)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3766, (const char *) session, 4, (const char *) "Crypto not negotiated but required.\n");
                      vmatch = 0;
                      m_idx = 0;
                    }
                  if (m_idx != 0)
                    {
                      {
                        char tmp[50];
                        int j = 0;

                                                char tmp[50];
                                                int j = 0;
                        if (greedy != 0)
                          {
                            greedy_sort (smh, (struct matches *) &matches, m_idx, codec_array, total_codecs);
                          }
                        vmatch = 1;
                        v_engine->codec_negotiated = 1;
                        j = 0;
                        goto <D.39106>;
                        <D.39105>:;
                        {
                          struct payload_map_t * pmap = switch_core_media_add_payload_map (session, 1, matches[j].map->rm_encoding, matches[j].map->rm_fmtp, sdp_type, (uint32_t) matches[j].map->rm_pt, matches[j].imp->samples_per_second, (uint32_t) ((int) matches[j].imp->microseconds_per_packet / 1000), 1);

                                                    struct payload_map_t * pmap = switch_core_media_add_payload_map (session, 1, matches[j].map->rm_encoding, matches[j].map->rm_fmtp, sdp_type, (uint32_t) matches[j].map->rm_pt, matches[j].imp->samples_per_second, (uint32_t) ((int) matches[j].imp->microseconds_per_packet / 1000), 1);
                          if (j == 0)
                            {
                              v_engine->cur_payload_map = pmap;
                              v_engine->cur_payload_map->current = 1;
                              if (v_engine->rtp_session != 0B)
                                {
                                  switch_rtp_set_default_payload (v_engine->rtp_session, pmap->pt);
                                }
                            }
                          mimp = matches[j].imp;
                          map = matches[j].map;
                          pmap->rm_encoding = switch_core_perform_session_strdup (session, map->rm_encoding, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3804);
                          pmap->recv_pt = (unsigned char) map->rm_pt;
                          pmap->rm_rate = map->rm_rate;
                          pmap->codec_ms = (uint32_t) ((int) mimp->microseconds_per_packet / 1000);
                          pmap->remote_sdp_ip = switch_core_perform_session_strdup (session, connection->c_address, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3810);
                          pmap->remote_sdp_port = (short unsigned int) m->m_port;
                          pmap->rm_fmtp = switch_core_perform_session_strdup (session, map->rm_fmtp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3813);
                          pmap->agreed_pt = (unsigned char) map->rm_pt;
                        }
                        j++ ;
                        <D.39106>:;
                        if (j < m_idx) goto <D.39105>; else goto <D.39107>;
                        <D.39107>:;
                        switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) v_engine->cur_payload_map->remote_sdp_port);
                        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_video_ip", (const char *) v_engine->cur_payload_map->remote_sdp_ip, 1);
                        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_video_port", (const char *) &tmp, 1);
                        switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_video_fmtp", (const char *) v_engine->cur_payload_map->rm_fmtp, 1);
                        switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) v_engine->cur_payload_map->agreed_pt);
                        switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_video_pt", (const char *) &tmp, 1);
                        switch_core_media_check_video_codecs (session);
                        switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) v_engine->cur_payload_map->recv_pt);
                        switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_video_recv_pt", (const char *) &tmp, 1);
                        if ((unsigned char) match == 0 && vmatch != 0)
                          {
                            match = 1;
                          }
                        if ((unsigned int) switch_core_codec_ready (&v_engine->read_codec) != 0)
                          {
                            v_engine->reset_codec = 1;
                          }
                        if ((unsigned int) switch_core_media_set_video_codec (session, 0) == 0)
                          {
                            check_ice (smh, 1, sdp, m);
                          }
                      }
                    }
                }
              }
          }
      }
  }
  m = m->m_next;
  <D.39109>:;
  if (m != 0B) goto <D.39108>; else goto <D.39042>;
  <D.39042>:;
  done:;
  if (parser != 0B)
    {
      sdp_parser_free (parser);
    }
  smh->mparams->cng_pt = cng_pt;
  return match;
}



;; Function switch_core_media_toggle_hold (null)
;; enabled by -tree-original

{
  int changed = 0;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  struct switch_core_session_t * b_session = 0B;
  struct switch_channel_t * b_channel = 0B;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_toggle_hold";
  static const char __func__[30] = "switch_core_media_toggle_hold";
  void end = <<< error >>>;

    static const char __func__[30] = "switch_core_media_toggle_hold";
    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_toggle_hold";
    int changed = 0;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
    struct switch_core_session_t * b_session = 0B;
    struct switch_channel_t * b_channel = 0B;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 3872, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if ((unsigned int) switch_core_session_perform_get_partner (session, &b_session, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3882) == 0)
    {
      b_channel = switch_core_session_get_channel (b_session);
    }
  if (sendonly != 0 && switch_channel_test_flag (session->channel, 1) != 0)
    {
      if (switch_channel_test_flag (session->channel, 96) == 0)
        {
          {
            const char * stream;
            const char * msg = (const char *) "hold";
            const char * info;

                        const char * stream;
                        const char * msg = (const char *) "hold";
                        const char * info;
            if ((switch_channel_test_flag (session->channel, 94) != 0 || switch_channel_test_flag (session->channel, 95) != 0) && (b_channel == 0B || switch_channel_test_flag (b_channel, 25) != 0))
              {
                switch_channel_mark_hold (session->channel, (switch_bool_t) sendonly);
                switch_channel_set_flag_value (session->channel, 96, 1);
                changed = 0;
                goto end;
              }
            info = switch_channel_get_variable_dup (session->channel, (const char *) "presence_call_info", 1, -1);
            if (info != 0B)
              {
                if (switch_stristr ((const char *) "private", info) != 0B)
                  {
                    msg = (const char *) "hold-private";
                  }
              }
            if (a_engine->rtp_session != 0B)
              {
                switch_rtp_set_flag (a_engine->rtp_session, 35);
              }
            if (v_engine->rtp_session != 0B)
              {
                switch_rtp_set_flag (v_engine->rtp_session, 35);
              }
            switch_channel_set_flag_value (session->channel, 96, 1);
            switch_channel_mark_hold (session->channel, 1);
            switch_channel_perform_presence (session->channel, (const char *) "unknown", msg, 0B, (const char *) "src/switch_core_media.c", (const char *) &__func__, 3918);
            changed = 1;
            if (a_engine->max_missed_hold_packets != 0 && a_engine->rtp_session != 0B)
              {
                switch_rtp_set_max_missed_packets (a_engine->rtp_session, a_engine->max_missed_hold_packets);
              }
            if ((stream = switch_channel_get_hold_music (session->channel)) == 0B)
              {
                stream = (const char *) "local_stream://moh";
              }
            if ((stream != 0B && strcasecmp (stream, (const char *) "silence") != 0) && (b_channel == 0B || switch_channel_test_flag (b_channel, 25) == 0))
              {
                if (strcasecmp (stream, (const char *) "indicate_hold") == 0)
                  {
                    switch_channel_set_flag_value (session->channel, 16, 1);
                    switch_channel_set_flag_value (session->channel, 10, 1);
                    switch_ivr_hold_uuid ((const char *) switch_core_session_get_uuid (b_session), 0B, 0);
                  }
                else
                  {
                    switch_ivr_broadcast ((const char *) switch_core_session_get_uuid (b_session), stream, 274);
                    switch_sleep (250000);
                  }
              }
          }
        }
    }
  else
    {
      if (switch_channel_test_flag (session->channel, 97) != 0)
        {
          switch_channel_set_flag_value (session->channel, 96, 1);
          switch_channel_mark_hold (session->channel, 1);
          if (a_engine->rtp_session != 0B)
            {
              switch_rtp_set_flag (a_engine->rtp_session, 35);
            }
          if (v_engine->rtp_session != 0B)
            {
              switch_rtp_set_flag (v_engine->rtp_session, 35);
            }
          changed = 1;
        }
      switch_channel_clear_flag (session->channel, 97);
      if (switch_channel_test_flag (session->channel, 96) != 0)
        {
          {
            const char * val;

                        const char * val;
            switch_sleep (250000);
            if (b_channel != 0B && (switch_channel_test_flag (session->channel, 120) != 0 || switch_channel_test_flag (b_channel, 120) != 0))
              {
                switch_ivr_nomedia ((const char *) switch_core_session_get_uuid (session), 1);
              }
            if (a_engine->max_missed_packets != 0 && a_engine->rtp_session != 0B)
              {
                switch_rtp_reset_media_timer (a_engine->rtp_session);
                switch_rtp_set_max_missed_packets (a_engine->rtp_session, a_engine->max_missed_packets);
              }
            if (b_channel != 0B)
              {
                if (switch_channel_test_flag (session->channel, 10) != 0)
                  {
                    switch_ivr_unhold (b_session);
                    switch_channel_clear_flag (session->channel, 16);
                    switch_channel_clear_flag (session->channel, 10);
                  }
                else
                  {
                    <D.39128>:;
                    if (switch_channel_test_flag (b_channel, 21) != 0)
                      {
                        switch_channel_set_flag_value (b_channel, 28, 1);
                        switch_channel_set_flag_value (b_channel, 20, 1);
                      }
                    goto <D.39127>;
                    goto <D.39128>;
                    <D.39127>:;
                    switch_channel_wait_for_flag (b_channel, 21, 0, 5000, 0B);
                  }
              }
            if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0)) && switch_channel_test_flag (session->channel, 106) == 0)
              {
                if (a_engine->rtp_session != 0B)
                  {
                    switch_rtp_set_flag (a_engine->rtp_session, 7);
                  }
                if (v_engine->rtp_session != 0B)
                  {
                    switch_rtp_set_flag (v_engine->rtp_session, 7);
                  }
              }
            switch_channel_clear_flag (session->channel, 96);
            switch_channel_mark_hold (session->channel, 0);
            switch_channel_perform_presence (session->channel, (const char *) "unknown", (const char *) "unhold", 0B, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4004);
            switch_rtp_clear_flag (a_engine->rtp_session, 35);
            if (v_engine->rtp_session != 0B)
              {
                switch_rtp_clear_flag (v_engine->rtp_session, 35);
              }
            changed = 1;
          }
        }
    }
  end:;
  if (b_session != 0B)
    {
      switch_core_session_rwunlock (b_session);
    }
  return changed;
}



;; Function video_helper_thread (null)
;; enabled by -tree-original

{
  struct media_helper * mh = (struct media_helper *) obj;
  struct switch_core_session_t * session = mh->session;
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  switch_status_t status;
  struct switch_frame_t * read_frame;
  struct switch_media_handle_t * smh;
  static const char __func__[20] = "video_helper_thread";

    static const char __func__[20] = "video_helper_thread";
    struct media_helper * mh = (struct media_helper *) obj;
    struct switch_core_session_t * session = mh->session;
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    switch_status_t status;
    struct switch_frame_t * read_frame;
    struct switch_media_handle_t * smh;
  if ((smh = session->media_handle) == 0B)
    {
      return 0B;
    }
  switch_core_session_read_lock (session);
  mh->up = 1;
  switch_mutex_lock (mh->cond_mutex);
  switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4044, 0B, 7, (const char *) "%s Video thread started. Echo is %s\n", switch_channel_get_name (session->channel), switch_channel_test_flag (channel, 115) != 0 ? (char *) "on" : (char *) "off");
  switch_core_session_refresh_video (session);
  goto <D.39140>;
  <D.39141>:;
  if (switch_channel_test_flag (channel, 113) != 0)
    {
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4051, 0B, 7, (const char *) "%s Video thread paused. Echo is %s\n", switch_channel_get_name (session->channel), switch_channel_test_flag (channel, 115) != 0 ? (char *) "on" : (char *) "off");
      switch_thread_cond_wait (mh->cond, mh->cond_mutex);
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4054, 0B, 7, (const char *) "%s Video thread resumed  Echo is %s\n", switch_channel_get_name (session->channel), switch_channel_test_flag (channel, 115) != 0 ? (char *) "on" : (char *) "off");
      switch_core_session_refresh_video (session);
    }
  if (switch_channel_test_flag (channel, 113) != 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.39140>;
    }
  if (switch_channel_test_flag (session->channel, 1) == 0 && switch_channel_test_flag (session->channel, 3) == 0)
    {
      switch_sleep (10000);
      // predicted unlikely by continue predictor.;
      goto <D.39140>;
    }
  status = switch_core_session_read_video_frame (session, &read_frame, 0, 0);
  if (((unsigned int) status != 0 && (unsigned int) status != 11) && (unsigned int) status != 10)
    {
      switch_cond_next ();
      // predicted unlikely by continue predictor.;
      goto <D.39140>;
    }
  if (switch_channel_test_flag (channel, 70) != 0)
    {
      switch_core_session_refresh_video (session);
      switch_channel_clear_flag (channel, 70);
    }
  if ((int) read_frame->flags & 1)
    {
      // predicted unlikely by continue predictor.;
      goto <D.39140>;
    }
  if (switch_channel_test_flag (channel, 115) != 0)
    {
      switch_core_session_write_video_frame (session, read_frame, 0, 0);
    }
  <D.39140>:;
  if ((unsigned int) switch_channel_get_state (channel) <= 9) goto <D.39141>; else goto <D.39142>;
  <D.39142>:;
  switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4093, 0B, 7, (const char *) "%s Video thread ended\n", switch_channel_get_name (session->channel));
  switch_mutex_unlock (mh->cond_mutex);
  switch_core_session_rwunlock (session);
  mh->up = 0;
  return 0B;
}



;; Function start_video_thread (null)
;; enabled by -tree-original

{
  struct switch_threadattr_t * thd_attr = 0B;
  struct switch_memory_pool_t * pool = switch_core_session_get_pool (session);
  struct switch_rtp_engine_t * v_engine = 0B;
  struct switch_media_handle_t * smh;
  static const char __func__[19] = "start_video_thread";

    static const char __func__[19] = "start_video_thread";
    struct switch_threadattr_t * thd_attr = 0B;
    struct switch_memory_pool_t * pool = switch_core_session_get_pool (session);
    struct switch_rtp_engine_t * v_engine = 0B;
    struct switch_media_handle_t * smh;
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (v_engine->media_thread != 0B)
    {
      return 1;
    }
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4120, (const char *) session, 5, (const char *) "%s Starting Video thread\n", switch_channel_get_name (switch_core_session_get_channel (session)));
  switch_rtp_set_default_payload (v_engine->rtp_session, v_engine->cur_payload_map->agreed_pt);
  v_engine->mh.session = session;
  switch_threadattr_create (&thd_attr, pool);
  switch_threadattr_stacksize_set (thd_attr, 245760);
  switch_thread_cond_create (&v_engine->mh.cond, pool);
  switch_mutex_init (&v_engine->mh.cond_mutex, 1, pool);
  switch_mutex_init ((struct switch_mutex_t * *) &v_engine->read_mutex + 4, 1, pool);
  switch_thread_create (&v_engine->media_thread, thd_attr, video_helper_thread, (void *) &v_engine->mh, switch_core_session_get_pool (session));
  return 0;
}



;; Function switch_core_media_proxy_remote_addr (null)
;; enabled by -tree-original

{
  const char * err;
  char rip[512] = "";
  char rp[512] = "";
  char rvp[512] = "";
  char * p;
  char * ip_ptr = 0B;
  char * port_ptr = 0B;
  char * vid_port_ptr = 0B;
  char * pe;
  int x;
  const char * val;
  switch_status_t status = 1;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[36] = "switch_core_media_proxy_remote_addr";
  void end = <<< error >>>;
  static const char __func__[36] = "switch_core_media_proxy_remote_addr";

    static const char __func__[36] = "switch_core_media_proxy_remote_addr";
    static const char __PRETTY_FUNCTION__[36] = "switch_core_media_proxy_remote_addr";
    const char * err;
    char rip[512] = "";
    char rp[512] = "";
    char rvp[512] = "";
    char * p;
    char * ip_ptr = 0B;
    char * port_ptr = 0B;
    char * vid_port_ptr = 0B;
    char * pe;
    int x;
    const char * val;
    switch_status_t status = 1;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4152, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (_zstr (sdp_str) != 0)
    {
      sdp_str = (const char *) smh->mparams->remote_sdp_str;
    }
  if (_zstr (sdp_str) != 0)
    {
      goto end;
    }
  if ((p = (char *) switch_stristr ((const char *) "c=IN IP4 ", sdp_str)) != 0B || (p = (char *) switch_stristr ((const char *) "c=IN IP6 ", sdp_str)) != 0B)
    {
      ip_ptr = p + 9;
    }
  if ((p = (char *) switch_stristr ((const char *) "m=audio ", sdp_str)) != 0B)
    {
      port_ptr = p + 8;
    }
  if ((p = (char *) switch_stristr ((const char *) "m=image ", sdp_str)) != 0B)
    {
      {
        char * tmp = p + 8;

                char * tmp = p + 8;
        if (tmp != 0B && atoi ((const char *) tmp) != 0)
          {
            port_ptr = tmp;
          }
      }
    }
  if ((p = (char *) switch_stristr ((const char *) "m=video ", sdp_str)) != 0B)
    {
      vid_port_ptr = p + 8;
    }
  if (ip_ptr == 0B || port_ptr == 0B)
    {
      goto end;
    }
  p = ip_ptr;
  pe = p + (unsigned int) strlen ((const char *) p);
  x = 0;
  goto <D.39174>;
  <D.39173>:;
  rip[x++ ] = *p;
  p++ ;
  if (p >= pe)
    {
      goto end;
    }
  <D.39174>:;
  if ((((unsigned int) x <= 510 && p != 0B) && (unsigned char) *p != 0) && ((((SAVE_EXPR <*p> + 208 <= 9 || SAVE_EXPR <*p> == 46) || (unsigned char) *p == 58) || *p + 159 <= 5) || *p + 191 <= 5)) goto <D.39173>; else goto <D.39175>;
  <D.39175>:;
  p = port_ptr;
  x = 0;
  goto <D.39177>;
  <D.39176>:;
  rp[x++ ] = *p;
  p++ ;
  if (p >= pe)
    {
      goto end;
    }
  <D.39177>:;
  if ((((unsigned int) x <= 510 && p != 0B) && (unsigned char) *p != 0) && *p + 208 <= 9) goto <D.39176>; else goto <D.39178>;
  <D.39178>:;
  p = vid_port_ptr;
  x = 0;
  goto <D.39180>;
  <D.39179>:;
  rvp[x++ ] = *p;
  p++ ;
  if (p >= pe)
    {
      goto end;
    }
  <D.39180>:;
  if ((((unsigned int) x <= 510 && p != 0B) && (unsigned char) *p != 0) && *p + 208 <= 9) goto <D.39179>; else goto <D.39181>;
  <D.39181>:;
  if ((unsigned char) *(char *) &rip == 0 || (unsigned char) *(char *) &rp == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4225, (const char *) session, 3, (const char *) "invalid SDP\n");
      goto end;
    }
  a_engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (session, (const char *) &rip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4229);
  a_engine->cur_payload_map->remote_sdp_port = (short unsigned int) atoi ((const char *) &rp);
  if ((unsigned char) *(char *) &rvp != 0)
    {
      v_engine->cur_payload_map->remote_sdp_ip = switch_core_perform_session_strdup (session, (const char *) &rip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4233);
      v_engine->cur_payload_map->remote_sdp_port = (short unsigned int) atoi ((const char *) &rvp);
      switch_channel_set_flag_value (session->channel, 98, 1);
      switch_channel_set_flag_value (session->channel, 23, 1);
    }
  if (v_engine->cur_payload_map->remote_sdp_ip != 0B && (short unsigned int) v_engine->cur_payload_map->remote_sdp_port != 0)
    {
      if (TARGET_EXPR <D.39191, {
        size_t __s1_len;
        size_t __s2_len;

                size_t __s1_len;
                size_t __s2_len;
        D.39191 = __builtin_strcmp ((const char *) v_engine->cur_payload_map->remote_sdp_ip, (const char *) &rip);
      }> == 0 && atoi ((const char *) &rvp) == (int) v_engine->cur_payload_map->remote_sdp_port)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4241, (const char *) session, 7, (const char *) "Remote video address:port [%s:%d] has not changed.\n", v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port);
        }
      else
        {
          switch_channel_set_flag_value (session->channel, 98, 1);
          switch_channel_set_flag_value (session->channel, 23, 1);
          if ((unsigned char) switch_rtp_ready (v_engine->rtp_session) != 0)
            {
              {
                const char * rport = 0B;
                switch_port_t remote_rtcp_port = v_engine->remote_rtcp_port;

                                const char * rport = 0B;
                                switch_port_t remote_rtcp_port = v_engine->remote_rtcp_port;
                if ((short unsigned int) remote_rtcp_port == 0)
                  {
                    if ((rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_video_rtcp_port", 1, -1)) != 0B)
                      {
                        remote_rtcp_port = (short unsigned int) atoi (rport);
                      }
                  }
                if ((unsigned int) switch_rtp_set_remote_address (v_engine->rtp_session, (const char *) v_engine->cur_payload_map->remote_sdp_ip, v_engine->cur_payload_map->remote_sdp_port, remote_rtcp_port, 1, &err) != 0)
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4259, (const char *) session, 3, (const char *) "VIDEO RTP REPORTS ERROR: [%s]\n", err);
                  }
                else
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4261, (const char *) session, 7, (const char *) "VIDEO RTP CHANGING DEST TO: [%s:%d]\n", v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port);
                    if ((((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 15) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0)) && switch_channel_test_flag (session->channel, 106) == 0)
                      {
                        switch_rtp_set_flag (v_engine->rtp_session, 7);
                        start_video_thread (session);
                      }
                    if ((int) switch_media_handle_test_media_flag (smh, 2) != 0)
                      {
                        v_engine->check_frames = 0;
                      }
                  }
              }
            }
        }
    }
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      {
        char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
        switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
        const char * rport = 0B;
        switch_port_t remote_rtcp_port = 0;

                char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
                switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
                const char * rport = 0B;
                switch_port_t remote_rtcp_port = 0;
        if (((remote_host != 0B && (short unsigned int) remote_port != 0) && TARGET_EXPR <D.39206, {
          size_t __s1_len;
          size_t __s2_len;

                    size_t __s1_len;
                    size_t __s2_len;
          D.39206 = __builtin_strcmp ((const char *) remote_host, (const char *) a_engine->cur_payload_map->remote_sdp_ip);
        }> == 0) && (short unsigned int) a_engine->cur_payload_map->remote_sdp_port == (short unsigned int) remote_port)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4286, (const char *) session, 7, (const char *) "Remote address:port [%s:%d] has not changed.\n", a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
            status = 11;
            goto end;
          }
        else
          {
            if (remote_host != 0B && (TARGET_EXPR <D.39215, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39215 = __s2_len = 7;, __s2_len <= 3; ? TARGET_EXPR <D.39214, {
                const unsigned char * __s1 = (const unsigned char *) remote_host;
                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";

                                const unsigned char * __s1 = (const unsigned char *) remote_host;
                                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";
                {
                  if (__s2_len != 0 && __result == 0)
                    {
                      __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "0.0.0.0" + 1);
                      if (__s2_len > 1 && __result == 0)
                        {
                          __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "0.0.0.0" + 2);
                          if (__s2_len > 2 && __result == 0)
                            {
                              __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "0.0.0.0" + 3);
                            }
                        }
                    }
                }
                D.39214 = __result;
              }> : __builtin_strcmp ((const char *) remote_host, (const char *) "0.0.0.0");
            }> == 0 || TARGET_EXPR <D.39224, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39224 = __s2_len = 7;, __s2_len <= 3; ? TARGET_EXPR <D.39223, {
                const unsigned char * __s1 = (const unsigned char *) a_engine->cur_payload_map->remote_sdp_ip;
                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";

                                const unsigned char * __s1 = (const unsigned char *) a_engine->cur_payload_map->remote_sdp_ip;
                                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";
                {
                  if (__s2_len != 0 && __result == 0)
                    {
                      __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "0.0.0.0" + 1);
                      if (__s2_len > 1 && __result == 0)
                        {
                          __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "0.0.0.0" + 2);
                          if (__s2_len > 2 && __result == 0)
                            {
                              __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "0.0.0.0" + 3);
                            }
                        }
                    }
                }
                D.39223 = __result;
              }> : __builtin_strcmp ((const char *) a_engine->cur_payload_map->remote_sdp_ip, (const char *) "0.0.0.0");
            }> == 0))
              {
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4292, (const char *) session, 7, (const char *) "Remote address changed from [%s] to [%s]. Ignoring...\n", a_engine->cur_payload_map->remote_sdp_ip, remote_host);
                status = 11;
                goto end;
              }
          }
        if ((rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_audio_rtcp_port", 1, -1)) != 0B)
          {
            remote_rtcp_port = (short unsigned int) atoi (rport);
          }
        if ((unsigned int) switch_rtp_set_remote_address (a_engine->rtp_session, (const char *) a_engine->cur_payload_map->remote_sdp_ip, a_engine->cur_payload_map->remote_sdp_port, remote_rtcp_port, 1, &err) != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4305, (const char *) session, 3, (const char *) "AUDIO RTP REPORTS ERROR: [%s]\n", err);
            status = 9;
          }
        else
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4308, (const char *) session, 7, (const char *) "AUDIO RTP CHANGING DEST TO: [%s:%d]\n", a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
            if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0)) && switch_channel_test_flag (session->channel, 106) == 0)
              {
                switch_rtp_set_flag (a_engine->rtp_session, 7);
              }
            if ((int) switch_media_handle_test_media_flag (smh, 2) != 0)
              {
                a_engine->check_frames = 0;
              }
            status = 0;
          }
      }
    }
  end:;
  return status;
}



;; Function switch_core_media_check_nat (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_check_nat";

    static const char __PRETTY_FUNCTION__[28] = "switch_core_media_check_nat";
  if (network_ip == 0B)
    {
      __assert_fail ((const char *) "network_ip", (const char *) "src/switch_core_media.c", 4331, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  return (smh->mparams->extsipip != 0B && (unsigned int) switch_check_network_list_ip_token (network_ip, (const char *) "loopback.auto", 0B) == 0) && (unsigned int) switch_check_network_list_ip_token (network_ip, (const char *) smh->mparams->local_network, 0B) == 0;
}



;; Function switch_core_media_ext_address_lookup (null)
;; enabled by -tree-original

{
  char * error = (char *) "";
  switch_status_t status = 1;
  int x;
  switch_port_t myport = *port;
  switch_port_t stun_port = 3478;
  char * stun_ip = 0B;
  struct switch_media_handle_t * smh;
  struct switch_memory_pool_t * pool = switch_core_session_get_pool (session);
  static const char __PRETTY_FUNCTION__[37] = "switch_core_media_ext_address_lookup";
  static const char __func__[37] = "switch_core_media_ext_address_lookup";
  void out = <<< error >>>;

    static const char __func__[37] = "switch_core_media_ext_address_lookup";
    static const char __PRETTY_FUNCTION__[37] = "switch_core_media_ext_address_lookup";
    char * error = (char *) "";
    switch_status_t status = 1;
    int x;
    switch_port_t myport = *port;
    switch_port_t stun_port = 3478;
    char * stun_ip = 0B;
    struct switch_media_handle_t * smh;
    struct switch_memory_pool_t * pool = switch_core_session_get_pool (session);
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4351, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if (sourceip == 0B)
    {
      return status;
    }
  if (strncasecmp (sourceip, (const char *) "host:", 5) == 0)
    {
      status = (*ip = switch_stun_host_lookup (sourceip + 5, pool)) == 0B;
    }
  else
    {
      if (strncasecmp (sourceip, (const char *) "stun:", 5) == 0)
        {
          {
            char * p;

                        char * p;
            stun_ip = __strdup (sourceip + 5);
            if ((p = __builtin_strchr ((const char *) stun_ip, 58)) != 0B)
              {
                {
                  int iport;

                                    int iport;
                  *p++  = 0;
                  iport = atoi ((const char *) p);
                  if ((unsigned int) iport + 4294967295 <= 65533)
                    {
                      stun_port = (short unsigned int) iport;
                    }
                }
              }
            if (_zstr ((const char *) stun_ip) != 0)
              {
                switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4378, 0B, 3, (const char *) "STUN Failed! NO STUN SERVER\n");
                goto out;
              }
            x = 0;
            goto <D.39254>;
            <D.39253>:;
            if ((unsigned int) (status = switch_stun_lookup (ip, port, stun_ip, stun_port, &error, pool)) != 0)
              {
                switch_sleep (100000);
              }
            else
              {
                goto <D.39252>;
              }
            x++ ;
            <D.39254>:;
            if (x <= 4) goto <D.39253>; else goto <D.39252>;
            <D.39252>:;
            if ((unsigned int) status != 0)
              {
                switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4390, 0B, 3, (const char *) "STUN Failed! %s:%d [%s]\n", stun_ip, (int) stun_port, error);
                goto out;
              }
            if (*ip == 0B)
              {
                switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4394, 0B, 3, (const char *) "STUN Failed! No IP returned\n");
                goto out;
              }
            switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4397, 0B, 7, (const char *) "STUN Success [%s]:[%d]\n", *ip, (int) *port);
            status = 0;
            if ((short unsigned int) *port == (short unsigned int) myport && TARGET_EXPR <D.39263, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39263 = __builtin_strcmp ((const char *) *ip, (const char *) smh->mparams->rtpip);
            }> == 0)
              {
                switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4401, 0B, 7, (const char *) "STUN Not Required ip and port match. [%s]:[%d]\n", *ip, (int) *port);
              }
            else
              {
                smh->mparams->stun_ip = switch_core_perform_session_strdup (session, (const char *) stun_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4403);
                smh->mparams->stun_port = stun_port;
                smh->mparams->stun_flags = smh->mparams->stun_flags | 1;
              }
          }
        }
      else
        {
          *ip = (char *) sourceip;
          status = 0;
        }
    }
  out:;
  if (stun_ip != 0B)
    {
      free ((void *) stun_ip);
      stun_ip = 0B;
    }
  return status;
}



;; Function switch_core_media_reset_autofix (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_reset_autofix";

    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_reset_autofix";
    struct switch_rtp_engine_t * engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4425, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  engine->check_frames = 0;
  engine->last_ts = 0;
}



;; Function switch_core_media_choose_port (null)
;; enabled by -tree-original

{
  char * lookup_rtpip;
  switch_port_t sdp_port;
  const char * use_ip = 0B;
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  const char * tstr = switch_media_type2str (type);
  char vname[128] = "";
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_choose_port";
  static const char __func__[30] = "switch_core_media_choose_port";

    static const char __func__[30] = "switch_core_media_choose_port";
    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_choose_port";
    char * lookup_rtpip;
    switch_port_t sdp_port;
    const char * use_ip = 0B;
    struct switch_rtp_engine_t * engine;
    struct switch_media_handle_t * smh;
    const char * tstr = switch_media_type2str (type);
    char vname[128] = "";
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4450, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  lookup_rtpip = smh->mparams->rtpip;
  if (force == 0)
    {
      if ((switch_channel_test_flag (session->channel, 15) != 0 || switch_channel_test_flag (session->channel, 29) != 0) || (short unsigned int) engine->adv_sdp_port != 0)
        {
          return 0;
        }
    }
  if ((short unsigned int) engine->local_sdp_port != 0)
    {
      switch_rtp_release_port ((const char *) smh->mparams->rtpip, engine->local_sdp_port);
    }
  if ((short unsigned int) (engine->local_sdp_port = switch_rtp_request_port ((const char *) smh->mparams->rtpip)) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4475, (const char *) session, 2, (const char *) "No %s RTP ports available!\n", tstr);
      return 1;
    }
  engine->local_sdp_ip = smh->mparams->rtpip;
  sdp_port = engine->local_sdp_port;
  if (_zstr ((const char *) smh->mparams->remote_ip) == 0 && switch_core_media_check_nat (smh, (const char *) smh->mparams->remote_ip) != 0)
    {
      switch_nat_add_mapping (engine->local_sdp_port, 0, &sdp_port, 0);
      switch_snprintf ((char *) &vname, 128, (const char *) "rtp_adv_%s_ip", tstr);
      if ((use_ip = switch_channel_get_variable_dup (session->channel, (const char *) &vname, 1, -1)) == 0B && _zstr ((const char *) smh->mparams->extrtpip) == 0)
        {
          use_ip = (const char *) smh->mparams->extrtpip;
        }
      if (use_ip != 0B)
        {
          if ((unsigned int) switch_core_media_ext_address_lookup (session, &lookup_rtpip, &sdp_port, use_ip) != 0)
            {
              return 1;
            }
          else
            {
              use_ip = (const char *) lookup_rtpip;
            }
        }
      else
        {
          use_ip = (const char *) smh->mparams->rtpip;
        }
    }
  else
    {
      use_ip = (const char *) smh->mparams->rtpip;
    }
  engine->adv_sdp_port = sdp_port;
  engine->adv_sdp_ip = smh->mparams->adv_sdp_audio_ip = smh->mparams->extrtpip = switch_core_perform_session_strdup (session, use_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4515);
  if ((unsigned int) type == 0)
    {
      switch_channel_set_variable_var_check (session->channel, (const char *) "local_media_ip", (const char *) engine->local_sdp_ip, 1);
      switch_channel_set_variable_printf (session->channel, (const char *) "local_media_port", (const char *) "%d", (int) sdp_port);
      switch_channel_set_variable_var_check (session->channel, (const char *) "advertised_media_ip", (const char *) engine->adv_sdp_ip, 1);
    }
  else
    {
      switch_channel_set_variable_var_check (session->channel, (const char *) "local_video_ip", (const char *) engine->adv_sdp_ip, 1);
      switch_channel_set_variable_printf (session->channel, (const char *) "local_video_port", (const char *) "%d", (int) sdp_port);
    }
  return 0;
}



;; Function switch_core_media_choose_ports (null)
;; enabled by -tree-original

{
  switch_status_t status = 0;

    switch_status_t status = 0;
  if ((unsigned int) audio != 0 && (unsigned int) (status = switch_core_media_choose_port (session, 0, 0)) == 0)
    {
      if ((unsigned int) video != 0)
        {
          switch_core_media_check_video_codecs (session);
          if (switch_channel_test_flag (session->channel, 98) != 0)
            {
              switch_core_media_choose_port (session, 1, 0);
            }
        }
    }
  return status;
}



;; Function switch_core_media_deactivate_rtp (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_deactivate_rtp";

    static const char __PRETTY_FUNCTION__[33] = "switch_core_media_deactivate_rtp";
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4554, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (v_engine->media_thread != 0B)
    {
      {
        switch_status_t st;

                switch_status_t st;
        switch_channel_clear_flag (session->channel, 113);
        v_engine->mh.up = 0;
        switch_thread_join (&st, v_engine->media_thread);
        v_engine->media_thread = 0B;
      }
    }
  if (v_engine->rtp_session != 0B)
    {
      switch_rtp_destroy (&v_engine->rtp_session);
    }
  else
    {
      if ((short unsigned int) v_engine->local_sdp_port != 0)
        {
          switch_rtp_release_port ((const char *) smh->mparams->rtpip, v_engine->local_sdp_port);
        }
    }
  if (((short unsigned int) v_engine->local_sdp_port != 0 && _zstr ((const char *) smh->mparams->remote_ip) == 0) && switch_core_media_check_nat (smh, (const char *) smh->mparams->remote_ip) != 0)
    {
      switch_nat_del_mapping (v_engine->local_sdp_port, 0);
      switch_nat_del_mapping (v_engine->local_sdp_port + 1, 0);
    }
  if (a_engine->rtp_session != 0B)
    {
      switch_rtp_destroy (&a_engine->rtp_session);
    }
  else
    {
      if ((short unsigned int) a_engine->local_sdp_port != 0)
        {
          switch_rtp_release_port ((const char *) smh->mparams->rtpip, a_engine->local_sdp_port);
        }
    }
  if (((short unsigned int) a_engine->local_sdp_port != 0 && _zstr ((const char *) smh->mparams->remote_ip) == 0) && switch_core_media_check_nat (smh, (const char *) smh->mparams->remote_ip) != 0)
    {
      switch_nat_del_mapping (a_engine->local_sdp_port, 0);
      switch_nat_del_mapping (a_engine->local_sdp_port + 1, 0);
    }
}



;; Function gen_ice (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * engine;
  char tmp[33] = "";
  static const char __PRETTY_FUNCTION__[8] = "gen_ice";
  static const char __func__[8] = "gen_ice";

    static const char __func__[8] = "gen_ice";
    static const char __PRETTY_FUNCTION__[8] = "gen_ice";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * engine;
    char tmp[33] = "";
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4608, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  if ((signed char) engine->rtcp_mux == 0)
    {
      engine->rtcp_mux = 1;
    }
  if (smh->msid == 0B)
    {
      switch_stun_random_string ((char *) &tmp, 32, 0B);
      tmp[32] = 0;
      smh->msid = switch_core_perform_session_strdup (session, (const char *) &tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4625);
    }
  if (smh->cname == 0B)
    {
      switch_stun_random_string ((char *) &tmp, 16, 0B);
      tmp[16] = 0;
      smh->cname = switch_core_perform_session_strdup (session, (const char *) &tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4631);
    }
  if (engine->ice_out.ufrag == 0B)
    {
      switch_stun_random_string ((char *) &tmp, 16, 0B);
      tmp[16] = 0;
      engine->ice_out.ufrag = switch_core_perform_session_strdup (session, (const char *) &tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4637);
    }
  if (engine->ice_out.pwd == 0B)
    {
      switch_stun_random_string ((char *) &tmp, 16, 0B);
      engine->ice_out.pwd = switch_core_perform_session_strdup (session, (const char *) &tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4642);
    }
  if (engine->ice_out.cands[0][0].foundation == 0B)
    {
      switch_stun_random_string ((char *) &tmp, 10, (char *) "0123456789");
      tmp[10] = 0;
      engine->ice_out.cands[0][0].foundation = switch_core_perform_session_strdup (session, (const char *) &tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4648);
    }
  engine->ice_out.cands[0][0].transport = (char *) "udp";
  if (engine->ice_out.cands[0][0].component_id == 0)
    {
      engine->ice_out.cands[0][0].component_id = 1;
      engine->ice_out.cands[0][0].priority = (uint32_t) ((329569 - engine->ice_out.cands[0][0].component_id) * 2);
    }
  if (_zstr (ip) == 0)
    {
      engine->ice_out.cands[0][0].con_addr = switch_core_perform_session_strdup (session, ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4659);
    }
  if ((short unsigned int) port != 0)
    {
      engine->ice_out.cands[0][0].con_port = port;
    }
  engine->ice_out.cands[0][0].generation = (char *) "0";
  engine->ice_out.cands[0][0].ready = 1;
}



;; Function switch_core_session_wake_video_thread (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * v_engine;

    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * v_engine;
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (v_engine->rtp_session == 0B)
    {
      return;
    }
  if ((unsigned int) switch_mutex_trylock (v_engine->mh.cond_mutex) == 0)
    {
      switch_thread_cond_broadcast (v_engine->mh.cond);
      switch_mutex_unlock (v_engine->mh.cond_mutex);
    }
}



;; Function check_dtls_reinvite (null)
;; enabled by -tree-original

{
  static const char __func__[20] = "check_dtls_reinvite";

    static const char __func__[20] = "check_dtls_reinvite";
  if (switch_channel_test_flag (session->channel, 103) != 0)
    {
      if ((_zstr ((const char *) &engine->local_dtls_fingerprint.str) == 0 && switch_rtp_has_dtls () != 0) && dtls_ok (session) != 0)
        {
          {
            dtls_type_t xtype;
            dtls_type_t dtype = (unsigned int) switch_ice_direction (session) == 0 ? 1 : 2;

                        dtls_type_t xtype;
                        dtls_type_t dtype = (unsigned int) switch_ice_direction (session) == 0 ? 1 : 2;
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4701, (const char *) session, 6, (const char *) "RE-SETTING %s DTLS\n", (unsigned int) engine->type == 1 ? (char *) "video" : (char *) "audio");
            xtype = 4;
            if ((signed char) engine->rtcp_mux > 0)
              {
                xtype = (dtls_type_t) ((unsigned int) xtype | 8);
              }
            switch_rtp_add_dtls (engine->rtp_session, &engine->local_dtls_fingerprint, &engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
            if ((signed char) engine->rtcp_mux <= 0)
              {
                xtype = 8;
                switch_rtp_add_dtls (engine->rtp_session, &engine->local_dtls_fingerprint, &engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
              }
          }
        }
    }
}



;; Function switch_core_media_activate_rtp (null)
;; enabled by -tree-original

{
  const char * err = 0B;
  const char * val = 0B;
  switch_rtp_flag_t flags[39] = {0};
  switch_status_t status = 0;
  char tmp[50];
  char * timer_name = 0B;
  const char * var;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_activate_rtp";
  void end = <<< error >>>;
  void video = <<< error >>>;
  static const char __func__[31] = "switch_core_media_activate_rtp";
  void video_up = <<< error >>>;

    static const char __func__[31] = "switch_core_media_activate_rtp";
    static const char __PRETTY_FUNCTION__[31] = "switch_core_media_activate_rtp";
    const char * err = 0B;
    const char * val = 0B;
    switch_rtp_flag_t flags[39] = {0};
    switch_status_t status = 0;
    char tmp[50];
    char * timer_name = 0B;
    const char * var;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 4731, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      return 1;
    }
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      switch_rtp_reset_media_timer (a_engine->rtp_session);
    }
  if ((unsigned int) a_engine->crypto_type != 9)
    {
      switch_channel_set_flag_value (session->channel, 92, 1);
    }
  if (switch_channel_test_flag (session->channel, 15) != 0)
    {
      status = 0;
      goto end;
    }
  if (switch_channel_test_flag (session->channel, 103) == 0)
    {
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          if (switch_channel_test_flag (session->channel, 98) != 0 && (unsigned char) switch_rtp_ready (v_engine->rtp_session) == 0)
            {
              goto video;
            }
          status = 0;
          goto end;
        }
    }
  if ((unsigned int) (status = switch_core_media_set_codec (session, 0, smh->mparams->codec_flags)) != 0)
    {
      goto end;
    }
  switch_core_media_set_video_codec (session, 0);
  memset ((void *) &flags, 0, 156);
  flags[13]++ ;
  if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 106) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0))
    {
      flags[7]++ ;
    }
  if ((int) switch_media_handle_test_media_flag (smh, 11) != 0 || (val = switch_channel_get_variable_dup (session->channel, (const char *) "pass_rfc2833", 1, -1)) != 0B && switch_true (val) != 0)
    {
      switch_channel_set_flag_value (session->channel, 100, 1);
    }
  if ((int) switch_media_handle_test_media_flag (smh, 12) != 0 || (val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_autoflush", 1, -1)) != 0B && switch_true (val) != 0)
    {
      flags[22]++ ;
    }
  if ((int) switch_media_handle_test_media_flag (smh, 13) == 0 && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_rewrite_timestamps", 1, -1)) == 0B || switch_true (val) == 0))
    {
      flags[8]++ ;
    }
  if ((int) switch_media_handle_test_media_flag (smh, 9) != 0)
    {
      smh->mparams->cng_pt = 0;
    }
  else
    {
      if ((unsigned char) smh->mparams->cng_pt != 0)
        {
          flags[16]++ ;
        }
    }
  if (strcasecmp ((const char *) a_engine->read_impl.iananame, (const char *) "L16") == 0)
    {
      flags[14]++ ;
    }
  if (((unsigned int) flags[14] != 0 && (val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_disable_byteswap", 1, -1)) != 0B) && switch_true (val) != 0)
    {
      flags[14] = 0;
    }
  if (a_engine->rtp_session != 0B && switch_channel_test_flag (session->channel, 103) != 0)
    {
      {
        char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
        switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);

                char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
                switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
        if (((remote_host != 0B && (short unsigned int) remote_port != 0) && TARGET_EXPR <D.39348, {
          size_t __s1_len;
          size_t __s2_len;

                    size_t __s1_len;
                    size_t __s2_len;
          D.39348 = __builtin_strcmp ((const char *) remote_host, (const char *) a_engine->cur_payload_map->remote_sdp_ip);
        }> == 0) && (short unsigned int) a_engine->cur_payload_map->remote_sdp_port == (short unsigned int) remote_port)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4825, (const char *) session, 7, (const char *) "Audio params are unchanged for %s.\n", switch_channel_get_name (session->channel));
            goto video;
          }
        else
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4830, (const char *) session, 7, (const char *) "Audio params changed for %s from %s:%d to %s:%d\n", switch_channel_get_name (session->channel), remote_host, (int) remote_port, a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
            switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) a_engine->cur_payload_map->remote_sdp_port);
            switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_ip", (const char *) a_engine->cur_payload_map->remote_sdp_ip, 1);
            switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
          }
      }
    }
  if (switch_channel_test_flag (session->channel, 29) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4841, (const char *) session, 7, (const char *) "AUDIO RTP [%s] %s port %d -> %s port %d codec: %u ms: %d\n", switch_channel_get_name (session->channel), a_engine->local_sdp_ip, (int) a_engine->local_sdp_port, a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port, (int) a_engine->cur_payload_map->agreed_pt, a_engine->read_impl.microseconds_per_packet / 1000);
    }
  switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) a_engine->local_sdp_port);
  switch_channel_set_variable_var_check (session->channel, (const char *) "local_media_ip", (const char *) a_engine->local_sdp_ip, 1);
  switch_channel_set_variable_var_check (session->channel, (const char *) "local_media_port", (const char *) &tmp, 1);
  switch_channel_set_variable_var_check (session->channel, (const char *) "advertised_media_ip", (const char *) a_engine->adv_sdp_ip, 1);
  if (a_engine->rtp_session != 0B && switch_channel_test_flag (session->channel, 103) != 0)
    {
      {
        const char * rport = 0B;
        switch_port_t remote_rtcp_port = a_engine->remote_rtcp_port;

                const char * rport = 0B;
                switch_port_t remote_rtcp_port = a_engine->remote_rtcp_port;
        if ((short unsigned int) remote_rtcp_port == 0)
          {
            if ((rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_audio_rtcp_port", 1, -1)) != 0B)
              {
                remote_rtcp_port = (short unsigned int) atoi (rport);
              }
          }
        if ((unsigned int) switch_rtp_set_remote_address (a_engine->rtp_session, (const char *) a_engine->cur_payload_map->remote_sdp_ip, a_engine->cur_payload_map->remote_sdp_port, remote_rtcp_port, 1, &err) != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4868, (const char *) session, 3, (const char *) "AUDIO RTP REPORTS ERROR: [%s]\n", err);
          }
        else
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4870, (const char *) session, 7, (const char *) "AUDIO RTP CHANGING DEST TO: [%s:%d]\n", a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port);
            if (switch_channel_test_flag (session->channel, 96) != 0 && TARGET_EXPR <D.39360, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39360 = __s2_len = 7;, __s2_len <= 3; ? TARGET_EXPR <D.39359, {
                const unsigned char * __s1 = (const unsigned char *) a_engine->cur_payload_map->remote_sdp_ip;
                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";

                                const unsigned char * __s1 = (const unsigned char *) a_engine->cur_payload_map->remote_sdp_ip;
                                register int __result = (int) *__s1 - (int) *(const unsigned char *) "0.0.0.0";
                {
                  if (__s2_len != 0 && __result == 0)
                    {
                      __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "0.0.0.0" + 1);
                      if (__s2_len > 1 && __result == 0)
                        {
                          __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "0.0.0.0" + 2);
                          if (__s2_len > 2 && __result == 0)
                            {
                              __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "0.0.0.0" + 3);
                            }
                        }
                    }
                }
                D.39359 = __result;
              }> : __builtin_strcmp ((const char *) a_engine->cur_payload_map->remote_sdp_ip, (const char *) "0.0.0.0");
            }> != 0)
              {
                switch_core_media_toggle_hold (session, 0);
              }
            if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0)) && switch_channel_test_flag (session->channel, 106) == 0)
              {
                switch_rtp_set_flag (a_engine->rtp_session, 7);
              }
          }
        if (session != 0B && a_engine != 0B)
          {
            check_dtls_reinvite (session, a_engine);
          }
        goto video;
      }
    }
  if (switch_channel_test_flag (session->channel, 29) != 0)
    {
      switch_core_media_proxy_remote_addr (session, 0B);
      memset ((void *) &flags, 0, 156);
      flags[13]++ ;
      flags[19]++ ;
      if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 106) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0))
        {
          flags[7]++ ;
        }
      timer_name = 0B;
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 4906, (const char *) session, 7, (const char *) "PROXY AUDIO RTP [%s] %s:%d->%s:%d codec: %u ms: %d\n", switch_channel_get_name (session->channel), a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port, a_engine->cur_payload_map->remote_sdp_ip, (int) a_engine->cur_payload_map->remote_sdp_port, (int) a_engine->cur_payload_map->agreed_pt, a_engine->read_impl.microseconds_per_packet / 1000);
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          switch_rtp_set_default_payload (a_engine->rtp_session, a_engine->cur_payload_map->agreed_pt);
        }
    }
  else
    {
      timer_name = smh->mparams->timer_name;
      if ((var = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_timer_name", 1, -1)) != 0B)
        {
          timer_name = (char *) var;
        }
    }
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) <= 9)
    {
      a_engine->rtp_session = switch_rtp_new ((const char *) a_engine->local_sdp_ip, a_engine->local_sdp_port, (const char *) a_engine->cur_payload_map->remote_sdp_ip, a_engine->cur_payload_map->remote_sdp_port, a_engine->cur_payload_map->agreed_pt, a_engine->read_impl.samples_per_packet, a_engine->cur_payload_map->codec_ms * 1000, (switch_rtp_flag_t *) &flags, timer_name, &err, switch_core_session_get_pool (session));
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          switch_rtp_set_payload_map (a_engine->rtp_session, &a_engine->payload_map);
        }
    }
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      {
        uint8_t vad_in = (uint8_t) smh->mparams->vflags & 1;
        uint8_t vad_out = (uint8_t) smh->mparams->vflags & 2;
        uint8_t inb = (unsigned int) switch_channel_direction (session->channel) == 0;
        const char * ssrc;

                uint8_t vad_in = (uint8_t) smh->mparams->vflags & 1;
                uint8_t vad_out = (uint8_t) smh->mparams->vflags & 2;
                uint8_t inb = (unsigned int) switch_channel_direction (session->channel) == 0;
                const char * ssrc;
        switch_mutex_init ((struct switch_mutex_t * *) &a_engine->read_mutex, 1, switch_core_session_get_pool (session));
        if ((ssrc = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_ssrc", 1, -1)) != 0B)
          {
            {
              uint32_t ssrc_ul = (unsigned int) strtoul (ssrc, 0B, 10);

                            uint32_t ssrc_ul = (unsigned int) strtoul (ssrc, 0B, 10);
              switch_rtp_set_ssrc (a_engine->rtp_session, ssrc_ul);
              a_engine->ssrc = ssrc_ul;
            }
          }
        else
          {
            switch_rtp_set_ssrc (a_engine->rtp_session, a_engine->ssrc);
          }
        if (a_engine->remote_ssrc != 0)
          {
            switch_rtp_set_remote_ssrc (a_engine->rtp_session, a_engine->remote_ssrc);
          }
        switch_channel_set_flag_value (session->channel, 36, 1);
        switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_pt", (const char *) "%d", (int) a_engine->cur_payload_map->agreed_pt);
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_enable_vad_in", 1, -1)) != 0B && switch_true (val) != 0)
          {
            vad_in = 1;
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_enable_vad_out", 1, -1)) != 0B && switch_true (val) != 0)
          {
            vad_out = 1;
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_disable_vad_in", 1, -1)) != 0B && switch_true (val) != 0)
          {
            vad_in = 0;
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_disable_vad_out", 1, -1)) != 0B && switch_true (val) != 0)
          {
            vad_out = 0;
          }
        a_engine->ssrc = switch_rtp_get_ssrc (a_engine->rtp_session);
        switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_ssrc", (const char *) "%u", a_engine->ssrc);
        if (((unsigned int) smh->mparams->auto_rtp_bugs & 4) != 0)
          {
            a_engine->rtp_bugs = (switch_rtp_bug_flag_t) ((unsigned int) a_engine->rtp_bugs | 4);
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_manual_rtp_bugs", 1, -1)) != 0B)
          {
            switch_core_media_parse_rtp_bugs (&a_engine->rtp_bugs, val);
          }
        switch_rtp_intentional_bugs (a_engine->rtp_session, (switch_rtp_bug_flag_t) ((unsigned int) a_engine->rtp_bugs | (unsigned int) smh->mparams->manual_rtp_bugs));
        if ((unsigned char) vad_in != 0 && (unsigned char) inb != 0 || (unsigned char) vad_out != 0 && (unsigned char) inb == 0)
          {
            switch_rtp_enable_vad (a_engine->rtp_session, session, &a_engine->read_codec, 7);
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5001, (const char *) session, 7, (const char *) "AUDIO RTP Engage VAD for %s ( %s %s )\n", switch_channel_get_name (switch_core_session_get_channel (session)), (unsigned char) vad_in != 0 ? (char *) "in" : (char *) "", (unsigned char) vad_out != 0 ? (char *) "out" : (char *) "");
          }
        if ((unsigned char) a_engine->ice_in.cands[a_engine->ice_in.chosen[0]][0].ready != 0)
          {
            gen_ice (session, 0, 0B, 0);
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5010, (const char *) session, 6, (const char *) "Activating Audio ICE\n");
            switch_rtp_activate_ice (a_engine->rtp_session, a_engine->ice_in.ufrag, a_engine->ice_out.ufrag, (const char *) a_engine->ice_out.pwd, (const char *) a_engine->ice_in.pwd, 0, (unsigned int) switch_ice_direction (session) == 1 ? 2 : 6, &a_engine->ice_in);
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtcp_audio_interval_msec", 1, -1)) != 0B || (val = (const char *) smh->mparams->rtcp_audio_interval_msec) != 0B)
          {
            {
              const char * rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_audio_rtcp_port", 1, -1);
              switch_port_t remote_rtcp_port = a_engine->remote_rtcp_port;

                            const char * rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_audio_rtcp_port", 1, -1);
                            switch_port_t remote_rtcp_port = a_engine->remote_rtcp_port;
              if ((short unsigned int) remote_rtcp_port == 0 && rport != 0B)
                {
                  remote_rtcp_port = (short unsigned int) atoi (rport);
                }
              if (strcasecmp (val, (const char *) "passthru") == 0)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5043, (const char *) session, 6, (const char *) "Activating RTCP PASSTHRU PORT %d\n", (int) remote_rtcp_port);
                  switch_rtp_activate_rtcp (a_engine->rtp_session, -1, remote_rtcp_port, (signed char) a_engine->rtcp_mux > 0);
                }
              else
                {
                  {
                    int interval = atoi (val);

                                        int interval = atoi (val);
                    if ((unsigned int) interval + 4294967196 > 499900)
                      {
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5048, (const char *) session, 3, (const char *) "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);
                        interval = 10000;
                      }
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5053, (const char *) session, 6, (const char *) "Activating RTCP PORT %d\n", (int) remote_rtcp_port);
                    switch_rtp_activate_rtcp (a_engine->rtp_session, interval, remote_rtcp_port, (signed char) a_engine->rtcp_mux > 0);
                  }
                }
              if ((unsigned char) a_engine->ice_in.cands[a_engine->ice_in.chosen[1]][1].ready != 0)
                {
                  if (((signed char) a_engine->rtcp_mux > 0 && TARGET_EXPR <D.39377, {
                    size_t __s1_len;
                    size_t __s2_len;

                                        size_t __s1_len;
                                        size_t __s2_len;
                    D.39377 = __builtin_strcmp ((const char *) a_engine->ice_in.cands[a_engine->ice_in.chosen[1]][1].con_addr, (const char *) a_engine->ice_in.cands[a_engine->ice_in.chosen[0]][0].con_addr);
                  }> == 0) && (short unsigned int) a_engine->ice_in.cands[a_engine->ice_in.chosen[1]][1].con_port == (short unsigned int) a_engine->ice_in.cands[a_engine->ice_in.chosen[0]][0].con_port)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5061, (const char *) session, 6, (const char *) "Skipping RTCP ICE (Same as RTP)\n");
                    }
                  else
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5063, (const char *) session, 6, (const char *) "Activating RTCP ICE\n");
                      switch_rtp_activate_ice (a_engine->rtp_session, a_engine->ice_in.ufrag, a_engine->ice_out.ufrag, (const char *) a_engine->ice_out.pwd, (const char *) a_engine->ice_in.pwd, 1, (unsigned int) switch_ice_direction (session) == 1 ? 2 : 6, &a_engine->ice_in);
                    }
                }
            }
          }
        if ((_zstr ((const char *) &a_engine->local_dtls_fingerprint.str) == 0 && switch_rtp_has_dtls () != 0) && dtls_ok (smh->session) != 0)
          {
            {
              dtls_type_t xtype;
              dtls_type_t dtype = (unsigned int) switch_channel_direction (smh->session->channel) == 0 ? 1 : 2;

                            dtls_type_t xtype;
                            dtls_type_t dtype = (unsigned int) switch_channel_direction (smh->session->channel) == 0 ? 1 : 2;
              if (switch_channel_test_flag (smh->session->channel, 112) != 0)
                {
                  dtype = (unsigned int) dtype == 1 ? 2 : 1;
                }
              xtype = 4;
              if ((signed char) a_engine->rtcp_mux > 0 && smh->mparams->rtcp_audio_interval_msec != 0B)
                {
                  xtype = (dtls_type_t) ((unsigned int) xtype | 8);
                }
              switch_rtp_add_dtls (a_engine->rtp_session, &a_engine->local_dtls_fingerprint, &a_engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
              if ((signed char) a_engine->rtcp_mux <= 0 && smh->mparams->rtcp_audio_interval_msec != 0B)
                {
                  xtype = 8;
                  switch_rtp_add_dtls (a_engine->rtp_session, &a_engine->local_dtls_fingerprint, &a_engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
                }
            }
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "jitterbuffer_msec", 1, -1)) != 0B || (val = (const char *) smh->mparams->jb_msec) != 0B)
          {
            {
              int jb_msec = atoi (val);
              int maxlen = 0;
              int max_drift = 0;
              char * p;
              char * q;

                            int jb_msec = atoi (val);
                            int maxlen = 0;
                            int max_drift = 0;
                            char * p;
                            char * q;
              if ((p = __builtin_strchr (val, 58)) != 0B)
                {
                  p++ ;
                  maxlen = atoi ((const char *) p);
                  if ((q = __builtin_strchr ((const char *) p, 58)) != 0B)
                    {
                      q++ ;
                      max_drift = ABS_EXPR <atoi ((const char *) q)>;
                    }
                }
              if ((unsigned int) jb_msec + 9 <= 8)
                {
                  jb_msec = ((int) a_engine->read_codec.implementation->microseconds_per_packet / 1000) * ABS_EXPR <jb_msec>;
                }
              if ((unsigned int) jb_msec + 4294967276 > 9980)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5125, (const char *) session, 3, (const char *) "Invalid Jitterbuffer spec [%d] must be between 20 and 10000\n", jb_msec);
                }
              else
                {
                  {
                    int qlen;
                    int maxqlen = 50;

                                        int qlen;
                                        int maxqlen = 50;
                    qlen = jb_msec / (a_engine->read_impl.microseconds_per_packet / 1000);
                    if (qlen <= 0)
                      {
                        qlen = 3;
                      }
                    if (maxlen != 0)
                      {
                        maxqlen = maxlen / (a_engine->read_impl.microseconds_per_packet / 1000);
                      }
                    if (maxqlen < qlen)
                      {
                        maxqlen = qlen * 5;
                      }
                    if ((unsigned int) switch_rtp_activate_jitter_buffer (a_engine->rtp_session, (uint32_t) qlen, (uint32_t) maxqlen, a_engine->read_impl.samples_per_packet, a_engine->read_impl.samples_per_second, (uint32_t) max_drift) == 0)
                      {
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5146, (const char *) session, 7, (const char *) "Setting Jitterbuffer to %dms (%d frames)\n", jb_msec, qlen);
                        switch_channel_set_flag_value (session->channel, 57, 1);
                        if (switch_false (switch_channel_get_variable_dup (session->channel, (const char *) "rtp_jitter_buffer_plc", 1, -1)) == 0)
                          {
                            switch_channel_set_flag_value (session->channel, 58, 1);
                          }
                      }
                    else
                      {
                        switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5153, (const char *) session, 4, (const char *) "Error Setting Jitterbuffer to %dms (%d frames)\n", jb_msec, qlen);
                      }
                  }
                }
            }
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_timeout_sec", 1, -1)) != 0B)
          {
            {
              int v = atoi (val);

                            int v = atoi (val);
              if (v >= 0)
                {
                  smh->mparams->rtp_timeout_sec = (uint32_t) v;
                }
            }
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_hold_timeout_sec", 1, -1)) != 0B)
          {
            {
              int v = atoi (val);

                            int v = atoi (val);
              if (v >= 0)
                {
                  smh->mparams->rtp_hold_timeout_sec = (uint32_t) v;
                }
            }
          }
        if (smh->mparams->rtp_timeout_sec != 0)
          {
            a_engine->max_missed_packets = (a_engine->read_impl.samples_per_second * smh->mparams->rtp_timeout_sec) / a_engine->read_impl.samples_per_packet;
            switch_rtp_set_max_missed_packets (a_engine->rtp_session, a_engine->max_missed_packets);
            if (smh->mparams->rtp_hold_timeout_sec == 0)
              {
                smh->mparams->rtp_hold_timeout_sec = smh->mparams->rtp_timeout_sec * 10;
              }
          }
        if (smh->mparams->rtp_hold_timeout_sec != 0)
          {
            a_engine->max_missed_hold_packets = (a_engine->read_impl.samples_per_second * smh->mparams->rtp_hold_timeout_sec) / a_engine->read_impl.samples_per_packet;
          }
        if ((unsigned char) smh->mparams->te != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5188, (const char *) session, 7, (const char *) "Set 2833 dtmf send payload to %u\n", (int) smh->mparams->te);
            switch_rtp_set_telephony_event (a_engine->rtp_session, smh->mparams->te);
            switch_channel_set_variable_printf (session->channel, (const char *) "rtp_2833_send_payload", (const char *) "%d", (int) smh->mparams->te);
          }
        if ((unsigned char) smh->mparams->recv_te != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5194, (const char *) session, 7, (const char *) "Set 2833 dtmf receive payload to %u\n", (int) smh->mparams->recv_te);
            switch_rtp_set_telephony_recv_event (a_engine->rtp_session, smh->mparams->recv_te);
            switch_channel_set_variable_printf (session->channel, (const char *) "rtp_2833_recv_payload", (const char *) "%d", (int) smh->mparams->recv_te);
          }
        if (((int) switch_media_handle_test_media_flag (smh, 9) != 0 || (val = switch_channel_get_variable_dup (session->channel, (const char *) "supress_cng", 1, -1)) != 0B && switch_true (val) != 0) || (val = switch_channel_get_variable_dup (session->channel, (const char *) "suppress_cng", 1, -1)) != 0B && switch_true (val) != 0)
          {
            smh->mparams->cng_pt = 0;
          }
        if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_digit_delay", 1, -1)) != 0B)
          {
            {
              int delayi = atoi (val);

                            int delayi = atoi (val);
              if (delayi < 0)
                {
                  delayi = 0;
                }
              smh->mparams->dtmf_delay = (unsigned int) delayi;
            }
          }
        if (smh->mparams->dtmf_delay != 0)
          {
            switch_rtp_set_interdigit_delay (a_engine->rtp_session, smh->mparams->dtmf_delay);
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5216, (const char *) session, 7, (const char *) "%s Set rtp dtmf delay to %u\n", switch_channel_get_name (session->channel), smh->mparams->dtmf_delay);
          }
        if ((unsigned char) smh->mparams->cng_pt != 0 && (int) switch_media_handle_test_media_flag (smh, 9) == 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5222, (const char *) session, 7, (const char *) "Set comfort noise payload to %u\n", (int) smh->mparams->cng_pt);
            switch_rtp_set_cng_pt (a_engine->rtp_session, smh->mparams->cng_pt);
          }
        switch_core_session_apply_crypto (session, 0);
        switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) a_engine->cur_payload_map->remote_sdp_port);
        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_ip", (const char *) a_engine->cur_payload_map->remote_sdp_ip, 1);
        switch_channel_set_variable_var_check (session->channel, (const char *) "remote_media_port", (const char *) &tmp, 1);
        if (switch_channel_test_flag (session->channel, 74) != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5234, (const char *) session, 6, (const char *) "Activating ZRTP PROXY MODE\n");
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5235, (const char *) session, 7, (const char *) "Disable NOTIMER_DURING_BRIDGE\n");
            switch_channel_clear_flag (session->channel, 99);
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5237, (const char *) session, 7, (const char *) "Activating audio UDPTL mode\n");
            switch_rtp_udptl_mode (a_engine->rtp_session);
          }
        video:;
        if ((unsigned int) switch_channel_direction (session->channel) == 1)
          {
            switch_core_media_check_video_codecs (session);
          }
        if ((switch_channel_test_flag (session->channel, 98) != 0 && v_engine->cur_payload_map->rm_encoding != 0B) && (short unsigned int) v_engine->cur_payload_map->remote_sdp_port != 0)
          {
            if (v_engine->rtp_session != 0B && switch_channel_test_flag (session->channel, 103) != 0)
              {
                {
                  char * remote_host = switch_rtp_get_remote_host (v_engine->rtp_session);
                  switch_port_t remote_port = switch_rtp_get_remote_port (v_engine->rtp_session);

                                    char * remote_host = switch_rtp_get_remote_host (v_engine->rtp_session);
                                    switch_port_t remote_port = switch_rtp_get_remote_port (v_engine->rtp_session);
                  if (((remote_host != 0B && (short unsigned int) remote_port != 0) && TARGET_EXPR <D.39400, {
                    size_t __s1_len;
                    size_t __s2_len;

                                        size_t __s1_len;
                                        size_t __s2_len;
                    D.39400 = __builtin_strcmp ((const char *) remote_host, (const char *) v_engine->cur_payload_map->remote_sdp_ip);
                  }> == 0) && (short unsigned int) v_engine->cur_payload_map->remote_sdp_port == (short unsigned int) remote_port)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5263, (const char *) session, 7, (const char *) "Video params are unchanged for %s.\n", switch_channel_get_name (session->channel));
                      goto video_up;
                    }
                  else
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5267, (const char *) session, 7, (const char *) "Video params changed for %s from %s:%d to %s:%d\n", switch_channel_get_name (session->channel), remote_host, (int) remote_port, v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port);
                    }
                }
              }
            if (switch_channel_test_flag (session->channel, 29) == 0)
              {
                if ((unsigned char) switch_rtp_ready (v_engine->rtp_session) != 0)
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5275, (const char *) session, 7, (const char *) "VIDEO RTP [%s] %s port %d -> %s port %d codec: %u ms: %d\n", switch_channel_get_name (session->channel), a_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->local_sdp_port, v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port, (int) v_engine->cur_payload_map->agreed_pt, a_engine->read_impl.microseconds_per_packet / 1000);
                    start_video_thread (session);
                    switch_rtp_set_default_payload (v_engine->rtp_session, v_engine->cur_payload_map->agreed_pt);
                  }
              }
            switch_snprintf ((char *) &tmp, 50, (const char *) "%d", (int) v_engine->local_sdp_port);
            switch_channel_set_variable_var_check (session->channel, (const char *) "local_video_ip", (const char *) a_engine->adv_sdp_ip, 1);
            switch_channel_set_variable_var_check (session->channel, (const char *) "local_video_port", (const char *) &tmp, 1);
            if (v_engine->rtp_session != 0B && switch_channel_test_flag (session->channel, 103) != 0)
              {
                {
                  const char * rport = 0B;
                  switch_port_t remote_rtcp_port = v_engine->remote_rtcp_port;

                                    const char * rport = 0B;
                                    switch_port_t remote_rtcp_port = v_engine->remote_rtcp_port;
                  if ((short unsigned int) remote_rtcp_port == 0)
                    {
                      if ((rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_video_rtcp_port", 1, -1)) != 0B)
                        {
                          remote_rtcp_port = (short unsigned int) atoi (rport);
                        }
                    }
                  if ((unsigned int) switch_rtp_set_remote_address (v_engine->rtp_session, (const char *) v_engine->cur_payload_map->remote_sdp_ip, v_engine->cur_payload_map->remote_sdp_port, remote_rtcp_port, 1, &err) != 0)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5306, (const char *) session, 3, (const char *) "VIDEO RTP REPORTS ERROR: [%s]\n", err);
                    }
                  else
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5308, (const char *) session, 7, (const char *) "VIDEO RTP CHANGING DEST TO: [%s:%d]\n", v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port);
                      if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 106) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0))
                        {
                          switch_rtp_set_flag (v_engine->rtp_session, 7);
                          start_video_thread (session);
                        }
                    }
                  goto video_up;
                }
              }
            if (switch_channel_test_flag (session->channel, 29) != 0)
              {
                switch_core_media_proxy_remote_addr (session, 0B);
                memset ((void *) &flags, 0, 156);
                flags[19]++ ;
                flags[13]++ ;
                if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 106) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0))
                  {
                    flags[7]++ ;
                  }
                timer_name = 0B;
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5334, (const char *) session, 7, (const char *) "PROXY VIDEO RTP [%s] %s:%d->%s:%d codec: %u ms: %d\n", switch_channel_get_name (session->channel), a_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->local_sdp_port, v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port, (int) v_engine->cur_payload_map->agreed_pt, v_engine->read_impl.microseconds_per_packet / 1000);
                if ((unsigned char) switch_rtp_ready (v_engine->rtp_session) != 0)
                  {
                    switch_rtp_set_default_payload (v_engine->rtp_session, v_engine->cur_payload_map->agreed_pt);
                  }
              }
            else
              {
                timer_name = smh->mparams->timer_name;
                if ((var = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_timer_name", 1, -1)) != 0B)
                  {
                    timer_name = (char *) var;
                  }
              }
            if (v_engine->rtp_session != 0B)
              {
                goto video_up;
              }
            if ((short unsigned int) v_engine->local_sdp_port == 0)
              {
                switch_core_media_choose_port (session, 1, 1);
              }
            memset ((void *) &flags, 0, 156);
            flags[13]++ ;
            flags[8]++ ;
            if ((((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 15) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_rtp_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0)) && switch_channel_test_flag (session->channel, 106) == 0)
              {
                flags[7]++ ;
              }
            if (switch_channel_test_flag (session->channel, 29) != 0)
              {
                flags[19]++ ;
              }
            switch_core_media_set_video_codec (session, 0);
            flags[3] = 0;
            flags[0] = 0;
            flags[30]++ ;
            v_engine->rtp_session = switch_rtp_new ((const char *) a_engine->local_sdp_ip, v_engine->local_sdp_port, (const char *) v_engine->cur_payload_map->remote_sdp_ip, v_engine->cur_payload_map->remote_sdp_port, v_engine->cur_payload_map->agreed_pt, 1, 90000, (switch_rtp_flag_t *) &flags, 0B, &err, switch_core_session_get_pool (session));
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5391, (const char *) session, 7, (const char *) "%sVIDEO RTP [%s] %s:%d->%s:%d codec: %u ms: %d [%s]\n", switch_channel_test_flag (session->channel, 29) != 0 ? (char *) "PROXY " : (char *) "", switch_channel_get_name (session->channel), a_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->local_sdp_port, v_engine->cur_payload_map->remote_sdp_ip, (int) v_engine->cur_payload_map->remote_sdp_port, (int) v_engine->cur_payload_map->agreed_pt, 0, (unsigned char) switch_rtp_ready (v_engine->rtp_session) == 0 ? err : (const char *) "SUCCESS");
            if ((unsigned char) switch_rtp_ready (v_engine->rtp_session) != 0)
              {
                {
                  const char * ssrc;

                                    const char * ssrc;
                  if ((unsigned char) v_engine->fir != 0)
                    {
                      switch_rtp_set_flag (v_engine->rtp_session, 36);
                    }
                  if ((unsigned char) v_engine->pli != 0)
                    {
                      switch_rtp_set_flag (v_engine->rtp_session, 37);
                    }
                  switch_rtp_set_payload_map (v_engine->rtp_session, &v_engine->payload_map);
                  start_video_thread (session);
                  switch_channel_set_flag_value (session->channel, 23, 1);
                  if ((ssrc = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_ssrc", 1, -1)) != 0B)
                    {
                      {
                        uint32_t ssrc_ul = (unsigned int) strtoul (ssrc, 0B, 10);

                                                uint32_t ssrc_ul = (unsigned int) strtoul (ssrc, 0B, 10);
                        switch_rtp_set_ssrc (v_engine->rtp_session, ssrc_ul);
                        v_engine->ssrc = ssrc_ul;
                      }
                    }
                  else
                    {
                      switch_rtp_set_ssrc (v_engine->rtp_session, v_engine->ssrc);
                    }
                  if (v_engine->remote_ssrc != 0)
                    {
                      switch_rtp_set_remote_ssrc (v_engine->rtp_session, v_engine->remote_ssrc);
                    }
                  if ((unsigned char) v_engine->ice_in.cands[v_engine->ice_in.chosen[0]][0].ready != 0)
                    {
                      gen_ice (session, 1, 0B, 0);
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5433, (const char *) session, 6, (const char *) "Activating Video ICE\n");
                      switch_rtp_activate_ice (v_engine->rtp_session, v_engine->ice_in.ufrag, v_engine->ice_out.ufrag, (const char *) v_engine->ice_out.pwd, (const char *) v_engine->ice_in.pwd, 0, (unsigned int) switch_ice_direction (session) == 1 ? 2 : 6, &v_engine->ice_in);
                    }
                  if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtcp_video_interval_msec", 1, -1)) != 0B || (val = (const char *) smh->mparams->rtcp_video_interval_msec) != 0B)
                    {
                      {
                        const char * rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_video_rtcp_port", 1, -1);
                        switch_port_t remote_port = v_engine->remote_rtcp_port;

                                                const char * rport = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_remote_video_rtcp_port", 1, -1);
                                                switch_port_t remote_port = v_engine->remote_rtcp_port;
                        if (rport != 0B)
                          {
                            remote_port = (short unsigned int) atoi (rport);
                          }
                        if (strcasecmp (val, (const char *) "passthru") == 0)
                          {
                            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5462, (const char *) session, 6, (const char *) "Activating VIDEO RTCP PASSTHRU PORT %d\n", (int) remote_port);
                            switch_rtp_activate_rtcp (v_engine->rtp_session, -1, remote_port, (signed char) v_engine->rtcp_mux > 0);
                          }
                        else
                          {
                            {
                              int interval = atoi (val);

                                                            int interval = atoi (val);
                              if ((unsigned int) interval + 4294967196 > 499900)
                                {
                                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5467, (const char *) session, 3, (const char *) "Invalid rtcp interval spec [%d] must be between 100 and 500000\n", interval);
                                }
                              interval = 10000;
                              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5471, (const char *) session, 6, (const char *) "Activating VIDEO RTCP PORT %d mux %d\n", (int) remote_port, (int) v_engine->rtcp_mux);
                              switch_rtp_activate_rtcp (v_engine->rtp_session, interval, remote_port, (signed char) v_engine->rtcp_mux > 0);
                            }
                          }
                        if ((unsigned char) v_engine->ice_in.cands[v_engine->ice_in.chosen[1]][1].ready != 0)
                          {
                            if (((signed char) v_engine->rtcp_mux > 0 && TARGET_EXPR <D.39417, {
                              size_t __s1_len;
                              size_t __s2_len;

                                                            size_t __s1_len;
                                                            size_t __s2_len;
                              D.39417 = __builtin_strcmp ((const char *) v_engine->ice_in.cands[v_engine->ice_in.chosen[1]][1].con_addr, (const char *) v_engine->ice_in.cands[v_engine->ice_in.chosen[0]][0].con_addr);
                            }> == 0) && (short unsigned int) v_engine->ice_in.cands[v_engine->ice_in.chosen[1]][1].con_port == (short unsigned int) v_engine->ice_in.cands[v_engine->ice_in.chosen[0]][0].con_port)
                              {
                                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5481, (const char *) session, 6, (const char *) "Skipping VIDEO RTCP ICE (Same as VIDEO RTP)\n");
                              }
                            else
                              {
                                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5484, (const char *) session, 6, (const char *) "Activating VIDEO RTCP ICE\n");
                                switch_rtp_activate_ice (v_engine->rtp_session, v_engine->ice_in.ufrag, v_engine->ice_out.ufrag, (const char *) v_engine->ice_out.pwd, (const char *) v_engine->ice_in.pwd, 1, (unsigned int) switch_ice_direction (session) == 1 ? 2 : 6, &v_engine->ice_in);
                              }
                          }
                      }
                    }
                  if ((_zstr ((const char *) &v_engine->local_dtls_fingerprint.str) == 0 && switch_rtp_has_dtls () != 0) && dtls_ok (smh->session) != 0)
                    {
                      {
                        dtls_type_t xtype;
                        dtls_type_t dtype = (unsigned int) switch_channel_direction (smh->session->channel) == 0 ? 1 : 2;

                                                dtls_type_t xtype;
                                                dtls_type_t dtype = (unsigned int) switch_channel_direction (smh->session->channel) == 0 ? 1 : 2;
                        xtype = 4;
                        if ((signed char) v_engine->rtcp_mux > 0 && smh->mparams->rtcp_video_interval_msec != 0B)
                          {
                            xtype = (dtls_type_t) ((unsigned int) xtype | 8);
                          }
                        switch_rtp_add_dtls (v_engine->rtp_session, &v_engine->local_dtls_fingerprint, &v_engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
                        if ((signed char) v_engine->rtcp_mux <= 0 && smh->mparams->rtcp_video_interval_msec != 0B)
                          {
                            xtype = 8;
                            switch_rtp_add_dtls (v_engine->rtp_session, &v_engine->local_dtls_fingerprint, &v_engine->remote_dtls_fingerprint, (dtls_type_t) ((unsigned int) dtype | (unsigned int) xtype));
                          }
                      }
                    }
                  if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_manual_video_rtp_bugs", 1, -1)) != 0B)
                    {
                      switch_core_media_parse_rtp_bugs (&v_engine->rtp_bugs, val);
                    }
                  switch_rtp_intentional_bugs (v_engine->rtp_session, (switch_rtp_bug_flag_t) ((unsigned int) v_engine->rtp_bugs | (unsigned int) smh->mparams->manual_video_rtp_bugs));
                  switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_video_pt", (const char *) "%d", (int) v_engine->cur_payload_map->agreed_pt);
                  v_engine->ssrc = switch_rtp_get_ssrc (v_engine->rtp_session);
                  switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_video_ssrc", (const char *) "%u", v_engine->ssrc);
                  switch_core_session_apply_crypto (session, 1);
                  if (switch_channel_test_flag (session->channel, 74) != 0)
                    {
                      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5542, (const char *) session, 7, (const char *) "Activating video UDPTL mode\n");
                      switch_rtp_udptl_mode (v_engine->rtp_session);
                    }
                }
              }
            else
              {
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5547, (const char *) session, 3, (const char *) "VIDEO RTP REPORTS ERROR: [%s]\n", err != 0B ? err : (const char *) "");
                switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5548, 27);
                goto end;
              }
          }
      }
    }
  else
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5554, (const char *) session, 3, (const char *) "AUDIO RTP REPORTS ERROR: [%s]\n", err != 0B ? err : (const char *) "");
      switch_channel_perform_hangup (session->channel, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5555, 27);
      status = 1;
      goto end;
    }
  video_up:;
  if (session != 0B && v_engine != 0B)
    {
      check_dtls_reinvite (session, v_engine);
    }
  status = 0;
  end:;
  switch_channel_clear_flag (session->channel, 103);
  switch_core_recovery_track (session);
  return status;
}



;; Function get_media_profile_name (null)
;; enabled by -tree-original

{
  static const char __PRETTY_FUNCTION__[23] = "get_media_profile_name";

    static const char __PRETTY_FUNCTION__[23] = "get_media_profile_name";
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 5582, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if (switch_channel_test_flag (session->channel, 106) != 0)
    {
      if (switch_channel_test_flag (session->channel, 107) != 0)
        {
          return (const char *) "UDP/TLS/RTP/SAVPF";
        }
      else
        {
          return (const char *) "RTP/SAVPF";
        }
    }
  if (secure != 0)
    {
      return (const char *) "RTP/SAVP";
    }
  return (const char *) "RTP/AVP";
}



;; Function generate_m (null)
;; enabled by -tree-original

{
  int i = 0;
  int rate;
  int already_did[128] = {0};
  int ptime = 0;
  int noptime = 0;
  const char * local_sdp_audio_zrtp_hash;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  static const char __PRETTY_FUNCTION__[11] = "generate_m";
  static const char __func__[11] = "generate_m";

    static const char __func__[11] = "generate_m";
    static const char __PRETTY_FUNCTION__[11] = "generate_m";
    int i = 0;
    int rate;
    int already_did[128] = {0};
    int ptime = 0;
    int noptime = 0;
    const char * local_sdp_audio_zrtp_hash;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 5614, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "m=audio %d %s", (int) port, get_media_profile_name (session, secure != 0 && (unsigned int) switch_channel_direction (session->channel) == 1 || (unsigned int) a_engine->crypto_type != 9));
  i = 0;
  goto <D.39454>;
  <D.39453>:;
  {
    const struct switch_codec_implementation_t * imp = smh->codecs[i];
    int this_ptime = (int) imp->microseconds_per_packet / 1000;

        const struct switch_codec_implementation_t * imp = smh->codecs[i];
        int this_ptime = (int) imp->microseconds_per_packet / 1000;
    if (strcasecmp ((const char *) imp->iananame, (const char *) "ilbc") == 0 || strcasecmp ((const char *) imp->iananame, (const char *) "isac") == 0)
      {
        this_ptime = 20;
      }
    if ((unsigned int) imp->codec_type != 0)
      {
        // predicted unlikely by continue predictor.;
        goto <D.39452>;
      }
    if (noptime == 0)
      {
        if (cur_ptime == 0)
          {
            if (ptime == 0)
              {
                ptime = this_ptime;
              }
          }
        else
          {
            if (this_ptime != cur_ptime)
              {
                // predicted unlikely by continue predictor.;
                goto <D.39452>;
              }
          }
      }
    if ((signed char) smh->ianacodes[i] >= 0)
      {
        if (already_did[(int) smh->ianacodes[i]] != 0)
          {
            // predicted unlikely by continue predictor.;
            goto <D.39452>;
          }
        already_did[(int) smh->ianacodes[i]] = 1;
      }
    switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) " %d", (int) smh->ianacodes[i]);
  }
  <D.39452>:;
  i++ ;
  <D.39454>:;
  if (smh->mparams->num_codecs > i) goto <D.39453>; else goto <D.39455>;
  <D.39455>:;
  if ((unsigned int) smh->mparams->dtmf_type == 0 && (unsigned char) smh->mparams->te > 95)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) " %d", (int) smh->mparams->te);
    }
  if ((int) switch_media_handle_test_media_flag (smh, 9) == 0 && (cng_type != 0 && use_cng != 0))
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) " %d", cng_type);
    }
  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "\n");
  memset ((void *) &already_did, 0, 512);
  i = 0;
  goto <D.39464>;
  <D.39463>:;
  {
    const struct switch_codec_implementation_t * imp = smh->codecs[i];
    char * fmtp = imp->fmtp;
    int this_ptime = (int) imp->microseconds_per_packet / 1000;

        const struct switch_codec_implementation_t * imp = smh->codecs[i];
        char * fmtp = imp->fmtp;
        int this_ptime = (int) imp->microseconds_per_packet / 1000;
    if ((unsigned int) imp->codec_type != 0)
      {
        // predicted unlikely by continue predictor.;
        goto <D.39459>;
      }
    if (strcasecmp ((const char *) imp->iananame, (const char *) "ilbc") == 0 || strcasecmp ((const char *) imp->iananame, (const char *) "isac") == 0)
      {
        this_ptime = 20;
      }
    if (noptime == 0)
      {
        if (cur_ptime == 0)
          {
            if (ptime == 0)
              {
                ptime = this_ptime;
              }
          }
        else
          {
            if (this_ptime != cur_ptime)
              {
                // predicted unlikely by continue predictor.;
                goto <D.39459>;
              }
          }
      }
    if ((signed char) smh->ianacodes[i] >= 0)
      {
        if (already_did[(int) smh->ianacodes[i]] != 0)
          {
            // predicted unlikely by continue predictor.;
            goto <D.39459>;
          }
        already_did[(int) smh->ianacodes[i]] = 1;
      }
    rate = (int) imp->samples_per_second;
    if (map != 0B)
      {
        {
          char key[128] = "";
          char * check = 0B;

                    char key[128] = "";
                    char * check = 0B;
          switch_snprintf ((char *) &key, 128, (const char *) "%s:%u", imp->iananame, imp->bits_per_second);
          if ((check = switch_event_get_header_idx (map, (const char *) &key, -1)) != 0B || (check = switch_event_get_header_idx (map, (const char *) imp->iananame, -1)) != 0B)
            {
              fmtp = check;
            }
        }
      }
    if (smh->fmtps[i] != 0B)
      {
        fmtp = smh->fmtps[i];
      }
    if ((unsigned char) smh->ianacodes[i] > 95 || switch_channel_test_flag (session->channel, 110) != 0)
      {
        {
          int channels = get_channels ((const char *) imp->iananame, (int) imp->number_of_channels);

                    int channels = get_channels ((const char *) imp->iananame, (int) imp->number_of_channels);
          if (channels > 1)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d/%d\n", (int) smh->ianacodes[i], imp->iananame, rate, channels);
            }
          else
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d\n", (int) smh->ianacodes[i], imp->iananame, rate);
            }
        }
      }
    if (fmtp != 0B)
      {
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=fmtp:%d %s\n", (int) smh->ianacodes[i], fmtp);
      }
  }
  <D.39459>:;
  i++ ;
  <D.39464>:;
  if (smh->mparams->num_codecs > i) goto <D.39463>; else goto <D.39465>;
  <D.39465>:;
  if ((((unsigned int) smh->mparams->dtmf_type == 0 || (int) switch_media_handle_test_media_flag (smh, 8) != 0) || switch_channel_test_flag (session->channel, 93) != 0) && (unsigned char) smh->mparams->te > 95)
    {
      if (switch_channel_test_flag (session->channel, 106) != 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtpmap:%d telephone-event/8000\n", (int) smh->mparams->te);
        }
      else
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtpmap:%d telephone-event/8000\na=fmtp:%d 0-16\n", (int) smh->mparams->te, (int) smh->mparams->te);
        }
    }
  if (_zstr ((const char *) a_engine->local_dtls_fingerprint.type) == 0 && secure != 0)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=fingerprint:%s %s\n", a_engine->local_dtls_fingerprint.type, (char *) &a_engine->local_dtls_fingerprint.str);
    }
  if (smh->mparams->rtcp_audio_interval_msec != 0B)
    {
      if ((signed char) a_engine->rtcp_mux > 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtcp-mux\n");
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", (int) port, family, ip);
        }
      else
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", (int) port + 1, family, ip);
        }
    }
  if ((unsigned char) a_engine->ice_out.cands[0][0].ready != 0)
    {
      {
        char tmp1[11] = "";
        char tmp2[11] = "";
        uint32_t c1 = 659136;
        uint32_t c2 = 659134;
        struct ice_t * ice_out;

                char tmp1[11] = "";
                char tmp2[11] = "";
                uint32_t c1 = 659136;
                uint32_t c2 = 659134;
                struct ice_t * ice_out;
        tmp1[10] = 0;
        tmp2[10] = 0;
        switch_stun_random_string ((char *) &tmp1, 10, (char *) "0123456789");
        switch_stun_random_string ((char *) &tmp2, 10, (char *) "0123456789");
        gen_ice (session, 0, 0B, 0);
        ice_out = &a_engine->ice_out;
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ssrc:%u cname:%s\n", a_engine->ssrc, smh->cname);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ssrc:%u msid:%s a0\n", a_engine->ssrc, smh->msid);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ssrc:%u mslabel:%s\n", a_engine->ssrc, smh->msid);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ssrc:%u label:%sa0\n", a_engine->ssrc, smh->msid);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ice-ufrag:%s\n", ice_out->ufrag);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ice-pwd:%s\n", ice_out->pwd);
        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c1, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port);
        if (((_zstr ((const char *) a_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][0].con_addr) == 0) && TARGET_EXPR <D.39479, {
          size_t __s1_len;
          size_t __s2_len;

                    size_t __s1_len;
                    size_t __s2_len;
          D.39479 = __builtin_strcmp ((const char *) a_engine->local_sdp_ip, (const char *) ice_out->cands[0][0].con_addr);
        }> != 0) && (short unsigned int) a_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][0].con_port)
          {
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c2, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port, a_engine->local_sdp_ip, (int) a_engine->local_sdp_port);
          }
        if ((signed char) a_engine->rtcp_mux <= 0 || (unsigned int) switch_channel_direction (session->channel) == 1)
          {
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c1, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) a_engine->rtcp_mux <= 0));
            if (((_zstr ((const char *) a_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][1].con_addr) == 0) && TARGET_EXPR <D.39488, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39488 = __builtin_strcmp ((const char *) a_engine->local_sdp_ip, (const char *) ice_out->cands[0][1].con_addr);
            }> != 0) && (short unsigned int) a_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][1].con_port)
              {
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c2, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) a_engine->rtcp_mux <= 0), a_engine->local_sdp_ip, (int) a_engine->local_sdp_port + ((signed char) a_engine->rtcp_mux <= 0));
              }
          }
      }
    }
  if (secure != 0 && switch_channel_test_flag (session->channel, 109) == 0)
    {
      {
        int i;

                int i;
        i = 0;
        goto <D.39492>;
        <D.39491>:;
        {
          switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;

                    switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;
          if (((unsigned int) a_engine->crypto_type == (unsigned int) j || (unsigned int) a_engine->crypto_type == 9) && _zstr ((const char *) a_engine->ssec[(unsigned int) j].local_crypto_key) == 0)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=crypto:%s\n", a_engine->ssec[(unsigned int) j].local_crypto_key);
            }
        }
        i++ ;
        <D.39492>:;
        if ((unsigned int) smh->crypto_suite_order[i] != 9) goto <D.39491>; else goto <D.39493>;
        <D.39493>:;
      }
    }
  if (cng_type == 0)
    {
      if ((int) switch_media_handle_test_media_flag (smh, 9) != 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=silenceSupp:off - - - -\n");
        }
    }
  if (append_audio != 0B)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "%s%s", append_audio, (unsigned char) *((unsigned char) *append_audio != 0 ? append_audio + ((unsigned int) strlen (append_audio) + -1) : append_audio) == 10 ? (char *) "" : (char *) "\n");
    }
  if (cur_ptime == 0)
    {
      cur_ptime = ptime;
    }
  if (noptime == 0 && cur_ptime != 0)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=ptime:%d\n", cur_ptime);
    }
  local_sdp_audio_zrtp_hash = switch_core_media_get_zrtp_hash (session, 0, 1);
  if (local_sdp_audio_zrtp_hash != 0B)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5882, (const char *) session, 7, (const char *) "Adding audio a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
    }
  if (_zstr (sr) == 0)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - strlen ((const char *) buf), (const char *) "a=%s\n", sr);
    }
}



;; Function switch_core_media_check_dtmf_type (null)
;; enabled by -tree-original

{
  const char * val;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_check_dtmf_type";

    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_check_dtmf_type";
    const char * val;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 5897, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "dtmf_type", 1, -1)) != 0B)
    {
      if (strcasecmp (val, (const char *) "rfc2833") == 0)
        {
          smh->mparams->dtmf_type = 0;
        }
      else
        {
          if (strcasecmp (val, (const char *) "info") == 0)
            {
              smh->mparams->dtmf_type = 1;
            }
          else
            {
              if (strcasecmp (val, (const char *) "none") == 0)
                {
                  smh->mparams->dtmf_type = 2;
                }
            }
        }
    }
}



;; Function switch_core_media_sdp_map (null)
;; enabled by -tree-original

{
  struct sdp_media_t * m;
  struct sdp_parser_t * parser = 0B;
  struct sdp_session_t * sdp;
  static const char __func__[26] = "switch_core_media_sdp_map";

    static const char __func__[26] = "switch_core_media_sdp_map";
    struct sdp_media_t * m;
    struct sdp_parser_t * parser = 0B;
    struct sdp_session_t * sdp;
  if ((parser = sdp_parse (0B, r_sdp, (int) strlen (r_sdp), 0)) == 0B)
    {
      return 1;
    }
  if ((sdp = sdp_session (parser)) == 0B)
    {
      sdp_parser_free (parser);
      return 1;
    }
  switch_event_create_subclass_detailed ((const char *) "src/switch_core_media.c", (const char *) &__func__, 5930, fmtp, 62, 0B);
  switch_event_create_subclass_detailed ((const char *) "src/switch_core_media.c", (const char *) &__func__, 5931, pt, 62, 0B);
  m = sdp->sdp_media;
  goto <D.39518>;
  <D.39517>:;
  if ((unsigned int) m->m_proto == 256)
    {
      {
        struct sdp_rtpmap_t * map;

                struct sdp_rtpmap_t * map;
        map = m->m_rtpmaps;
        goto <D.39515>;
        <D.39514>:;
        if (map->rm_encoding != 0B)
          {
            {
              char buf[25] = "";
              char key[128] = "";
              char * br = 0B;

                            char buf[25] = "";
                            char key[128] = "";
                            char * br = 0B;
              if (map->rm_fmtp != 0B)
                {
                  if ((br = strstr (map->rm_fmtp, (const char *) "bitrate=")) != 0B)
                    {
                      br = br + 8;
                    }
                }
              switch_snprintf ((char *) &buf, 25, (const char *) "%d", (int) map->rm_pt);
              if (br != 0B)
                {
                  switch_snprintf ((char *) &key, 128, (const char *) "%s:%s", map->rm_encoding, br);
                }
              else
                {
                  switch_snprintf ((char *) &key, 128, (const char *) "%s", map->rm_encoding);
                }
              switch_event_add_header_string (*pt, 1, (const char *) &key, (const char *) &buf);
              if (map->rm_fmtp != 0B)
                {
                  switch_event_add_header_string (*fmtp, 1, (const char *) &key, map->rm_fmtp);
                }
            }
          }
        map = map->rm_next;
        <D.39515>:;
        if (map != 0B) goto <D.39514>; else goto <D.39516>;
        <D.39516>:;
      }
    }
  m = m->m_next;
  <D.39518>:;
  if (m != 0B) goto <D.39517>; else goto <D.39519>;
  <D.39519>:;
  sdp_parser_free (parser);
  return 0;
}



;; Function switch_core_media_set_local_sdp (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_set_local_sdp";
  static const char __func__[32] = "switch_core_media_set_local_sdp";

    static const char __func__[32] = "switch_core_media_set_local_sdp";
    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_set_local_sdp";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 5978, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if (smh->sdp_mutex != 0B)
    {
      switch_mutex_lock (smh->sdp_mutex);
    }
  smh->mparams->local_sdp_str = (unsigned int) dup != 0 ? switch_core_perform_session_strdup (session, sdp_str, (const char *) "src/switch_core_media.c", (const char *) &__func__, 5985) : (char *) sdp_str;
  switch_channel_set_variable_var_check (session->channel, (const char *) "rtp_local_sdp_str", (const char *) smh->mparams->local_sdp_str, 1);
  if (smh->sdp_mutex != 0B)
    {
      switch_mutex_unlock (smh->sdp_mutex);
    }
}



;; Function switch_core_media_gen_local_sdp (null)
;; enabled by -tree-original

{
  char * buf;
  int ptime = 0;
  uint32_t rate = 0;
  uint32_t v_port;
  int use_cng = 1;
  const char * val;
  const char * family;
  const char * pass_fmtp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_video_fmtp", 1, -1);
  const char * ov_fmtp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_force_video_fmtp", 1, -1);
  const char * append_audio = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_append_audio_sdp", 1, -1);
  const char * append_video = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_append_video_sdp", 1, -1);
  char srbuf[128] = "";
  const char * var_val;
  const char * username;
  const char * fmtp_out;
  const char * fmtp_out_var = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_force_audio_fmtp", 1, -1);
  struct switch_event_t * map = 0B;
  struct switch_event_t * ptmap = 0B;
  const char * local_sdp_audio_zrtp_hash = switch_core_media_get_zrtp_hash (session, 0, 1);
  const char * local_sdp_video_zrtp_hash = switch_core_media_get_zrtp_hash (session, 1, 1);
  const char * tmp;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  struct ice_t * ice_out;
  int vp8 = 0;
  int red = 0;
  struct payload_map_t * pmap;
  int is_outbound = (unsigned int) switch_channel_direction (session->channel) == 1;
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_gen_local_sdp";
  static const char __func__[32] = "switch_core_media_gen_local_sdp";

    static const char __func__[32] = "switch_core_media_gen_local_sdp";
    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_gen_local_sdp";
    char * buf;
    int ptime = 0;
    uint32_t rate = 0;
    uint32_t v_port;
    int use_cng = 1;
    const char * val;
    const char * family;
    const char * pass_fmtp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_video_fmtp", 1, -1);
    const char * ov_fmtp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_force_video_fmtp", 1, -1);
    const char * append_audio = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_append_audio_sdp", 1, -1);
    const char * append_video = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_append_video_sdp", 1, -1);
    char srbuf[128] = "";
    const char * var_val;
    const char * username;
    const char * fmtp_out;
    const char * fmtp_out_var = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_force_audio_fmtp", 1, -1);
    struct switch_event_t * map = 0B;
    struct switch_event_t * ptmap = 0B;
    const char * local_sdp_audio_zrtp_hash = switch_core_media_get_zrtp_hash (session, 0, 1);
    const char * local_sdp_video_zrtp_hash = switch_core_media_get_zrtp_hash (session, 1, 1);
    const char * tmp;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
    struct ice_t * ice_out;
    int vp8 = 0;
    int red = 0;
    struct payload_map_t * pmap;
    int is_outbound = (unsigned int) switch_channel_direction (session->channel) == 1;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 6025, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "rtcp_mux", 1, -1)) != 0)
    {
      a_engine->rtcp_mux = 1;
      v_engine->rtcp_mux = 1;
    }
  if (smh->mparams->rtcp_audio_interval_msec == 0B)
    {
      smh->mparams->rtcp_audio_interval_msec = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtcp_audio_interval_msec", 1, -1);
    }
  if (smh->mparams->rtcp_video_interval_msec == 0B)
    {
      smh->mparams->rtcp_video_interval_msec = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtcp_video_interval_msec", 1, -1);
    }
  if ((dtls_ok (session) != 0 && (tmp = switch_channel_get_variable_dup (smh->session->channel, (const char *) "webrtc_enable_dtls", 1, -1)) != 0B) && switch_false (tmp) != 0)
    {
      switch_channel_clear_flag (smh->session->channel, 111);
      switch_channel_clear_flag (smh->session->channel, 109);
    }
  if ((is_outbound != 0 || switch_channel_test_flag (session->channel, 84) != 0) || switch_channel_test_flag (session->channel, 112) != 0)
    {
      if (switch_channel_test_flag (session->channel, 106) == 0 && switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "media_webrtc", 1, -1)) != 0)
        {
          switch_channel_set_flag_value (session->channel, 106, 1);
          switch_channel_set_flag_value (session->channel, 108, 1);
          smh->mparams->rtcp_audio_interval_msec = (char *) "5000";
          smh->mparams->rtcp_video_interval_msec = (char *) "5000";
        }
      if (switch_rtp_has_dtls () != 0 && dtls_ok (session) != 0)
        {
          if (switch_channel_test_flag (session->channel, 106) != 0 || switch_true (switch_channel_get_variable_dup (smh->session->channel, (const char *) "rtp_use_dtls", 1, -1)) != 0)
            {
              switch_channel_set_flag_value (smh->session->channel, 109, 1);
              switch_channel_set_flag_value (smh->session->channel, 92, 1);
              generate_local_fingerprint (smh, 0);
            }
        }
      switch_core_session_parse_crypto_prefs (session);
      switch_core_session_check_outgoing_crypto (session);
    }
  fmtp_out = (const char *) a_engine->cur_payload_map->fmtp_out;
  username = (const char *) smh->mparams->sdp_username;
  if ((buf = (char *) calloc (1, 65536)) == 0B)
    {
      __assert_fail ((const char *) "(buf = calloc(1, (65536)))", (const char *) "src/switch_core_media.c", 6078, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }, (void) buf;;
  switch_core_media_check_dtmf_type (session);
  if (((int) switch_media_handle_test_media_flag (smh, 9) != 0 || (val = switch_channel_get_variable_dup (session->channel, (const char *) "supress_cng", 1, -1)) != 0B && switch_true (val) != 0) || (val = switch_channel_get_variable_dup (session->channel, (const char *) "suppress_cng", 1, -1)) != 0B && switch_true (val) != 0)
    {
      use_cng = 0;
      smh->mparams->cng_pt = 0;
    }
  if (smh->payload_space == 0)
    {
      {
        int i;

                int i;
        if (switch_channel_test_flag (session->channel, 106) != 0)
          {
            smh->payload_space = 102;
          }
        else
          {
            smh->payload_space = 98;
          }
        i = 0;
        goto <D.39568>;
        <D.39567>:;
        smh->ianacodes[i] = smh->codecs[i]->ianacode;
        i++ ;
        <D.39568>:;
        if (smh->mparams->num_codecs > i) goto <D.39567>; else goto <D.39569>;
        <D.39569>:;
        if ((unsigned int) sdp_type == 0)
          {
            {
              struct switch_core_session_t * orig_session = 0B;

                            struct switch_core_session_t * orig_session = 0B;
              switch_core_session_perform_get_partner (session, &orig_session, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6108);
              i = 0;
              goto <D.39576>;
              <D.39575>:;
              {
                const struct switch_codec_implementation_t * imp = smh->codecs[i];
                switch_payload_t orig_pt = 0;
                char * orig_fmtp = 0B;

                                const struct switch_codec_implementation_t * imp = smh->codecs[i];
                                switch_payload_t orig_pt = 0;
                                char * orig_fmtp = 0B;
                if ((unsigned char) smh->ianacodes[i] > 64)
                  {
                    if (((unsigned int) smh->mparams->dtmf_type == 0 && (unsigned char) smh->mparams->te > 95) && (int) smh->mparams->te == smh->payload_space)
                      {
                        smh->payload_space++ ;
                      }
                    if (((int) switch_media_handle_test_media_flag (smh, 9) == 0 && ((unsigned char) smh->mparams->cng_pt != 0 && use_cng != 0)) && (int) smh->mparams->cng_pt == smh->payload_space)
                      {
                        smh->payload_space++ ;
                      }
                    if (orig_session != 0B && (unsigned int) switch_core_session_get_payload_code (orig_session, (unsigned int) imp->codec_type != 0, (const char *) imp->iananame, &orig_pt, 0B, &orig_fmtp) == 0)
                      {
                        smh->ianacodes[i] = orig_pt;
                        if (orig_fmtp != 0B)
                          {
                            smh->fmtps[i] = switch_core_perform_session_strdup (session, (const char *) orig_fmtp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6133);
                          }
                      }
                    else
                      {
                        smh->ianacodes[i] = (unsigned char) smh->payload_space++ ;
                      }
                  }
                switch_core_media_add_payload_map (session, (unsigned int) imp->codec_type != 0, (const char *) imp->iananame, 0B, sdp_type, (uint32_t) smh->ianacodes[i], imp->samples_per_second, (uint32_t) ((int) imp->microseconds_per_packet / 1000), 0);
              }
              i++ ;
              <D.39576>:;
              if (smh->mparams->num_codecs > i) goto <D.39575>; else goto <D.39577>;
              <D.39577>:;
              if (orig_session != 0B)
                {
                  switch_core_session_rwunlock (orig_session);
                }
            }
          }
      }
    }
  if (fmtp_out_var != 0B)
    {
      fmtp_out = fmtp_out_var;
    }
  val = switch_channel_get_variable_dup (session->channel, (const char *) "verbose_sdp", 1, -1);
  if (val == 0B || switch_true (val) != 0)
    {
      switch_channel_set_flag_value (session->channel, 110, 1);
    }
  if (((force == 0 && ip == 0B) && _zstr (sr) != 0) && (switch_channel_test_flag (session->channel, 15) != 0 || switch_channel_test_flag (session->channel, 29) != 0))
    {
      if (buf != 0B)
        {
          free ((void *) buf);
          buf = 0B;
        }
      return;
    }
  if (ip == 0B)
    {
      if ((ip = (const char *) a_engine->adv_sdp_ip) == 0B)
        {
          ip = (const char *) a_engine->proxy_sdp_ip;
        }
    }
  if (ip == 0B)
    {
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6182, 0B, 2, (const char *) "%s NO IP!\n", switch_channel_get_name (session->channel));
      if (buf != 0B)
        {
          free ((void *) buf);
          buf = 0B;
        }
      return;
    }
  if ((short unsigned int) port == 0)
    {
      if ((short unsigned int) (port = a_engine->adv_sdp_port) == 0)
        {
          port = a_engine->proxy_sdp_port;
        }
    }
  if ((short unsigned int) port == 0)
    {
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6194, 0B, 2, (const char *) "%s NO PORT!\n", switch_channel_get_name (session->channel));
      if (buf != 0B)
        {
          free ((void *) buf);
          buf = 0B;
        }
      return;
    }
  if (_zstr (sr) != 0)
    {
      if ((var_val = switch_channel_get_variable_dup (session->channel, (const char *) "media_audio_mode", 1, -1)) != 0B)
        {
          sr = var_val;
        }
      else
        {
          sr = (const char *) "sendrecv";
        }
    }
  if (smh->owner_id == 0)
    {
      smh->owner_id = (unsigned int) switch_epoch_time_now (0B) - (unsigned int) port;
    }
  if (smh->session_id == 0)
    {
      smh->session_id = smh->owner_id;
    }
  if (switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "drop_dtmf", 0, -1)) != 0)
    {
      switch_channel_set_flag_value (session->channel, 102, 1);
    }
  smh->session_id++ ;
  if (((unsigned int) smh->mparams->ndlb & 16) != 0 || (var_val = switch_channel_get_variable_dup (session->channel, (const char *) "ndlb_sendrecv_in_session", 1, -1)) != 0B && switch_true (var_val) != 0)
    {
      if (_zstr (sr) == 0)
        {
          switch_snprintf ((char *) &srbuf, 128, (const char *) "a=%s\n", sr);
        }
      sr = 0B;
    }
  family = (const char *) (__builtin_strchr (ip, 58) != 0B ? "IP6" : "IP4");
  switch_snprintf (buf, 65536, (const char *) "v=0\no=%s %010u %010u IN %s %s\ns=%s\nc=IN %s %s\nt=0 0\n%s", username, smh->owner_id, smh->session_id, family, ip, username, family, ip, (char *) &srbuf);
  if (switch_channel_test_flag (smh->session->channel, 108) != 0)
    {
      gen_ice (session, 0, ip, port);
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=msid-semantic: WMS %s\n", smh->msid);
    }
  if ((unsigned char) a_engine->codec_negotiated != 0)
    {
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "m=audio %d %s", (int) port, get_media_profile_name (session, (unsigned char) a_engine->no_crypto == 0 && (switch_channel_test_flag (session->channel, 109) != 0 || (unsigned int) a_engine->crypto_type != 9)));
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) a_engine->cur_payload_map->pt);
      if ((int) switch_media_handle_test_media_flag (smh, 15) != 0)
        {
          switch_mutex_lock (smh->sdp_mutex);
          pmap = a_engine->cur_payload_map;
          goto <D.39579>;
          <D.39578>:;
          if ((unsigned char) pmap->pt != (unsigned char) a_engine->cur_payload_map->pt)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) pmap->pt);
            }
          pmap = (struct payload_map_t *) pmap->next;
          <D.39579>:;
          if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.39578>; else goto <D.39580>;
          <D.39580>:;
          switch_mutex_unlock (smh->sdp_mutex);
        }
      if ((((unsigned int) smh->mparams->dtmf_type == 0 || (int) switch_media_handle_test_media_flag (smh, 8) != 0) || switch_channel_test_flag (session->channel, 93) != 0) && (unsigned char) smh->mparams->te > 95)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) smh->mparams->te);
        }
      if ((int) switch_media_handle_test_media_flag (smh, 9) == 0 && ((unsigned char) smh->mparams->cng_pt != 0 && use_cng != 0))
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) smh->mparams->cng_pt);
        }
      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "\n");
      rate = (uint32_t) a_engine->cur_payload_map->adv_rm_rate;
      if (a_engine->cur_payload_map->adv_channels == 0)
        {
          a_engine->cur_payload_map->adv_channels = get_channels ((const char *) a_engine->cur_payload_map->rm_encoding, 1);
        }
      if (a_engine->cur_payload_map->adv_channels > 1)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d/%d\n", (int) a_engine->cur_payload_map->agreed_pt, a_engine->cur_payload_map->rm_encoding, rate, a_engine->cur_payload_map->adv_channels);
        }
      else
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d\n", (int) a_engine->cur_payload_map->agreed_pt, a_engine->cur_payload_map->rm_encoding, rate);
        }
      if (fmtp_out != 0B)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=fmtp:%d %s\n", (int) a_engine->cur_payload_map->agreed_pt, fmtp_out);
        }
      if ((int) switch_media_handle_test_media_flag (smh, 15) != 0)
        {
          switch_mutex_lock (smh->sdp_mutex);
          pmap = a_engine->cur_payload_map;
          goto <D.39582>;
          <D.39581>:;
          if ((unsigned char) pmap->pt != (unsigned char) a_engine->cur_payload_map->pt)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%ld\n", (int) pmap->pt, pmap->iananame, pmap->rate);
            }
          pmap = (struct payload_map_t *) pmap->next;
          <D.39582>:;
          if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.39581>; else goto <D.39583>;
          <D.39583>:;
          switch_mutex_unlock (smh->sdp_mutex);
        }
      if (a_engine->read_codec.implementation != 0B && ptime == 0)
        {
          ptime = (int) a_engine->read_codec.implementation->microseconds_per_packet / 1000;
        }
      if ((((unsigned int) smh->mparams->dtmf_type == 0 || (int) switch_media_handle_test_media_flag (smh, 8) != 0) || switch_channel_test_flag (session->channel, 93) != 0) && (unsigned char) smh->mparams->te > 95)
        {
          if (switch_channel_test_flag (session->channel, 106) != 0)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d telephone-event/8000\n", (int) smh->mparams->te);
            }
          else
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d telephone-event/8000\na=fmtp:%d 0-16\n", (int) smh->mparams->te, (int) smh->mparams->te);
            }
        }
      if ((int) switch_media_handle_test_media_flag (smh, 9) != 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=silenceSupp:off - - - -\n");
        }
      else
        {
          if ((unsigned char) smh->mparams->cng_pt != 0 && use_cng != 0)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d CN/8000\n", (int) smh->mparams->cng_pt);
              if ((unsigned char) a_engine->codec_negotiated == 0)
                {
                  smh->mparams->cng_pt = 0;
                }
            }
        }
      if (append_audio != 0B)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "%s%s", append_audio, (unsigned char) *((unsigned char) *append_audio != 0 ? append_audio + ((unsigned int) strlen (append_audio) + -1) : append_audio) == 10 ? (char *) "" : (char *) "\n");
        }
      if (ptime != 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ptime:%d\n", ptime);
        }
      if (local_sdp_audio_zrtp_hash != 0B)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6350, (const char *) session, 7, (const char *) "Adding audio a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=zrtp-hash:%s\n", local_sdp_audio_zrtp_hash);
        }
      if (_zstr (sr) == 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=%s\n", sr);
        }
      if (_zstr ((const char *) a_engine->local_dtls_fingerprint.type) == 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=fingerprint:%s %s\n", a_engine->local_dtls_fingerprint.type, (char *) &a_engine->local_dtls_fingerprint.str);
        }
      if (smh->mparams->rtcp_audio_interval_msec != 0B)
        {
          if ((signed char) a_engine->rtcp_mux > 0)
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp-mux\n");
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", (int) port, family, ip);
            }
          else
            {
              switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", (int) port + 1, family, ip);
            }
        }
      if ((unsigned char) a_engine->ice_out.cands[0][0].ready != 0)
        {
          {
            char tmp1[11] = "";
            char tmp2[11] = "";
            uint32_t c1 = 659136;
            uint32_t c2 = 659134;
            uint32_t c3 = 659126;
            uint32_t c4 = 659124;

                        char tmp1[11] = "";
                        char tmp2[11] = "";
                        uint32_t c1 = 659136;
                        uint32_t c2 = 659134;
                        uint32_t c3 = 659126;
                        uint32_t c4 = 659124;
            tmp1[10] = 0;
            tmp2[10] = 0;
            switch_stun_random_string ((char *) &tmp1, 10, (char *) "0123456789");
            switch_stun_random_string ((char *) &tmp2, 10, (char *) "0123456789");
            ice_out = &a_engine->ice_out;
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u cname:%s\n", a_engine->ssrc, smh->cname);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u msid:%s a0\n", a_engine->ssrc, smh->msid);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u mslabel:%s\n", a_engine->ssrc, smh->msid);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u label:%sa0\n", a_engine->ssrc, smh->msid);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ice-ufrag:%s\n", ice_out->ufrag);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ice-pwd:%s\n", ice_out->pwd);
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c1, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port);
            if (((_zstr ((const char *) a_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][0].con_addr) == 0) && TARGET_EXPR <D.39598, {
              size_t __s1_len;
              size_t __s2_len;

                            size_t __s1_len;
                            size_t __s2_len;
              D.39598 = __builtin_strcmp ((const char *) a_engine->local_sdp_ip, (const char *) ice_out->cands[0][0].con_addr);
            }> != 0) && (short unsigned int) a_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][0].con_port)
              {
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c3, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port, a_engine->local_sdp_ip, (int) a_engine->local_sdp_port);
              }
            if (((signed char) a_engine->rtcp_mux <= 0 || is_outbound != 0) || switch_channel_test_flag (session->channel, 84) != 0)
              {
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c2, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) a_engine->rtcp_mux <= 0));
                if (((_zstr ((const char *) a_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][0].con_addr) == 0) && TARGET_EXPR <D.39607, {
                  size_t __s1_len;
                  size_t __s2_len;

                                    size_t __s1_len;
                                    size_t __s2_len;
                  D.39607 = __builtin_strcmp ((const char *) a_engine->local_sdp_ip, (const char *) ice_out->cands[0][0].con_addr);
                }> != 0) && (short unsigned int) a_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][0].con_port)
                  {
                    switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c4, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) a_engine->rtcp_mux <= 0), a_engine->local_sdp_ip, (int) a_engine->local_sdp_port + ((signed char) a_engine->rtcp_mux <= 0));
                  }
              }
          }
        }
      if ((((unsigned int) a_engine->crypto_type != 9 && switch_channel_test_flag (session->channel, 109) == 0) && _zstr ((const char *) a_engine->ssec[(unsigned int) a_engine->crypto_type].local_crypto_key) == 0) && switch_channel_test_flag (session->channel, 92) != 0)
        {
          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=crypto:%s\n", a_engine->ssec[(unsigned int) a_engine->crypto_type].local_crypto_key);
        }
    }
  else
    {
      if (smh->mparams->num_codecs != 0)
        {
          {
            int i;
            int cur_ptime = 0;
            int this_ptime = 0;
            int cng_type = 0;
            const char * mult;

                        int i;
                        int cur_ptime = 0;
                        int this_ptime = 0;
                        int cng_type = 0;
                        const char * mult;
            if ((int) switch_media_handle_test_media_flag (smh, 9) == 0 && ((unsigned char) smh->mparams->cng_pt != 0 && use_cng != 0))
              {
                cng_type = (int) smh->mparams->cng_pt;
                if ((unsigned char) a_engine->codec_negotiated == 0)
                  {
                    smh->mparams->cng_pt = 0;
                  }
              }
            mult = switch_channel_get_variable_dup (session->channel, (const char *) "sdp_m_per_ptime", 1, -1);
            if (switch_channel_test_flag (session->channel, 106) != 0 || mult != 0B && switch_false (mult) != 0)
              {
                {
                  char * bp = buf;
                  int both = switch_channel_test_flag (session->channel, 106) == 0 && switch_channel_test_flag (session->channel, 109) == 0;

                                    char * bp = buf;
                                    int both = switch_channel_test_flag (session->channel, 106) == 0 && switch_channel_test_flag (session->channel, 109) == 0;
                  if ((unsigned char) a_engine->no_crypto == 0 && switch_channel_test_flag (session->channel, 92) != 0 || switch_channel_test_flag (session->channel, 109) != 0)
                    {
                      generate_m (session, buf, 65536, port, family, ip, 0, append_audio, sr, use_cng, cng_type, map, 1, sdp_type);
                      bp = buf + (unsigned int) strlen ((const char *) buf);
                      if ((unsigned int) smh->crypto_mode == 1)
                        {
                          both = 0;
                        }
                    }
                  if (both != 0)
                    {
                      generate_m (session, bp, 65536 - strlen ((const char *) buf), port, family, ip, 0, append_audio, sr, use_cng, cng_type, map, 0, sdp_type);
                    }
                }
              }
            else
              {
                i = 0;
                goto <D.39620>;
                <D.39619>:;
                {
                  const struct switch_codec_implementation_t * imp = smh->codecs[i];

                                    const struct switch_codec_implementation_t * imp = smh->codecs[i];
                  if ((unsigned int) imp->codec_type != 0)
                    {
                      // predicted unlikely by continue predictor.;
                      goto <D.39616>;
                    }
                  this_ptime = (int) imp->microseconds_per_packet / 1000;
                  if (strcasecmp ((const char *) imp->iananame, (const char *) "ilbc") == 0 || strcasecmp ((const char *) imp->iananame, (const char *) "isac") == 0)
                    {
                      this_ptime = 20;
                    }
                  if (cur_ptime != this_ptime)
                    {
                      {
                        char * bp = buf;
                        int both = 1;

                                                char * bp = buf;
                                                int both = 1;
                        cur_ptime = this_ptime;
                        if ((unsigned char) a_engine->no_crypto == 0 && switch_channel_test_flag (session->channel, 92) != 0 || switch_channel_test_flag (session->channel, 109) != 0)
                          {
                            generate_m (session, bp, 65536 - strlen ((const char *) buf), port, family, ip, cur_ptime, append_audio, sr, use_cng, cng_type, map, 1, sdp_type);
                            bp = buf + (unsigned int) strlen ((const char *) buf);
                            if ((unsigned int) smh->crypto_mode == 1)
                              {
                                both = 0;
                              }
                          }
                        if (switch_channel_test_flag (session->channel, 106) != 0 || switch_channel_test_flag (session->channel, 109) != 0)
                          {
                            both = 0;
                          }
                        if (both != 0)
                          {
                            generate_m (session, bp, 65536 - strlen ((const char *) buf), port, family, ip, cur_ptime, append_audio, sr, use_cng, cng_type, map, 0, sdp_type);
                          }
                      }
                    }
                }
                <D.39616>:;
                i++ ;
                <D.39620>:;
                if (smh->mparams->num_codecs > i) goto <D.39619>; else goto <D.39621>;
                <D.39621>:;
              }
          }
        }
    }
  if (switch_channel_test_flag (session->channel, 98) != 0)
    {
      if ((unsigned int) switch_channel_direction (session->channel) == 0)
        {
          if (switch_channel_test_flag (smh->session->channel, 109) != 0)
            {
              v_engine->no_crypto = 1;
            }
        }
      if ((short unsigned int) v_engine->local_sdp_port == 0)
        {
          switch_core_media_choose_port (session, 1, 0);
        }
      if (switch_channel_test_flag (session->channel, 106) != 0)
        {
          switch_media_handle_set_media_flag (smh, 16);
        }
      if ((v_port = (uint32_t) v_engine->adv_sdp_port) != 0)
        {
          {
            int loops;

                        int loops;
            loops = 0;
            goto <D.39683>;
            <D.39682>:;
            if (switch_channel_test_flag (smh->session->channel, 108) != 0)
              {
                gen_ice (session, 1, ip, (short unsigned int) v_port);
              }
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "m=video %d %s", v_port, get_media_profile_name (session, ((loops == 0 && switch_channel_test_flag (session->channel, 92) != 0) && (unsigned int) switch_channel_direction (session->channel) == 1 || (unsigned int) a_engine->crypto_type != 9) || switch_channel_test_flag (session->channel, 109) != 0));
            if ((unsigned char) v_engine->codec_negotiated != 0)
              {
                {
                  struct payload_map_t * pmap;

                                    struct payload_map_t * pmap;
                  switch_core_media_set_video_codec (session, 0);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) v_engine->cur_payload_map->agreed_pt);
                  if ((int) switch_media_handle_test_media_flag (smh, 16) != 0)
                    {
                      switch_mutex_lock (smh->sdp_mutex);
                      pmap = v_engine->cur_payload_map;
                      goto <D.39625>;
                      <D.39624>:;
                      if ((unsigned char) pmap->pt != (unsigned char) v_engine->cur_payload_map->pt)
                        {
                          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) pmap->pt);
                        }
                      pmap = (struct payload_map_t *) pmap->next;
                      <D.39625>:;
                      if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.39624>; else goto <D.39626>;
                      <D.39626>:;
                      switch_mutex_unlock (smh->sdp_mutex);
                    }
                }
              }
            else
              {
                if (smh->mparams->num_codecs != 0)
                  {
                    {
                      int i;
                      int already_did[128] = {0};

                                            int i;
                                            int already_did[128] = {0};
                      i = 0;
                      goto <D.39632>;
                      <D.39631>:;
                      {
                        const struct switch_codec_implementation_t * imp = smh->codecs[i];

                                                const struct switch_codec_implementation_t * imp = smh->codecs[i];
                        if ((unsigned int) imp->codec_type != 1)
                          {
                            // predicted unlikely by continue predictor.;
                            goto <D.39630>;
                          }
                        if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 114) != 0)
                          {
                            // predicted unlikely by continue predictor.;
                            goto <D.39630>;
                          }
                        if ((signed char) smh->ianacodes[i] >= 0)
                          {
                            if (already_did[(int) smh->ianacodes[i]] != 0)
                              {
                                // predicted unlikely by continue predictor.;
                                goto <D.39630>;
                              }
                            already_did[(int) smh->ianacodes[i]] = 1;
                          }
                        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) " %d", (int) smh->ianacodes[i]);
                        if (ptime == 0)
                          {
                            ptime = (int) imp->microseconds_per_packet / 1000;
                          }
                      }
                      <D.39630>:;
                      i++ ;
                      <D.39632>:;
                      if (smh->mparams->num_codecs > i) goto <D.39631>; else goto <D.39633>;
                      <D.39633>:;
                    }
                  }
              }
            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "\n");
            if ((unsigned char) v_engine->codec_negotiated != 0)
              {
                {
                  const char * of;
                  struct payload_map_t * pmap;

                                    const char * of;
                                    struct payload_map_t * pmap;
                  if (strcasecmp ((const char *) v_engine->cur_payload_map->rm_encoding, (const char *) "VP8") == 0)
                    {
                      vp8 = (int) v_engine->cur_payload_map->pt;
                    }
                  if (strcasecmp ((const char *) v_engine->cur_payload_map->rm_encoding, (const char *) "red") == 0)
                    {
                      red = (int) v_engine->cur_payload_map->pt;
                    }
                  rate = (uint32_t) v_engine->cur_payload_map->rm_rate;
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%ld\n", (int) v_engine->cur_payload_map->pt, v_engine->cur_payload_map->rm_encoding, v_engine->cur_payload_map->rm_rate);
                  if (switch_channel_test_flag (session->channel, 84) != 0)
                    {
                      pass_fmtp = (const char *) v_engine->cur_payload_map->rm_fmtp;
                    }
                  else
                    {
                      pass_fmtp = 0B;
                      if (switch_channel_get_partner_uuid (session->channel) != 0B)
                        {
                          if ((of = switch_channel_get_variable_partner (session->channel, (const char *) "rtp_video_fmtp")) != 0B)
                            {
                              pass_fmtp = of;
                            }
                        }
                      if (ov_fmtp != 0B)
                        {
                          pass_fmtp = ov_fmtp;
                        }
                      else
                        {
                          pass_fmtp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_video_fmtp", 1, -1);
                        }
                    }
                  if (pass_fmtp != 0B)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=fmtp:%d %s\n", (int) v_engine->cur_payload_map->pt, pass_fmtp);
                    }
                  if ((int) switch_media_handle_test_media_flag (smh, 16) != 0)
                    {
                      switch_mutex_lock (smh->sdp_mutex);
                      pmap = v_engine->cur_payload_map;
                      goto <D.39637>;
                      <D.39636>:;
                      if ((unsigned char) pmap->pt != (unsigned char) v_engine->cur_payload_map->pt && (unsigned char) pmap->negotiated != 0)
                        {
                          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%ld\n", (int) pmap->pt, pmap->iananame, pmap->rate);
                        }
                      pmap = (struct payload_map_t *) pmap->next;
                      <D.39637>:;
                      if (pmap != 0B && (unsigned char) pmap->allocated != 0) goto <D.39636>; else goto <D.39638>;
                      <D.39638>:;
                      switch_mutex_unlock (smh->sdp_mutex);
                    }
                  if (append_video != 0B)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "%s%s", append_video, (unsigned char) *((unsigned char) *append_video != 0 ? append_video + ((unsigned int) strlen (append_video) + -1) : append_video) == 10 ? (char *) "" : (char *) "\n");
                    }
                }
              }
            else
              {
                if (smh->mparams->num_codecs != 0)
                  {
                    {
                      int i;
                      int already_did[128] = {0};

                                            int i;
                                            int already_did[128] = {0};
                      i = 0;
                      goto <D.39647>;
                      <D.39646>:;
                      {
                        const struct switch_codec_implementation_t * imp = smh->codecs[i];
                        char * fmtp = 0B;
                        uint32_t ianacode = (uint32_t) smh->ianacodes[i];
                        int channels;

                                                const struct switch_codec_implementation_t * imp = smh->codecs[i];
                                                char * fmtp = 0B;
                                                uint32_t ianacode = (uint32_t) smh->ianacodes[i];
                                                int channels;
                        if ((unsigned int) imp->codec_type != 1)
                          {
                            // predicted unlikely by continue predictor.;
                            goto <D.39645>;
                          }
                        if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 114) != 0)
                          {
                            // predicted unlikely by continue predictor.;
                            goto <D.39645>;
                          }
                        if (ianacode <= 127)
                          {
                            if (already_did[ianacode] != 0)
                              {
                                // predicted unlikely by continue predictor.;
                                goto <D.39645>;
                              }
                            already_did[ianacode] = 1;
                          }
                        if (rate == 0)
                          {
                            rate = imp->samples_per_second;
                          }
                        channels = get_channels ((const char *) imp->iananame, (int) imp->number_of_channels);
                        if (strcasecmp ((const char *) imp->iananame, (const char *) "VP8") == 0)
                          {
                            vp8 = (int) ianacode;
                          }
                        if (strcasecmp ((const char *) imp->iananame, (const char *) "red") == 0)
                          {
                            red = (int) ianacode;
                          }
                        if (channels > 1)
                          {
                            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d/%d\n", ianacode, imp->iananame, imp->samples_per_second, channels);
                          }
                        else
                          {
                            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtpmap:%d %s/%d\n", ianacode, imp->iananame, imp->samples_per_second);
                          }
                        if (_zstr (ov_fmtp) == 0)
                          {
                            fmtp = (char *) ov_fmtp;
                          }
                        else
                          {
                            if (map != 0B)
                              {
                                fmtp = switch_event_get_header_idx (map, (const char *) imp->iananame, -1);
                              }
                            if (smh->fmtps[i] != 0B)
                              {
                                fmtp = smh->fmtps[i];
                              }
                            if (_zstr ((const char *) fmtp) != 0)
                              {
                                fmtp = imp->fmtp;
                              }
                            if (_zstr ((const char *) fmtp) != 0)
                              {
                                fmtp = (char *) pass_fmtp;
                              }
                          }
                        if (_zstr ((const char *) fmtp) == 0 && strcasecmp ((const char *) fmtp, (const char *) "_blank_") != 0)
                          {
                            switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=fmtp:%d %s\n", ianacode, fmtp);
                          }
                      }
                      <D.39645>:;
                      i++ ;
                      <D.39647>:;
                      if (smh->mparams->num_codecs > i) goto <D.39646>; else goto <D.39648>;
                      <D.39648>:;
                    }
                  }
              }
            if ((is_outbound != 0 || switch_channel_test_flag (session->channel, 84) != 0) && switch_channel_test_flag (smh->session->channel, 109) != 0)
              {
                generate_local_fingerprint (smh, 1);
              }
            if (_zstr ((const char *) v_engine->local_dtls_fingerprint.type) == 0)
              {
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=fingerprint:%s %s\n", v_engine->local_dtls_fingerprint.type, (char *) &v_engine->local_dtls_fingerprint.str);
              }
            if (smh->mparams->rtcp_video_interval_msec != 0B)
              {
                if ((signed char) v_engine->rtcp_mux > 0)
                  {
                    switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp-mux\n");
                    switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", v_port, family, ip);
                  }
                else
                  {
                    switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp:%d IN %s %s\n", v_port + 1, family, ip);
                  }
              }
            if ((BIT_FIELD_REF <*v_engine, 16, 91280> & 65535) != 0)
              {
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp-fb:* %s%s\n", (unsigned char) v_engine->fir != 0 ? (char *) "fir " : (char *) "", (unsigned char) v_engine->pli != 0 ? (char *) "pli" : (char *) "");
              }
            if ((unsigned char) v_engine->ice_out.cands[0][0].ready != 0)
              {
                {
                  char tmp1[11] = "";
                  char tmp2[11] = "";
                  uint32_t c1 = 659136;
                  uint32_t c2 = 659134;
                  uint32_t c3 = 659126;
                  uint32_t c4 = 659124;
                  const char * vbw;
                  int bw = 256;

                                    char tmp1[11] = "";
                                    char tmp2[11] = "";
                                    uint32_t c1 = 659136;
                                    uint32_t c2 = 659134;
                                    uint32_t c3 = 659126;
                                    uint32_t c4 = 659124;
                                    const char * vbw;
                                    int bw = 256;
                  tmp1[10] = 0;
                  tmp2[10] = 0;
                  switch_stun_random_string ((char *) &tmp1, 10, (char *) "0123456789");
                  switch_stun_random_string ((char *) &tmp2, 10, (char *) "0123456789");
                  ice_out = &v_engine->ice_out;
                  if ((vbw = switch_channel_get_variable_dup (smh->session->channel, (const char *) "rtp_video_max_bandwidth", 1, -1)) != 0B)
                    {
                      {
                        int v = atoi (vbw);

                                                int v = atoi (vbw);
                        bw = v;
                      }
                    }
                  if (bw > 0)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "b=AS:%d\n", bw);
                    }
                  if (vp8 != 0 && switch_channel_test_flag (session->channel, 106) != 0)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp-fb:%d ccm fir\n", vp8);
                    }
                  if (red != 0)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=rtcp-fb:%d nack\n", vp8);
                    }
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u cname:%s\n", v_engine->ssrc, smh->cname);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u msid:%s v0\n", v_engine->ssrc, smh->msid);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u mslabel:%s\n", v_engine->ssrc, smh->msid);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ssrc:%u label:%sv0\n", v_engine->ssrc, smh->msid);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ice-ufrag:%s\n", ice_out->ufrag);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=ice-pwd:%s\n", ice_out->pwd);
                  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c1, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port);
                  if (((_zstr ((const char *) v_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][0].con_addr) == 0) && TARGET_EXPR <D.39666, {
                    size_t __s1_len;
                    size_t __s2_len;

                                        size_t __s1_len;
                                        size_t __s2_len;
                    D.39666 = __builtin_strcmp ((const char *) v_engine->local_sdp_ip, (const char *) ice_out->cands[0][0].con_addr);
                  }> != 0) && (short unsigned int) v_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][0].con_port)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 1 %s %u %s %d typ srflx raddr %s rport %d generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c3, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port, v_engine->local_sdp_ip, (int) v_engine->local_sdp_port);
                    }
                  if (((signed char) v_engine->rtcp_mux <= 0 || is_outbound != 0) || switch_channel_test_flag (session->channel, 84) != 0)
                    {
                      switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ host generation 0\n", (char *) &tmp1, ice_out->cands[0][0].transport, c2, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) v_engine->rtcp_mux <= 0));
                      if (((_zstr ((const char *) v_engine->local_sdp_ip) == 0 && _zstr ((const char *) ice_out->cands[0][1].con_addr) == 0) && TARGET_EXPR <D.39675, {
                        size_t __s1_len;
                        size_t __s2_len;

                                                size_t __s1_len;
                                                size_t __s2_len;
                        D.39675 = __builtin_strcmp ((const char *) v_engine->local_sdp_ip, (const char *) ice_out->cands[0][1].con_addr);
                      }> != 0) && (short unsigned int) v_engine->local_sdp_port != (short unsigned int) ice_out->cands[0][1].con_port)
                        {
                          switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=candidate:%s 2 %s %u %s %d typ srflx generation 0\n", (char *) &tmp2, ice_out->cands[0][0].transport, c4, ice_out->cands[0][0].con_addr, (int) ice_out->cands[0][0].con_port + ((signed char) v_engine->rtcp_mux <= 0), v_engine->local_sdp_ip, (int) v_engine->local_sdp_port + ((signed char) v_engine->rtcp_mux <= 0));
                        }
                    }
                }
              }
            if ((loops == 0 && switch_channel_test_flag (session->channel, 92) != 0) && switch_channel_test_flag (session->channel, 109) == 0)
              {
                {
                  int i;

                                    int i;
                  i = 0;
                  goto <D.39679>;
                  <D.39678>:;
                  {
                    switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;

                                        switch_rtp_crypto_key_type_t j = SUITES[(unsigned int) smh->crypto_suite_order[i]].type;
                    if (((unsigned int) a_engine->crypto_type == (unsigned int) j || (unsigned int) a_engine->crypto_type == 9) && _zstr ((const char *) a_engine->ssec[(unsigned int) j].local_crypto_key) == 0)
                      {
                        switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=crypto:%s\n", v_engine->ssec[(unsigned int) j].local_crypto_key);
                      }
                  }
                  i++ ;
                  <D.39679>:;
                  if ((unsigned int) smh->crypto_suite_order[i] != 9) goto <D.39678>; else goto <D.39680>;
                  <D.39680>:;
                }
              }
            if (local_sdp_video_zrtp_hash != 0B)
              {
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6892, (const char *) session, 7, (const char *) "Adding video a=zrtp-hash:%s\n", local_sdp_video_zrtp_hash);
                switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), 65536 - strlen ((const char *) buf), (const char *) "a=zrtp-hash:%s\n", local_sdp_video_zrtp_hash);
              }
            if (((switch_channel_test_flag (session->channel, 109) != 0 || switch_channel_test_flag (session->channel, 92) == 0) || (unsigned int) smh->crypto_mode == 1) || (unsigned int) smh->crypto_mode == 2)
              {
                goto <D.39681>;
              }
            loops++ ;
            <D.39683>:;
            if (loops <= 1) goto <D.39682>; else goto <D.39681>;
            <D.39681>:;
          }
        }
    }
  if (map != 0B)
    {
      switch_event_destroy (&map);
    }
  if (ptmap != 0B)
    {
      switch_event_destroy (&ptmap);
    }
  switch_core_media_set_local_sdp (session, (const char *) buf, 1);
  if (buf != 0B)
    {
      free ((void *) buf);
      buf = 0B;
    }
}



;; Function switch_core_media_absorb_sdp (null)
;; enabled by -tree-original

{
  const char * sdp_str;
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_absorb_sdp";
  static const char __func__[29] = "switch_core_media_absorb_sdp";

    static const char __func__[29] = "switch_core_media_absorb_sdp";
    static const char __PRETTY_FUNCTION__[29] = "switch_core_media_absorb_sdp";
    const char * sdp_str;
    struct switch_rtp_engine_t * a_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 6930, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  if ((sdp_str = switch_channel_get_variable_dup (session->channel, (const char *) "switch_m_sdp", 1, -1)) != 0B)
    {
      {
        struct sdp_parser_t * parser;
        struct sdp_session_t * sdp;
        struct sdp_media_t * m;
        struct sdp_connection_t * connection;

                struct sdp_parser_t * parser;
                struct sdp_session_t * sdp;
                struct sdp_media_t * m;
                struct sdp_connection_t * connection;
        if ((parser = sdp_parse (0B, sdp_str, (int) strlen (sdp_str), 0)) != 0B)
          {
            if ((sdp = sdp_session (parser)) != 0B)
              {
                m = sdp->sdp_media;
                goto <D.39699>;
                <D.39698>:;
                if ((unsigned int) m->m_type != 2 || m->m_port == 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.39695>;
                  }
                connection = sdp->sdp_connection;
                if (m->m_connections != 0B)
                  {
                    connection = m->m_connections;
                  }
                if (connection != 0B)
                  {
                    a_engine->proxy_sdp_ip = switch_core_perform_session_strdup (session, connection->c_address, (const char *) "src/switch_core_media.c", (const char *) &__func__, 6957);
                  }
                a_engine->proxy_sdp_port = (short unsigned int) m->m_port;
                if (a_engine->proxy_sdp_ip != 0B && (short unsigned int) a_engine->proxy_sdp_port != 0)
                  {
                    goto <D.39697>;
                  }
                <D.39695>:;
                m = m->m_next;
                <D.39699>:;
                if (m != 0B) goto <D.39698>; else goto <D.39697>;
                <D.39697>:;
              }
            sdp_parser_free (parser);
          }
        switch_core_media_set_local_sdp (session, sdp_str, 1);
      }
    }
}



;; Function switch_core_media_set_udptl_image_sdp (null)
;; enabled by -tree-original

{
  char buf[2048] = "";
  char max_buf[128] = "";
  char max_data[128] = "";
  const char * ip;
  uint32_t port;
  const char * family = (const char *) "IP4";
  const char * username;
  const char * bit_removal_on = (const char *) "a=T38FaxFillBitRemoval\n";
  const char * bit_removal_off = (const char *) "";
  const char * mmr_on = (const char *) "a=T38FaxTranscodingMMR\n";
  const char * mmr_off = (const char *) "";
  const char * jbig_on = (const char *) "a=T38FaxTranscodingJBIG\n";
  const char * jbig_off = (const char *) "";
  const char * var;
  int broken_boolean;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_udptl_image_sdp";
  static const char __func__[38] = "switch_core_media_set_udptl_image_sdp";

    static const char __func__[38] = "switch_core_media_set_udptl_image_sdp";
    static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_udptl_image_sdp";
    char buf[2048] = "";
    char max_buf[128] = "";
    char max_data[128] = "";
    const char * ip;
    uint32_t port;
    const char * family = (const char *) "IP4";
    const char * username;
    const char * bit_removal_on = (const char *) "a=T38FaxFillBitRemoval\n";
    const char * bit_removal_off = (const char *) "";
    const char * mmr_on = (const char *) "a=T38FaxTranscodingMMR\n";
    const char * mmr_off = (const char *) "";
    const char * jbig_on = (const char *) "a=T38FaxTranscodingJBIG\n";
    const char * jbig_off = (const char *) "";
    const char * var;
    int broken_boolean;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 6995, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  if (t38_options == 0B)
    {
      __assert_fail ((const char *) "t38_options", (const char *) "src/switch_core_media.c", 7004, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  ip = t38_options->local_ip;
  port = (uint32_t) t38_options->local_port;
  username = (const char *) smh->mparams->sdp_username;
  var = switch_channel_get_variable_dup (session->channel, (const char *) "t38_broken_boolean", 1, -1);
  broken_boolean = switch_true (var);
  if (ip == 0B)
    {
      if ((ip = (const char *) a_engine->adv_sdp_ip) == 0B)
        {
          ip = (const char *) a_engine->proxy_sdp_ip;
        }
    }
  if (ip == 0B)
    {
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7022, 0B, 2, (const char *) "%s NO IP!\n", switch_channel_get_name (session->channel));
      return;
    }
  if (port == 0)
    {
      if ((port = (uint32_t) a_engine->adv_sdp_port) == 0)
        {
          port = (uint32_t) a_engine->proxy_sdp_port;
        }
    }
  if (port == 0)
    {
      switch_log_printf (0, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7033, 0B, 2, (const char *) "%s NO PORT!\n", switch_channel_get_name (session->channel));
      return;
    }
  if (smh->owner_id == 0)
    {
      smh->owner_id = (unsigned int) switch_epoch_time_now (0B) - (unsigned int) port;
    }
  if (smh->session_id == 0)
    {
      smh->session_id = smh->owner_id;
    }
  smh->session_id++ ;
  family = (const char *) (__builtin_strchr (ip, 58) != 0B ? "IP6" : "IP4");
  switch_snprintf ((char *) &buf, 2048, (const char *) "v=0\no=%s %010u %010u IN %s %s\ns=%s\nc=IN %s %s\nt=0 0\n", username, smh->owner_id, smh->session_id, family, ip, username, family, ip);
  if (t38_options->T38FaxMaxBuffer != 0)
    {
      switch_snprintf ((char *) &max_buf, 128, (const char *) "a=T38FaxMaxBuffer:%d\n", t38_options->T38FaxMaxBuffer);
    }
  if (t38_options->T38FaxMaxDatagram != 0)
    {
      switch_snprintf ((char *) &max_data, 128, (const char *) "a=T38FaxMaxDatagram:%d\n", t38_options->T38FaxMaxDatagram);
    }
  if (broken_boolean != 0)
    {
      bit_removal_on = (const char *) "a=T38FaxFillBitRemoval:1\n";
      bit_removal_off = (const char *) "a=T38FaxFillBitRemoval:0\n";
      mmr_on = (const char *) "a=T38FaxTranscodingMMR:1\n";
      mmr_off = (const char *) "a=T38FaxTranscodingMMR:0\n";
      jbig_on = (const char *) "a=T38FaxTranscodingJBIG:1\n";
      jbig_off = (const char *) "a=T38FaxTranscodingJBIG:0\n";
    }
  switch_snprintf ((char *) &buf + (unsigned int) strlen ((const char *) &buf), 2048 - (unsigned int) strlen ((const char *) &buf), (const char *) "m=image %d udptl t38\na=T38FaxVersion:%d\na=T38MaxBitRate:%d\n%s%s%sa=T38FaxRateManagement:%s\n%s%sa=T38FaxUdpEC:%s\n", port, (int) t38_options->T38FaxVersion, t38_options->T38MaxBitRate, (unsigned int) t38_options->T38FaxFillBitRemoval != 0 ? bit_removal_on : bit_removal_off, (unsigned int) t38_options->T38FaxTranscodingMMR != 0 ? mmr_on : mmr_off, (unsigned int) t38_options->T38FaxTranscodingJBIG != 0 ? jbig_on : jbig_off, t38_options->T38FaxRateManagement, (char *) &max_buf, (char *) &max_data, t38_options->T38FaxUdpEC);
  if (insist != 0)
    {
      switch_snprintf ((char *) &buf + (unsigned int) strlen ((const char *) &buf), 2048 - (unsigned int) strlen ((const char *) &buf), (const char *) "m=audio 0 RTP/AVP 19\n");
    }
  switch_core_media_set_local_sdp (session, (const char *) &buf, 1);
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7113, (const char *) session, 7, (const char *) "%s image media sdp:\n%s\n", switch_channel_get_name (session->channel), smh->mparams->local_sdp_str);
}



;; Function switch_core_media_patch_sdp (null)
;; enabled by -tree-original

{
  switch_size_t len;
  char * p;
  char * q;
  char * pe;
  char * qe;
  int has_video = 0;
  int has_audio = 0;
  int has_ip = 0;
  char port_buf[25] = "";
  char vport_buf[25] = "";
  char * new_sdp;
  int bad = 0;
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_patch_sdp";
  static const char __func__[28] = "switch_core_media_patch_sdp";
  void end = <<< error >>>;

    static const char __func__[28] = "switch_core_media_patch_sdp";
    static const char __PRETTY_FUNCTION__[28] = "switch_core_media_patch_sdp";
    switch_size_t len;
    char * p;
    char * q;
    char * pe;
    char * qe;
    int has_video = 0;
    int has_audio = 0;
    int has_ip = 0;
    char port_buf[25] = "";
    char vport_buf[25] = "";
    char * new_sdp;
    int bad = 0;
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7134, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  if (_zstr ((const char *) smh->mparams->local_sdp_str) != 0)
    {
      return;
    }
  len = strlen ((const char *) smh->mparams->local_sdp_str) * 2;
  if (((unsigned int) smh->mparams->ndlb & 32) == 0)
    {
      if (switch_channel_test_flag (session->channel, 1) != 0 && (switch_stristr ((const char *) "sendonly", (const char *) smh->mparams->local_sdp_str) != 0B || switch_stristr ((const char *) "0.0.0.0", (const char *) smh->mparams->local_sdp_str) != 0B))
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7152, (const char *) session, 7, (const char *) "Skip patch on hold SDP\n");
          return;
        }
    }
  if (_zstr ((const char *) a_engine->local_sdp_ip) != 0 || (short unsigned int) a_engine->local_sdp_port == 0)
    {
      if ((unsigned int) switch_core_media_choose_port (session, 0, 1) != 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7159, (const char *) session, 3, (const char *) "%s I/O Error\n", switch_channel_get_name (session->channel));
          return;
        }
      a_engine->cur_payload_map->iananame = switch_core_perform_session_strdup (session, (const char *) "PROXY", (const char *) "src/switch_core_media.c", (const char *) &__func__, 7163);
      a_engine->cur_payload_map->rm_rate = 8000;
      a_engine->cur_payload_map->adv_rm_rate = 8000;
      a_engine->cur_payload_map->codec_ms = 20;
    }
  new_sdp = (char *) switch_core_perform_session_alloc (session, len, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7169);
  switch_snprintf ((char *) &port_buf, 25, (const char *) "%u", (int) a_engine->local_sdp_port);
  p = smh->mparams->local_sdp_str;
  q = new_sdp;
  pe = p + (unsigned int) strlen ((const char *) p);
  qe = q + ((unsigned int) len + -1);
  goto <D.39819>;
  <D.39818>:;
  if (p >= pe)
    {
      bad = 1;
      goto end;
    }
  if (q >= qe)
    {
      bad = 2;
      goto end;
    }
  if (a_engine->local_sdp_ip != 0B && strncmp ((const char *) "c=IN IP", (const char *) p, 7) == 0)
    {
      __builtin_strncpy (q, (const char *) p, 7);
      p = p + 7;
      q = q + 7;
      (char *) __builtin_memcpy (q, (const char *) (__builtin_strchr ((const char *) a_engine->adv_sdp_ip, 58) != 0B ? "6 " : "4 "), 2);
      p = p + 2;
      q = q + 2;
      __builtin_strncpy (q, (const char *) a_engine->adv_sdp_ip, strlen ((const char *) a_engine->adv_sdp_ip));
      q = q + (unsigned int) strlen ((const char *) a_engine->adv_sdp_ip);
      goto <D.39755>;
      <D.39754>:;
      if (p >= pe)
        {
          bad = 3;
          goto end;
        }
      p++ ;
      <D.39755>:;
      if ((p != 0B && (unsigned char) *p != 0) && ((((SAVE_EXPR <*p> + 208 <= 9 || SAVE_EXPR <*p> == 46) || (unsigned char) *p == 58) || *p + 191 <= 5) || *p + 159 <= 5)) goto <D.39754>; else goto <D.39756>;
      <D.39756>:;
      has_ip++ ;
    }
  else
    {
      if (strncmp ((const char *) "o=", (const char *) p, 2) == 0)
        {
          {
            char * oe = __builtin_strchr ((const char *) p, 10);
            switch_size_t len;

                        char * oe = __builtin_strchr ((const char *) p, 10);
                        switch_size_t len;
            if (oe != 0B)
              {
                {
                  const char * family = (const char *) "IP4";
                  char o_line[1024] = "";

                                    const char * family = (const char *) "IP4";
                                    char o_line[1024] = "";
                  if (oe >= pe)
                    {
                      bad = 5;
                      goto end;
                    }
                  len = (switch_size_t) ((int) oe - (int) p);
                  p = p + (unsigned int) len;
                  family = (const char *) (__builtin_strchr ((const char *) smh->mparams->sipip, 58) != 0B ? "IP6" : "IP4");
                  if (smh->owner_id == 0)
                    {
                      smh->owner_id = (unsigned int) switch_epoch_time_now (0B) * 31821 + 13849;
                    }
                  if (smh->session_id == 0)
                    {
                      smh->session_id = smh->owner_id;
                    }
                  smh->session_id++ ;
                  snprintf ((char *) &o_line, 1024, (const char * restrict) "o=%s %010u %010u IN %s %s\n", smh->mparams->sdp_username, smh->owner_id, smh->session_id, family, smh->mparams->sipip);
                  __builtin_strncpy (q, (const char *) &o_line, strlen ((const char *) &o_line));
                  q = q + ((unsigned int) strlen ((const char *) &o_line) + -1);
                }
              }
          }
        }
      else
        {
          if (strncmp ((const char *) "s=", (const char *) p, 2) == 0)
            {
              {
                char * se = __builtin_strchr ((const char *) p, 10);
                switch_size_t len;

                                char * se = __builtin_strchr ((const char *) p, 10);
                                switch_size_t len;
                if (se != 0B)
                  {
                    {
                      char s_line[1024] = "";

                                            char s_line[1024] = "";
                      if (se >= pe)
                        {
                          bad = 5;
                          goto end;
                        }
                      len = (switch_size_t) ((int) se - (int) p);
                      p = p + (unsigned int) len;
                      snprintf ((char *) &s_line, 1024, (const char * restrict) "s=%s\n", smh->mparams->sdp_username);
                      __builtin_strncpy (q, (const char *) &s_line, strlen ((const char *) &s_line));
                      q = q + ((unsigned int) strlen ((const char *) &s_line) + -1);
                    }
                  }
              }
            }
          else
            {
              if ((strncmp ((const char *) "m=audio ", (const char *) p, 8) == 0 || strncmp ((const char *) "m=image ", (const char *) p, 8) == 0) && (unsigned char) *(p + 8) != 48)
                {
                  __builtin_strncpy (q, (const char *) p, 8);
                  p = p + 8;
                  if (p >= pe)
                    {
                      bad = 4;
                      goto end;
                    }
                  q = q + 8;
                  if (q >= qe)
                    {
                      bad = 5;
                      goto end;
                    }
                  __builtin_strncpy (q, (const char *) &port_buf, strlen ((const char *) &port_buf));
                  q = q + (unsigned int) strlen ((const char *) &port_buf);
                  if (q >= qe)
                    {
                      bad = 6;
                      goto end;
                    }
                  goto <D.39801>;
                  <D.39800>:;
                  if (p >= pe)
                    {
                      bad = 7;
                      goto end;
                    }
                  p++ ;
                  <D.39801>:;
                  if ((p != 0B && (unsigned char) *p != 0) && *p + 208 <= 9) goto <D.39800>; else goto <D.39802>;
                  <D.39802>:;
                  has_audio++ ;
                }
              else
                {
                  if (strncmp ((const char *) "m=video ", (const char *) p, 8) == 0 && (unsigned char) *(p + 8) != 48)
                    {
                      if (has_video == 0)
                        {
                          switch_core_media_choose_port (session, 1, 1);
                          v_engine->cur_payload_map->rm_encoding = (char *) "PROXY-VID";
                          v_engine->cur_payload_map->rm_rate = 90000;
                          v_engine->cur_payload_map->adv_rm_rate = 90000;
                          v_engine->cur_payload_map->codec_ms = 0;
                          switch_snprintf ((char *) &vport_buf, 25, (const char *) "%u", (int) v_engine->adv_sdp_port);
                          if (switch_channel_test_ready (session->channel, 1, 1) != 0 && (unsigned char) switch_rtp_ready (v_engine->rtp_session) == 0)
                            {
                              switch_channel_set_flag_value (session->channel, 98, 1);
                              switch_channel_set_flag_value (session->channel, 103, 1);
                              switch_core_media_activate_rtp (session);
                            }
                        }
                      __builtin_strncpy (q, (const char *) p, 8);
                      p = p + 8;
                      if (p >= pe)
                        {
                          bad = 8;
                          goto end;
                        }
                      q = q + 8;
                      if (q >= qe)
                        {
                          bad = 9;
                          goto end;
                        }
                      __builtin_strncpy (q, (const char *) &vport_buf, strlen ((const char *) &vport_buf));
                      q = q + (unsigned int) strlen ((const char *) &vport_buf);
                      if (q >= qe)
                        {
                          bad = 10;
                          goto end;
                        }
                      goto <D.39813>;
                      <D.39812>:;
                      if (p >= pe)
                        {
                          bad = 11;
                          goto end;
                        }
                      p++ ;
                      <D.39813>:;
                      if ((p != 0B && (unsigned char) *p != 0) && *p + 208 <= 9) goto <D.39812>; else goto <D.39814>;
                      <D.39814>:;
                      has_video++ ;
                    }
                }
            }
        }
    }
  goto <D.39816>;
  <D.39815>:;
  if (p >= pe)
    {
      bad = 12;
      goto end;
    }
  if (q >= qe)
    {
      bad = 13;
      goto end;
    }
  *q++  = *p++ ;
  <D.39816>:;
  if ((p != 0B && (unsigned char) *p != 0) && (unsigned char) *p != 10) goto <D.39815>; else goto <D.39817>;
  <D.39817>:;
  if (p >= pe)
    {
      bad = 14;
      goto end;
    }
  if (q >= qe)
    {
      bad = 15;
      goto end;
    }
  *q++  = *p++ ;
  <D.39819>:;
  if (p != 0B && (unsigned char) *p != 0) goto <D.39818>; else goto <D.39820>;
  <D.39820>:;
  end:;
  if (bad != 0)
    {
      return;
    }
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7394, (const char *) session, 7, (const char *) "%s too late.\n", switch_channel_get_name (session->channel));
      return;
    }
  if ((has_ip | has_audio) == 0)
    {
      switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7400, (const char *) session, 7, (const char *) "%s SDP has no audio in it.\n%s\n", switch_channel_get_name (session->channel), smh->mparams->local_sdp_str);
      return;
    }
  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7406, (const char *) session, 7, (const char *) "%s Patched SDP\n---\n%s\n+++\n%s\n", switch_channel_get_name (session->channel), smh->mparams->local_sdp_str, new_sdp);
  switch_core_media_set_local_sdp (session, (const char *) new_sdp, 0);
}



;; Function switch_core_media_start_udptl (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_start_udptl";
  static const char __func__[30] = "switch_core_media_start_udptl";

    static const char __func__[30] = "switch_core_media_start_udptl";
    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_start_udptl";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7419, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
    {
      {
        char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
        switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
        const char * err;
        const char * val;

                char * remote_host = switch_rtp_get_remote_host (a_engine->rtp_session);
                switch_port_t remote_port = switch_rtp_get_remote_port (a_engine->rtp_session);
                const char * err;
                const char * val;
        switch_channel_clear_flag (session->channel, 99);
        switch_rtp_udptl_mode (a_engine->rtp_session);
        if (t38_options == 0B || t38_options->remote_ip == 0B)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7441, (const char *) session, 7, (const char *) "No remote address\n");
            return;
          }
        if (((remote_host != 0B && (short unsigned int) remote_port != 0) && (short unsigned int) t38_options->remote_port == (short unsigned int) remote_port) && TARGET_EXPR <D.39841, {
          size_t __s1_len;
          size_t __s2_len;

                    size_t __s1_len;
                    size_t __s2_len;
          D.39841 = __builtin_strcmp ((const char *) remote_host, t38_options->remote_ip);
        }> == 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7446, (const char *) session, 7, (const char *) "Remote address:port [%s:%d] has not changed.\n", t38_options->remote_ip, (int) t38_options->remote_port);
            return;
          }
        if ((unsigned int) switch_rtp_set_remote_address (a_engine->rtp_session, t38_options->remote_ip, t38_options->remote_port, 0, 1, &err) != 0)
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7453, (const char *) session, 3, (const char *) "IMAGE UDPTL REPORTS ERROR: [%s]\n", err);
          }
        else
          {
            switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7455, (const char *) session, 7, (const char *) "IMAGE UDPTL CHANGING DEST TO: [%s:%d]\n", t38_options->remote_ip, (int) t38_options->remote_port);
            if (((int) switch_media_handle_test_media_flag (smh, 10) == 0 && switch_channel_test_flag (session->channel, 106) == 0) && ((val = switch_channel_get_variable_dup (session->channel, (const char *) "disable_udptl_auto_adjust", 1, -1)) == 0B || switch_true (val) == 0))
              {
                switch_rtp_set_flag (a_engine->rtp_session, 7);
              }
          }
      }
    }
}



;; Function switch_core_media_receive_message (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  switch_status_t status = 0;
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_receive_message";
  void end = <<< error >>>;
  static const char __func__[34] = "switch_core_media_receive_message";
  void end_lock = <<< error >>>;

    static const char __func__[34] = "switch_core_media_receive_message";
    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_receive_message";
    struct switch_media_handle_t * smh;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    switch_status_t status = 0;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7477, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      return 1;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  switch ((unsigned int) msg->message_id)
    {
      case 46:;
      if (switch_channel_test_flag (session->channel, 82) != 0)
        {
          switch_channel_set_flag_value (session->channel, 122, 1);
        }
      goto <D.39852>;
      case 17:;
      if (v_engine->rtp_session != 0B)
        {
          switch_rtp_video_refresh (v_engine->rtp_session);
        }
      goto <D.39852>;
      case 25:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          if (msg->numeric_arg != 0)
            {
              switch_rtp_set_flag (a_engine->rtp_session, 19);
            }
          else
            {
              switch_rtp_clear_flag (a_engine->rtp_session, 19);
            }
        }
      goto <D.39852>;
      case 32:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          {
            int len = 0;
            int maxlen = 0;
            int qlen = 0;
            int maxqlen = 50;
            int max_drift = 0;

                        int len = 0;
                        int maxlen = 0;
                        int qlen = 0;
                        int maxqlen = 50;
                        int max_drift = 0;
            if (msg->string_arg != 0B)
              {
                {
                  char * p;
                  char * q;
                  const char * s;

                                    char * p;
                                    char * q;
                                    const char * s;
                  if (strcasecmp (msg->string_arg, (const char *) "pause") == 0)
                    {
                      switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 1);
                      goto end;
                    }
                  else
                    {
                      if (strcasecmp (msg->string_arg, (const char *) "resume") == 0)
                        {
                          switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 0);
                          goto end;
                        }
                      else
                        {
                          if (strncasecmp (msg->string_arg, (const char *) "debug:", 6) == 0)
                            {
                              s = msg->string_arg + 6;
                              if (s != 0B && TARGET_EXPR <D.39873, {
                                size_t __s1_len;
                                size_t __s2_len;

                                                                size_t __s1_len;
                                                                size_t __s2_len;
                                D.39873 = __s2_len = 3;, __s2_len <= 3; ? TARGET_EXPR <D.39872, {
                                  const unsigned char * __s1 = (const unsigned char *) s;
                                  register int __result = (int) *__s1 - (int) *(const unsigned char *) "off";

                                                                    const unsigned char * __s1 = (const unsigned char *) s;
                                                                    register int __result = (int) *__s1 - (int) *(const unsigned char *) "off";
                                  {
                                    if (__s2_len != 0 && __result == 0)
                                      {
                                        __result = (int) *(__s1 + 1) - (int) *((const unsigned char *) "off" + 1);
                                        if (__s2_len > 1 && __result == 0)
                                          {
                                            __result = (int) *(__s1 + 2) - (int) *((const unsigned char *) "off" + 2);
                                            if (__s2_len > 2 && __result == 0)
                                              {
                                                __result = (int) *(__s1 + 3) - (int) *((const unsigned char *) "off" + 3);
                                              }
                                          }
                                      }
                                  }
                                  D.39872 = __result;
                                }> : __builtin_strcmp (s, (const char *) "off");
                              }> == 0)
                                {
                                  s = 0B;
                                }
                              status = switch_rtp_debug_jitter_buffer (a_engine->rtp_session, s);
                              goto end;
                            }
                        }
                    }
                  if ((len = atoi (msg->string_arg)) != 0)
                    {
                      qlen = len / (a_engine->read_impl.microseconds_per_packet / 1000);
                      if (qlen <= 0)
                        {
                          qlen = 3;
                        }
                    }
                  if (qlen != 0)
                    {
                      if ((p = __builtin_strchr (msg->string_arg, 58)) != 0B)
                        {
                          p++ ;
                          maxlen = (int) atol ((const char *) p);
                          if ((q = __builtin_strchr ((const char *) p, 58)) != 0B)
                            {
                              q++ ;
                              max_drift = ABS_EXPR <(int) atol ((const char *) q)>;
                            }
                        }
                    }
                  if (maxlen != 0)
                    {
                      maxqlen = maxlen / (a_engine->read_impl.microseconds_per_packet / 1000);
                    }
                }
              }
            if (qlen != 0)
              {
                if (maxqlen < qlen)
                  {
                    maxqlen = qlen * 5;
                  }
                if ((unsigned int) switch_rtp_activate_jitter_buffer (a_engine->rtp_session, (uint32_t) qlen, (uint32_t) maxqlen, a_engine->read_impl.samples_per_packet, a_engine->read_impl.samples_per_second, (uint32_t) max_drift) == 0)
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7577, (const char *) session, 7, (const char *) "Setting Jitterbuffer to %dms (%d frames) (%d max frames) (%d max drift)\n", len, qlen, maxqlen, max_drift);
                    switch_channel_set_flag_value (session->channel, 57, 1);
                    if (switch_false (switch_channel_get_variable_dup (session->channel, (const char *) "rtp_jitter_buffer_plc", 1, -1)) == 0)
                      {
                        switch_channel_set_flag_value (session->channel, 58, 1);
                      }
                  }
                else
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7585, (const char *) session, 4, (const char *) "Error Setting Jitterbuffer to %dms (%d frames)\n", len, qlen);
                  }
              }
            else
              {
                switch_rtp_deactivate_jitter_buffer (a_engine->rtp_session);
              }
          }
        }
      goto <D.39852>;
      case 24:;
      {
        struct switch_rtp_t * rtp = a_engine->rtp_session;
        const char * direction = msg->string_array_arg[0];

                struct switch_rtp_t * rtp = a_engine->rtp_session;
                const char * direction = msg->string_array_arg[0];
        if (direction != 0B && (unsigned char) *direction == 118)
          {
            direction++ ;
            rtp = v_engine->rtp_session;
          }
        if (((unsigned char) switch_rtp_ready (rtp) != 0 && _zstr (direction) == 0) && _zstr (msg->string_array_arg[1]) == 0)
          {
            {
              switch_rtp_flag_t flags[39] = {0};
              int both = strcasecmp (direction, (const char *) "both") == 0;
              int set = 0;

                            switch_rtp_flag_t flags[39] = {0};
                            int both = strcasecmp (direction, (const char *) "both") == 0;
                            int set = 0;
              if (both != 0 || strcasecmp (direction, (const char *) "read") == 0)
                {
                  flags[28]++ ;
                  set++ ;
                }
              if (both != 0 || strcasecmp (direction, (const char *) "write") == 0)
                {
                  flags[29]++ ;
                  set++ ;
                }
              if (set != 0)
                {
                  if (switch_true (msg->string_array_arg[1]) != 0)
                    {
                      switch_rtp_set_flags (rtp, (switch_rtp_flag_t *) &flags);
                    }
                  else
                    {
                      switch_rtp_clear_flags (rtp, (switch_rtp_flag_t *) &flags);
                    }
                }
              else
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7627, (const char *) session, 3, (const char *) "Invalid Options\n");
                }
            }
          }
      }
      goto end;
      case 19:;
      if (a_engine->rtp_session != 0B && switch_rtp_test_flag (a_engine->rtp_session, 15) != 0)
        {
          switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7634, (const char *) session, 4, (const char *) "Pass 2833 mode may not work on a transcoded call.\n");
        }
      goto end;
      case 4:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          {
            const char * val;
            int ok = 0;

                        const char * val;
                        int ok = 0;
            if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_jitter_buffer_during_bridge", 1, -1)) == 0B || switch_false (val) != 0)
              {
                if (switch_channel_test_flag (session->channel, 57) != 0 && switch_channel_test_cap_partner (session->channel, 5) != 0)
                  {
                    switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7647, (const char *) session, 7, (const char *) "%s PAUSE Jitterbuffer\n", switch_channel_get_name (session->channel));
                    switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 1);
                    smh->flags = (smh_flag_t) ((unsigned int) smh->flags | 4);
                  }
              }
            if (switch_channel_test_flag (session->channel, 100) != 0 && switch_channel_test_flag_partner (session->channel, 36) != 0)
              {
                switch_rtp_set_flag (a_engine->rtp_session, 15);
                switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7656, (const char *) session, 7, (const char *) "%s activate passthru 2833 mode.\n", switch_channel_get_name (session->channel));
              }
            if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_notimer_during_bridge", 1, -1)) != 0B)
              {
                ok = switch_true (val);
              }
            else
              {
                ok = (int) switch_channel_test_flag (session->channel, 105);
              }
            if (ok != 0 && switch_rtp_test_flag (a_engine->rtp_session, 3) == 0)
              {
                ok = 0;
              }
            if (ok != 0)
              {
                switch_rtp_clear_flag (a_engine->rtp_session, 3);
                switch_channel_set_flag_value (session->channel, 99, 1);
              }
            if (ok != 0 && switch_channel_test_flag (session->channel, 99) != 0)
              {
                ok = 0;
              }
            else
              {
                if ((val = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_autoflush_during_bridge", 1, -1)) != 0B)
                  {
                    ok = switch_true (val);
                  }
                else
                  {
                    ok = (int) smh->media_flags[14];
                  }
              }
            if (ok != 0)
              {
                rtp_flush_read_buffer (a_engine->rtp_session, 1);
                switch_channel_set_flag_value (session->channel, 104, 1);
              }
            else
              {
                rtp_flush_read_buffer (a_engine->rtp_session, 0);
              }
          }
        }
      goto end;
      case 5:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          if (((unsigned int) smh->flags & 4) != 0)
            {
              smh->flags = (smh_flag_t) ((unsigned int) smh->flags & 4294967291);
              if (switch_channel_test_flag (session->channel, 57) != 0)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7704, (const char *) session, 7, (const char *) "%s RESUME Jitterbuffer\n", switch_channel_get_name (session->channel));
                  switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 0);
                }
            }
          if (switch_rtp_test_flag (a_engine->rtp_session, 15) != 0)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7712, (const char *) session, 7, (const char *) "%s deactivate passthru 2833 mode.\n", switch_channel_get_name (session->channel));
              switch_rtp_clear_flag (a_engine->rtp_session, 15);
            }
          if (switch_channel_test_flag (session->channel, 99) != 0)
            {
              if (switch_rtp_test_flag (a_engine->rtp_session, 12) == 0 && switch_rtp_test_flag (a_engine->rtp_session, 19) == 0)
                {
                  switch_rtp_set_flag (a_engine->rtp_session, 3);
                }
              switch_channel_clear_flag (session->channel, 99);
            }
          if (switch_channel_test_flag (session->channel, 104) != 0)
            {
              rtp_flush_read_buffer (a_engine->rtp_session, 2);
              switch_channel_clear_flag (session->channel, 104);
            }
          else
            {
              rtp_flush_read_buffer (a_engine->rtp_session, 0);
            }
        }
      goto end;
      case 20:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          rtp_flush_read_buffer (a_engine->rtp_session, 0);
        }
      goto end;
      case 8:;
      if (session->track_duration != 0)
        {
          switch_core_session_enable_heartbeat (session, session->track_duration);
        }
      goto <D.39852>;
      case 9:;
      {
        const char * uuid;
        struct switch_core_session_t * other_session;
        struct switch_channel_t * other_channel;
        const char * ip = 0B;
        const char * port = 0B;

                const char * uuid;
                struct switch_core_session_t * other_session;
                struct switch_channel_t * other_channel;
                const char * ip = 0B;
                const char * port = 0B;
        switch_channel_set_flag_value (session->channel, 15, 1);
        a_engine->codec_negotiated = 0;
        v_engine->codec_negotiated = 0;
        switch_core_media_set_local_sdp (session, 0B, 0);
        if (switch_true (switch_channel_get_variable_dup (session->channel, (const char *) "bypass_keep_codec", 1, -1)) != 0)
          {
            switch_channel_set_variable_var_check (session->channel, (const char *) "absolute_codec_string", switch_channel_get_variable_dup (session->channel, (const char *) "ep_codec_string", 1, -1), 1);
          }
        if ((uuid = switch_channel_get_partner_uuid (session->channel)) != 0B && (other_session = switch_core_session_perform_locate (uuid, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7768)) != 0B)
          {
            other_channel = switch_core_session_get_channel (other_session);
            ip = switch_channel_get_variable_dup (other_channel, (const char *) "remote_media_ip", 1, -1);
            port = switch_channel_get_variable_dup (other_channel, (const char *) "remote_media_port", 1, -1);
            switch_core_session_rwunlock (other_session);
            if (ip != 0B && port != 0B)
              {
                switch_core_media_prepare_codecs (session, 1);
                clear_pmaps (a_engine);
                clear_pmaps (v_engine);
                switch_core_media_gen_local_sdp (session, 0, ip, (short unsigned int) atoi (port), 0B, 1);
              }
          }
        if (smh->mparams->local_sdp_str == 0B)
          {
            switch_core_media_absorb_sdp (session);
          }
        if (session->track_duration != 0)
          {
            switch_core_session_enable_heartbeat (session, session->track_duration);
          }
      }
      goto <D.39852>;
      default:;
      goto <D.39852>;
    }
  <D.39852>:;
  if (smh->mutex != 0B)
    {
      switch_mutex_lock (smh->mutex);
    }
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      status = 1;
      goto end_lock;
    }
  switch ((unsigned int) msg->message_id)
    {
      case 40:;
      {
        struct switch_core_session_t * nsession;

                struct switch_core_session_t * nsession;
        if (msg->string_arg != 0B)
          {
            switch_channel_set_variable_var_check (session->channel, (const char *) "absolute_codec_string", 0B, 1);
            if ((unsigned char) *msg->string_arg == 61)
              {
                switch_channel_set_variable_var_check (session->channel, (const char *) "codec_string", msg->string_arg, 1);
              }
            else
              {
                switch_channel_set_variable_printf (session->channel, (const char *) "codec_string", (const char *) "=%s%s%s,%s", v_engine->cur_payload_map->rm_encoding != 0B ? v_engine->cur_payload_map->rm_encoding : (char *) "", v_engine->cur_payload_map->rm_encoding != 0B ? (char *) "," : (char *) "", a_engine->cur_payload_map->rm_encoding, msg->string_arg);
              }
            a_engine->codec_negotiated = 0;
            v_engine->codec_negotiated = 0;
            switch_channel_clear_flag (session->channel, 98);
            switch_core_media_prepare_codecs (session, 1);
            switch_core_media_check_video_codecs (session);
            switch_core_media_gen_local_sdp (session, 0, 0B, 0, 0B, 1);
          }
        switch_media_handle_set_media_flag (smh, 7);
        if (msg->numeric_arg != 0 && (unsigned int) switch_core_session_perform_get_partner (session, &nsession, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7835) == 0)
          {
            msg->numeric_arg = 0;
            switch_core_session_perform_receive_message (nsession, msg, (const char *) "src/switch_core_media.c", (const char *) &__func__, 7837);
            switch_core_session_rwunlock (nsession);
          }
      }
      goto <D.39898>;
      case 37:;
      if ((unsigned char) switch_rtp_ready (a_engine->rtp_session) != 0)
        {
          if (msg->numeric_arg != 0)
            {
              if (switch_channel_test_flag (session->channel, 57) != 0)
                {
                  switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 1);
                  smh->flags = (smh_flag_t) ((unsigned int) smh->flags | 4);
                }
              rtp_flush_read_buffer (a_engine->rtp_session, 2);
            }
          else
            {
              if (((unsigned int) smh->flags & 4) != 0)
                {
                  smh->flags = (smh_flag_t) ((unsigned int) smh->flags & 4294967291);
                  if (switch_channel_test_flag (session->channel, 57) != 0)
                    {
                      switch_rtp_pause_jitter_buffer (a_engine->rtp_session, 0);
                    }
                }
            }
        }
      goto <D.39898>;
      case 30:;
      {
        struct switch_t38_options_t * t38_options = (struct switch_t38_options_t *) switch_channel_get_private (session->channel, (const char *) "t38_options");

                struct switch_t38_options_t * t38_options = (struct switch_t38_options_t *) switch_channel_get_private (session->channel, (const char *) "t38_options");
        if (t38_options != 0B)
          {
            switch_core_media_start_udptl (session, t38_options);
          }
      }
      default:;
      goto <D.39898>;
    }
  <D.39898>:;
  end_lock:;
  if (smh->mutex != 0B)
    {
      switch_mutex_unlock (smh->mutex);
    }
  end:;
  if (switch_channel_check_signal (session->channel, 1) != 0 || (unsigned int) switch_channel_get_state (session->channel) > 9)
    {
      status = 1;
    }
  return status;
}



;; Function switch_core_media_break (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_break";

    static const char __PRETTY_FUNCTION__[24] = "switch_core_media_break";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7902, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_break (smh->engines[(unsigned int) type].rtp_session);
    }
}



;; Function switch_core_media_kill_socket (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_kill_socket";

    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_kill_socket";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7918, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_kill_socket (smh->engines[(unsigned int) type].rtp_session);
    }
}



;; Function switch_core_media_queue_rfc2833 (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[32] = "switch_core_media_queue_rfc2833";

    static const char __PRETTY_FUNCTION__[32] = "switch_core_media_queue_rfc2833";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7934, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      return switch_rtp_queue_rfc2833 (smh->engines[(unsigned int) type].rtp_session, dtmf);
    }
  return 1;
}



;; Function switch_core_media_queue_rfc2833_in (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[35] = "switch_core_media_queue_rfc2833_in";

    static const char __PRETTY_FUNCTION__[35] = "switch_core_media_queue_rfc2833_in";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7952, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      return switch_rtp_queue_rfc2833_in (smh->engines[(unsigned int) type].rtp_session, dtmf);
    }
  return 1;
}



;; Function switch_core_media_ready (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[24] = "switch_core_media_ready";

    static const char __PRETTY_FUNCTION__[24] = "switch_core_media_ready";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7970, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0;
    }
  return switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session);
}



;; Function switch_core_media_set_rtp_flag (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_set_rtp_flag";

    static const char __PRETTY_FUNCTION__[31] = "switch_core_media_set_rtp_flag";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 7984, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_set_flag (smh->engines[(unsigned int) type].rtp_session, flag);
    }
}



;; Function switch_core_media_clear_rtp_flag (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[33] = "switch_core_media_clear_rtp_flag";

    static const char __PRETTY_FUNCTION__[33] = "switch_core_media_clear_rtp_flag";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8000, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_clear_flag (smh->engines[(unsigned int) type].rtp_session, flag);
    }
}



;; Function switch_core_media_set_telephony_event (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_telephony_event";

    static const char __PRETTY_FUNCTION__[38] = "switch_core_media_set_telephony_event";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8016, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_set_telephony_event (smh->engines[(unsigned int) type].rtp_session, te);
    }
}



;; Function switch_core_media_set_telephony_recv_event (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[43] = "switch_core_media_set_telephony_recv_event";

    static const char __PRETTY_FUNCTION__[43] = "switch_core_media_set_telephony_recv_event";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8032, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      switch_rtp_set_telephony_recv_event (smh->engines[(unsigned int) type].rtp_session, te);
    }
}



;; Function switch_core_media_get_stats (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[28] = "switch_core_media_get_stats";

    static const char __PRETTY_FUNCTION__[28] = "switch_core_media_get_stats";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8048, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0B;
    }
  if (smh->engines[(unsigned int) type].rtp_session != 0B)
    {
      return switch_rtp_get_stats (smh->engines[(unsigned int) type].rtp_session, pool);
    }
  return 0B;
}



;; Function switch_core_media_udptl_mode (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[29] = "switch_core_media_udptl_mode";

    static const char __PRETTY_FUNCTION__[29] = "switch_core_media_udptl_mode";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8066, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      return switch_rtp_udptl_mode (smh->engines[(unsigned int) type].rtp_session);
    }
  return 1;
}



;; Function switch_core_media_get_jb (null)
;; enabled by -tree-original

{
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[25] = "switch_core_media_get_jb";

    static const char __PRETTY_FUNCTION__[25] = "switch_core_media_get_jb";
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8084, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 0B;
    }
  if ((unsigned char) switch_rtp_ready (smh->engines[(unsigned int) type].rtp_session) != 0)
    {
      return switch_rtp_get_jitter_buffer (smh->engines[(unsigned int) type].rtp_session);
    }
  return 0B;
}



;; Function switch_core_media_set_sdp_codec_string (null)
;; enabled by -tree-original

{
  struct sdp_parser_t * parser;
  struct sdp_session_t * sdp;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_set_sdp_codec_string";

    static const char __PRETTY_FUNCTION__[39] = "switch_core_media_set_sdp_codec_string";
    struct sdp_parser_t * parser;
    struct sdp_session_t * sdp;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8105, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((parser = sdp_parse (0B, r_sdp, (int) strlen (r_sdp), 0)) != 0B)
    {
      if ((sdp = sdp_session (parser)) != 0B)
        {
          switch_core_media_set_r_sdp_codec_string (session, switch_core_media_get_codec_string (session), sdp, sdp_type);
        }
      sdp_parser_free (parser);
    }
}



;; Function add_audio_codec (null)
;; enabled by -tree-original

{
  int codec_ms = ptime;
  uint32_t map_bit_rate = 0;
  char ptstr[20] = "";
  char ratestr[20] = "";
  char bitstr[20] = "";
  struct switch_codec_fmtp_t codec_fmtp = {.actual_samples_per_second=0};

    int codec_ms = ptime;
    uint32_t map_bit_rate = 0;
    char ptstr[20] = "";
    char ratestr[20] = "";
    char bitstr[20] = "";
    struct switch_codec_fmtp_t codec_fmtp = {.actual_samples_per_second=0};
  if (codec_ms == 0)
    {
      codec_ms = (int) switch_default_ptime (map->rm_encoding, (uint32_t) map->rm_pt);
    }
  map_bit_rate = switch_known_bitrate ((unsigned char) map->rm_pt);
  if (ptime == 0 && strcasecmp (map->rm_encoding, (const char *) "g723") == 0)
    {
      ptime = codec_ms = 30;
    }
  if (_zstr (map->rm_fmtp) != 0)
    {
      if (strcasecmp (map->rm_encoding, (const char *) "ilbc") == 0)
        {
          ptime = codec_ms = 30;
          map_bit_rate = 13330;
        }
      else
        {
          if (strcasecmp (map->rm_encoding, (const char *) "isac") == 0)
            {
              ptime = codec_ms = 30;
              map_bit_rate = 32000;
            }
        }
    }
  else
    {
      if ((unsigned int) switch_core_codec_parse_fmtp (map->rm_encoding, map->rm_fmtp, (uint32_t) map->rm_rate, &codec_fmtp) == 0)
        {
          if (codec_fmtp.bits_per_second != 0)
            {
              map_bit_rate = (uint32_t) codec_fmtp.bits_per_second;
            }
          if (codec_fmtp.microseconds_per_packet != 0)
            {
              codec_ms = codec_fmtp.microseconds_per_packet / 1000;
            }
        }
    }
  if (map->rm_rate != 0)
    {
      switch_snprintf ((char *) &ratestr, 20, (const char *) "@%uh", (unsigned int) map->rm_rate);
    }
  if (codec_ms != 0)
    {
      switch_snprintf ((char *) &ptstr, 20, (const char *) "@%di", codec_ms);
    }
  if (map_bit_rate != 0)
    {
      switch_snprintf ((char *) &bitstr, 20, (const char *) "@%db", map_bit_rate);
    }
  switch_snprintf (buf + (unsigned int) strlen ((const char *) buf), buflen - (switch_size_t) strlen ((const char *) buf), (const char *) ",%s%s%s%s", map->rm_encoding, (char *) &ratestr, (char *) &ptstr, (char *) &bitstr);
}



;; Function switch_core_media_set_r_sdp_codec_string (null)
;; enabled by -tree-original

{
  char buf[1024] = {0};
  struct sdp_media_t * m;
  struct sdp_attribute_t * attr;
  int ptime = 0;
  int dptime = 0;
  struct sdp_connection_t * connection;
  struct sdp_rtpmap_t * map;
  short int match = 0;
  int i;
  int already_did[128] = {0};
  int num_codecs = 0;
  char * codec_order[50];
  const struct switch_codec_implementation_t * codecs[50] = {0B};
  struct switch_channel_t * channel = switch_core_session_get_channel (session);
  int prefer_sdp = 0;
  const char * var;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[41] = "switch_core_media_set_r_sdp_codec_string";
  static const char __func__[41] = "switch_core_media_set_r_sdp_codec_string";

    static const char __func__[41] = "switch_core_media_set_r_sdp_codec_string";
    static const char __PRETTY_FUNCTION__[41] = "switch_core_media_set_r_sdp_codec_string";
    char buf[1024] = {0};
    struct sdp_media_t * m;
    struct sdp_attribute_t * attr;
    int ptime = 0;
    int dptime = 0;
    struct sdp_connection_t * connection;
    struct sdp_rtpmap_t * map;
    short int match = 0;
    int i;
    int already_did[128] = {0};
    int num_codecs = 0;
    char * codec_order[50];
    const struct switch_codec_implementation_t * codecs[50] = {0B};
    struct switch_channel_t * channel = switch_core_session_get_channel (session);
    int prefer_sdp = 0;
    const char * var;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8198, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  if ((var = switch_channel_get_variable_dup (channel, (const char *) "ep_codec_prefer_sdp", 1, -1)) != 0B && switch_true (var) != 0)
    {
      prefer_sdp = 1;
    }
  if (_zstr (codec_string) == 0)
    {
      {
        char * tmp_codec_string;

                char * tmp_codec_string;
        if ((tmp_codec_string = __strdup (codec_string)) != 0B)
          {
            num_codecs = (int) switch_separate_string (tmp_codec_string, 44, (char * *) &codec_order, 50);
            num_codecs = switch_loadable_module_get_codecs_sorted ((const struct switch_codec_implementation_t * *) &codecs, 50, (char * *) &codec_order, num_codecs);
            if (tmp_codec_string != 0B)
              {
                free ((void *) tmp_codec_string);
                tmp_codec_string = 0B;
              }
          }
      }
    }
  else
    {
      num_codecs = switch_loadable_module_get_codecs ((const struct switch_codec_implementation_t * *) &codecs, 50);
    }
  if (channel == 0B || num_codecs == 0)
    {
      return;
    }
  attr = sdp->sdp_attributes;
  goto <D.40034>;
  <D.40033>:;
  if (_zstr (attr->a_name) != 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.40031>;
    }
  if (strcasecmp (attr->a_name, (const char *) "ptime") == 0)
    {
      dptime = atoi (attr->a_value);
      goto <D.40032>;
    }
  <D.40031>:;
  attr = attr->a_next;
  <D.40034>:;
  if (attr != 0B) goto <D.40033>; else goto <D.40032>;
  <D.40032>:;
  switch_core_media_find_zrtp_hash (session, sdp);
  switch_core_media_pass_zrtp_hash (session);
  m = sdp->sdp_media;
  goto <D.40043>;
  <D.40042>:;
  ptime = dptime;
  if ((unsigned int) m->m_type + 4294967294 <= 1 && m->m_port != 0)
    {
      map = m->m_rtpmaps;
      goto <D.40040>;
      <D.40039>:;
      attr = m->m_attributes;
      goto <D.40038>;
      <D.40037>:;
      if (_zstr (attr->a_name) != 0)
        {
          // predicted unlikely by continue predictor.;
          goto <D.40035>;
        }
      if (strcasecmp (attr->a_name, (const char *) "ptime") == 0 && attr->a_value != 0B)
        {
          ptime = atoi (attr->a_value);
          goto <D.40036>;
        }
      <D.40035>:;
      attr = attr->a_next;
      <D.40038>:;
      if (attr != 0B) goto <D.40037>; else goto <D.40036>;
      <D.40036>:;
      switch_core_media_add_payload_map (session, (unsigned int) m->m_type != 2, map->rm_encoding, map->rm_fmtp, sdp_type, (uint32_t) map->rm_pt, (uint32_t) map->rm_rate, (uint32_t) ptime, 0);
      map = map->rm_next;
      <D.40040>:;
      if (map != 0B) goto <D.40039>; else goto <D.40041>;
      <D.40041>:;
    }
  m = m->m_next;
  <D.40043>:;
  if (m != 0B) goto <D.40042>; else goto <D.40044>;
  <D.40044>:;
  m = sdp->sdp_media;
  goto <D.40078>;
  <D.40077>:;
  ptime = dptime;
  if ((unsigned int) m->m_type == 8 && m->m_port != 0)
    {
      switch_snprintf ((char *) &buf + (unsigned int) strlen ((const char *) &buf), 1024 - (unsigned int) strlen ((const char *) &buf), (const char *) ",t38");
    }
  else
    {
      if ((unsigned int) m->m_type == 2 && m->m_port != 0)
        {
          attr = m->m_attributes;
          goto <D.40048>;
          <D.40047>:;
          if (_zstr (attr->a_name) != 0)
            {
              // predicted unlikely by continue predictor.;
              goto <D.40045>;
            }
          if (strcasecmp (attr->a_name, (const char *) "ptime") == 0 && attr->a_value != 0B)
            {
              ptime = atoi (attr->a_value);
              goto <D.40046>;
            }
          <D.40045>:;
          attr = attr->a_next;
          <D.40048>:;
          if (attr != 0B) goto <D.40047>; else goto <D.40046>;
          <D.40046>:;
          connection = sdp->sdp_connection;
          if (m->m_connections != 0B)
            {
              connection = m->m_connections;
            }
          if (connection == 0B)
            {
              switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8285, (const char *) switch_channel_get_session (channel), 3, (const char *) "Cannot find a c= line in the sdp at media or session level!\n");
              goto <D.40050>;
            }
          if ((unsigned int) switch_channel_direction (channel) == 0 || prefer_sdp != 0)
            {
              map = m->m_rtpmaps;
              goto <D.40057>;
              <D.40056>:;
              if ((int) map->rm_pt > 127 || already_did[(int) map->rm_pt] != 0)
                {
                  // predicted unlikely by continue predictor.;
                  goto <D.40051>;
                }
              i = 0;
              goto <D.40055>;
              <D.40054>:;
              {
                const struct switch_codec_implementation_t * imp = codecs[i];

                                const struct switch_codec_implementation_t * imp = codecs[i];
                if ((_zstr (map->rm_encoding) != 0 || (int) smh->mparams->ndlb & 1) && (int) map->rm_pt <= 95)
                  {
                    match = (int) map->rm_pt == (int) imp->ianacode;
                  }
                else
                  {
                    if (map->rm_encoding != 0B)
                      {
                        match = strcasecmp (map->rm_encoding, (const char *) imp->iananame) == 0;
                      }
                    else
                      {
                        match = 0;
                      }
                  }
                if (match != 0)
                  {
                    add_audio_codec (map, ptime, (char *) &buf, 1024);
                    goto <D.40053>;
                  }
              }
              i++ ;
              <D.40055>:;
              if (i < num_codecs) goto <D.40054>; else goto <D.40053>;
              <D.40053>:;
              <D.40051>:;
              map = map->rm_next;
              <D.40057>:;
              if (map != 0B) goto <D.40056>; else goto <D.40058>;
              <D.40058>:;
            }
          else
            {
              i = 0;
              goto <D.40066>;
              <D.40065>:;
              {
                const struct switch_codec_implementation_t * imp = codecs[i];

                                const struct switch_codec_implementation_t * imp = codecs[i];
                if (((unsigned int) imp->codec_type != 0 || (signed char) imp->ianacode < 0) || already_did[(int) imp->ianacode] != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.40060>;
                  }
                map = m->m_rtpmaps;
                goto <D.40064>;
                <D.40063>:;
                if ((int) map->rm_pt > 127 || already_did[(int) map->rm_pt] != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.40061>;
                  }
                if ((_zstr (map->rm_encoding) != 0 || (int) smh->mparams->ndlb & 1) && (int) map->rm_pt <= 95)
                  {
                    match = (int) map->rm_pt == (int) imp->ianacode;
                  }
                else
                  {
                    if (map->rm_encoding != 0B)
                      {
                        match = strcasecmp (map->rm_encoding, (const char *) imp->iananame) == 0;
                      }
                    else
                      {
                        match = 0;
                      }
                  }
                if (match != 0)
                  {
                    add_audio_codec (map, ptime, (char *) &buf, 1024);
                    goto <D.40062>;
                  }
                <D.40061>:;
                map = map->rm_next;
                <D.40064>:;
                if (map != 0B) goto <D.40063>; else goto <D.40062>;
                <D.40062>:;
              }
              <D.40060>:;
              i++ ;
              <D.40066>:;
              if (i < num_codecs) goto <D.40065>; else goto <D.40067>;
              <D.40067>:;
            }
        }
      else
        {
          if ((unsigned int) m->m_type == 3 && m->m_port != 0)
            {
              connection = sdp->sdp_connection;
              if (m->m_connections != 0B)
                {
                  connection = m->m_connections;
                }
              if (connection == 0B)
                {
                  switch_log_printf (3, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8352, (const char *) switch_channel_get_session (channel), 3, (const char *) "Cannot find a c= line in the sdp at media or session level!\n");
                  goto <D.40050>;
                }
              i = 0;
              goto <D.40075>;
              <D.40074>:;
              {
                const struct switch_codec_implementation_t * imp = codecs[i];

                                const struct switch_codec_implementation_t * imp = codecs[i];
                if (((unsigned int) imp->codec_type != 1 || (signed char) imp->ianacode < 0) || already_did[(int) imp->ianacode] != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.40069>;
                  }
                if ((unsigned int) switch_channel_direction (session->channel) == 0 && switch_channel_test_flag (session->channel, 114) != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.40069>;
                  }
                map = m->m_rtpmaps;
                goto <D.40073>;
                <D.40072>:;
                if ((int) map->rm_pt > 127 || already_did[(int) map->rm_pt] != 0)
                  {
                    // predicted unlikely by continue predictor.;
                    goto <D.40070>;
                  }
                if ((_zstr (map->rm_encoding) != 0 || (int) smh->mparams->ndlb & 1) && (int) map->rm_pt <= 95)
                  {
                    match = (int) map->rm_pt == (int) imp->ianacode;
                  }
                else
                  {
                    if (map->rm_encoding != 0B)
                      {
                        match = strcasecmp (map->rm_encoding, (const char *) imp->iananame) == 0;
                      }
                    else
                      {
                        match = 0;
                      }
                  }
                if (match != 0)
                  {
                    if (ptime > 0)
                      {
                        switch_snprintf ((char *) &buf + (unsigned int) strlen ((const char *) &buf), 1024 - (unsigned int) strlen ((const char *) &buf), (const char *) ",%s@%uh@%di", imp->iananame, (unsigned int) map->rm_rate, ptime);
                      }
                    else
                      {
                        switch_snprintf ((char *) &buf + (unsigned int) strlen ((const char *) &buf), 1024 - (unsigned int) strlen ((const char *) &buf), (const char *) ",%s@%uh", imp->iananame, (unsigned int) map->rm_rate);
                      }
                    already_did[(int) imp->ianacode] = 1;
                    goto <D.40071>;
                  }
                <D.40070>:;
                map = map->rm_next;
                <D.40073>:;
                if (map != 0B) goto <D.40072>; else goto <D.40071>;
                <D.40071>:;
              }
              <D.40069>:;
              i++ ;
              <D.40075>:;
              if (i < num_codecs) goto <D.40074>; else goto <D.40076>;
              <D.40076>:;
            }
        }
    }
  m = m->m_next;
  <D.40078>:;
  if (m != 0B) goto <D.40077>; else goto <D.40050>;
  <D.40050>:;
  if ((unsigned char) buf[0] == 44)
    {
      switch_channel_set_variable_var_check (channel, (const char *) "ep_codec_string", (const char *) &buf + 1, 1);
    }
}



;; Function switch_core_media_codec_chosen (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[31] = "switch_core_media_codec_chosen";

    static const char __PRETTY_FUNCTION__[31] = "switch_core_media_codec_chosen";
    struct switch_rtp_engine_t * engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8407, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return 1;
    }
  engine = (struct switch_rtp_engine_t *) &smh->engines + (unsigned int) ((unsigned int) type * 11416);
  if (engine->cur_payload_map->iananame != 0B)
    {
      return 0;
    }
  return 1;
}



;; Function switch_core_media_check_outgoing_proxy (null)
;; enabled by -tree-original

{
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  const char * r_sdp = 0B;
  static const char __PRETTY_FUNCTION__[39] = "switch_core_media_check_outgoing_proxy";
  static const char __func__[39] = "switch_core_media_check_outgoing_proxy";

    static const char __func__[39] = "switch_core_media_check_outgoing_proxy";
    static const char __PRETTY_FUNCTION__[39] = "switch_core_media_check_outgoing_proxy";
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
    const char * r_sdp = 0B;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8430, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if (switch_channel_test_flag (o_session->channel, 29) == 0)
    {
      return;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  r_sdp = switch_channel_get_variable_dup (o_session->channel, (const char *) "switch_r_sdp", 1, -1);
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  switch_channel_set_flag_value (session->channel, 29, 1);
  a_engine->cur_payload_map->iananame = switch_core_perform_session_strdup (session, (const char *) "PROXY", (const char *) "src/switch_core_media.c", (const char *) &__func__, 8447);
  a_engine->cur_payload_map->rm_rate = 8000;
  a_engine->cur_payload_map->adv_rm_rate = 8000;
  a_engine->cur_payload_map->codec_ms = 20;
  if (switch_stristr ((const char *) "m=video", r_sdp) != 0B)
    {
      switch_core_media_choose_port (session, 1, 1);
      v_engine->cur_payload_map->rm_encoding = (char *) "PROXY-VID";
      v_engine->cur_payload_map->rm_rate = 90000;
      v_engine->cur_payload_map->adv_rm_rate = 90000;
      v_engine->cur_payload_map->codec_ms = 0;
      switch_channel_set_flag_value (session->channel, 23, 1);
      switch_channel_set_flag_value (session->channel, 98, 1);
    }
}



;; Function switch_core_media_proxy_codec (null)
;; enabled by -tree-original

{
  struct sdp_media_t * m;
  struct sdp_parser_t * parser = 0B;
  struct sdp_session_t * sdp;
  struct sdp_attribute_t * attr;
  int ptime = 0;
  int dptime = 0;
  struct switch_rtp_engine_t * a_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[30] = "switch_core_media_proxy_codec";
  static const char __func__[30] = "switch_core_media_proxy_codec";

    static const char __func__[30] = "switch_core_media_proxy_codec";
    static const char __PRETTY_FUNCTION__[30] = "switch_core_media_proxy_codec";
    struct sdp_media_t * m;
    struct sdp_parser_t * parser = 0B;
    struct sdp_session_t * sdp;
    struct sdp_attribute_t * attr;
    int ptime = 0;
    int dptime = 0;
    struct switch_rtp_engine_t * a_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8482, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  if ((parser = sdp_parse (0B, r_sdp, (int) strlen (r_sdp), 0)) == 0B)
    {
      return;
    }
  if ((sdp = sdp_session (parser)) == 0B)
    {
      sdp_parser_free (parser);
      return;
    }
  attr = sdp->sdp_attributes;
  goto <D.40111>;
  <D.40110>:;
  if (_zstr (attr->a_name) != 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.40109>;
    }
  if (strcasecmp (attr->a_name, (const char *) "ptime") == 0)
    {
      dptime = atoi (attr->a_value);
    }
  <D.40109>:;
  attr = attr->a_next;
  <D.40111>:;
  if (attr != 0B) goto <D.40110>; else goto <D.40112>;
  <D.40112>:;
  m = sdp->sdp_media;
  goto <D.40123>;
  <D.40122>:;
  ptime = dptime;
  if ((unsigned int) m->m_proto == 256)
    {
      {
        struct sdp_rtpmap_t * map;

                struct sdp_rtpmap_t * map;
        attr = m->m_attributes;
        goto <D.40115>;
        <D.40114>:;
        if (strcasecmp (attr->a_name, (const char *) "ptime") == 0 && attr->a_value != 0B)
          {
            ptime = atoi (attr->a_value);
          }
        else
          {
            if (strcasecmp (attr->a_name, (const char *) "maxptime") == 0 && attr->a_value != 0B)
              {
                
              }
          }
        attr = attr->a_next;
        <D.40115>:;
        if (attr != 0B) goto <D.40114>; else goto <D.40116>;
        <D.40116>:;
        map = m->m_rtpmaps;
        goto <D.40120>;
        <D.40119>:;
        a_engine->cur_payload_map->iananame = switch_core_perform_session_strdup (session, map->rm_encoding, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8527);
        a_engine->cur_payload_map->rm_rate = map->rm_rate;
        a_engine->cur_payload_map->adv_rm_rate = map->rm_rate;
        a_engine->cur_payload_map->codec_ms = (uint32_t) ptime;
        switch_core_media_set_codec (session, 0, smh->mparams->codec_flags);
        goto <D.40118>;
        map = map->rm_next;
        <D.40120>:;
        if (map != 0B) goto <D.40119>; else goto <D.40118>;
        <D.40118>:;
        goto <D.40121>;
      }
    }
  m = m->m_next;
  <D.40123>:;
  if (m != 0B) goto <D.40122>; else goto <D.40121>;
  <D.40121>:;
  sdp_parser_free (parser);
}



;; Function switch_core_media_recover_session (null)
;; enabled by -tree-original

{
  const char * ip;
  const char * port;
  const char * a_ip;
  const char * r_ip;
  const char * r_port;
  const char * tmp;
  struct switch_rtp_engine_t * a_engine;
  struct switch_rtp_engine_t * v_engine;
  struct switch_media_handle_t * smh;
  static const char __PRETTY_FUNCTION__[34] = "switch_core_media_recover_session";
  static const char __func__[34] = "switch_core_media_recover_session";

    static const char __func__[34] = "switch_core_media_recover_session";
    static const char __PRETTY_FUNCTION__[34] = "switch_core_media_recover_session";
    const char * ip;
    const char * port;
    const char * a_ip;
    const char * r_ip;
    const char * r_port;
    const char * tmp;
    struct switch_rtp_engine_t * a_engine;
    struct switch_rtp_engine_t * v_engine;
    struct switch_media_handle_t * smh;
  if (session == 0B)
    {
      __assert_fail ((const char *) "session", (const char *) "src/switch_core_media.c", 8557, (const char *) &__PRETTY_FUNCTION__);
    }
  else
    {
      (void) 0;
    }
  if ((smh = session->media_handle) == 0B)
    {
      return;
    }
  ip = switch_channel_get_variable_dup (session->channel, (const char *) "local_media_ip", 1, -1);
  port = switch_channel_get_variable_dup (session->channel, (const char *) "local_media_port", 1, -1);
  if (switch_channel_test_flag (session->channel, 15) != 0 || (ip == 0B || port == 0B))
    {
      return;
    }
  else
    {
      a_ip = switch_channel_get_variable_dup (session->channel, (const char *) "advertised_media_ip", 1, -1);
      r_ip = switch_channel_get_variable_dup (session->channel, (const char *) "remote_media_ip", 1, -1);
      r_port = switch_channel_get_variable_dup (session->channel, (const char *) "remote_media_port", 1, -1);
    }
  a_engine = (struct switch_rtp_engine_t *) &smh->engines;
  v_engine = (struct switch_rtp_engine_t *) &smh->engines + 11416;
  a_engine->cur_payload_map->iananame = a_engine->cur_payload_map->rm_encoding = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_codec_name", 1, -1);
  a_engine->cur_payload_map->rm_fmtp = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_codec_fmtp", 1, -1);
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "switch_r_sdp", 1, -1)) != 0B)
    {
      smh->mparams->remote_sdp_str = switch_core_perform_session_strdup (session, tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8581);
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_last_audio_codec_string", 1, -1)) != 0B)
    {
      {
        const char * vtmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_last_video_codec_string", 1, -1);

                const char * vtmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_last_video_codec_string", 1, -1);
        switch_channel_set_variable_printf (session->channel, (const char *) "rtp_use_codec_string", (const char *) "%s%s%s", tmp, vtmp != 0B ? (char *) "," : (char *) "", vtmp != 0B ? vtmp : (const char *) "");
      }
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_codec_string", 1, -1)) != 0B)
    {
      {
        char * tmp_codec_string = switch_core_perform_session_strdup (smh->session, tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8591);

                char * tmp_codec_string = switch_core_perform_session_strdup (smh->session, tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8591);
        smh->codec_order_last = (int) switch_separate_string (tmp_codec_string, 44, (char * *) &smh->codec_order, 50);
        smh->mparams->num_codecs = switch_loadable_module_get_codecs_sorted ((const struct switch_codec_implementation_t * *) &smh->codecs, 50, (char * *) &smh->codec_order, smh->codec_order_last);
      }
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_2833_send_payload", 1, -1)) != 0B)
    {
      smh->mparams->te = (unsigned char) atoi (tmp);
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_2833_recv_payload", 1, -1)) != 0B)
    {
      smh->mparams->recv_te = (unsigned char) atoi (tmp);
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_codec_rate", 1, -1)) != 0B)
    {
      a_engine->cur_payload_map->rm_rate = (long unsigned int) atoi (tmp);
      a_engine->cur_payload_map->adv_rm_rate = a_engine->cur_payload_map->rm_rate;
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_codec_ptime", 1, -1)) != 0B)
    {
      a_engine->cur_payload_map->codec_ms = (uint32_t) atoi (tmp);
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_pt", 1, -1)) != 0B)
    {
      a_engine->cur_payload_map->pt = a_engine->cur_payload_map->agreed_pt = (unsigned char) atoi (tmp);
    }
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_audio_recv_pt", 1, -1)) != 0B)
    {
      a_engine->cur_payload_map->recv_pt = (unsigned char) atoi (tmp);
    }
  switch_core_media_set_codec (session, 1, smh->mparams->codec_flags);
  a_engine->adv_sdp_ip = smh->mparams->extrtpip = (char *) ip;
  a_engine->adv_sdp_port = a_engine->local_sdp_port = (short unsigned int) atoi (port);
  if (_zstr (ip) == 0)
    {
      a_engine->local_sdp_ip = switch_core_perform_session_strdup (session, ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8627);
      smh->mparams->rtpip = a_engine->local_sdp_ip;
    }
  if (_zstr (a_ip) == 0)
    {
      a_engine->adv_sdp_ip = switch_core_perform_session_strdup (session, a_ip, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8632);
    }
  if (r_ip != 0B && r_port != 0B)
    {
      a_engine->cur_payload_map->remote_sdp_ip = (char *) r_ip;
      a_engine->cur_payload_map->remote_sdp_port = (short unsigned int) atoi (r_port);
    }
  if (switch_channel_test_flag (session->channel, 23) != 0)
    {
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_pt", 1, -1)) != 0B)
        {
          v_engine->cur_payload_map->pt = v_engine->cur_payload_map->agreed_pt = (unsigned char) atoi (tmp);
        }
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_video_recv_pt", 1, -1)) != 0B)
        {
          v_engine->cur_payload_map->recv_pt = (unsigned char) atoi (tmp);
        }
      v_engine->cur_payload_map->rm_encoding = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_codec_name", 1, -1);
      v_engine->cur_payload_map->rm_fmtp = (char *) switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_codec_fmtp", 1, -1);
      ip = switch_channel_get_variable_dup (session->channel, (const char *) "local_video_ip", 1, -1);
      port = switch_channel_get_variable_dup (session->channel, (const char *) "local_video_port", 1, -1);
      r_ip = switch_channel_get_variable_dup (session->channel, (const char *) "remote_video_ip", 1, -1);
      r_port = switch_channel_get_variable_dup (session->channel, (const char *) "remote_video_port", 1, -1);
      switch_channel_set_flag_value (session->channel, 98, 1);
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_codec_rate", 1, -1)) != 0B)
        {
          v_engine->cur_payload_map->rm_rate = (long unsigned int) atoi (tmp);
          v_engine->cur_payload_map->adv_rm_rate = v_engine->cur_payload_map->rm_rate;
        }
      if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_use_video_codec_ptime", 1, -1)) != 0B)
        {
          v_engine->cur_payload_map->codec_ms = (uint32_t) atoi (tmp);
        }
      v_engine->adv_sdp_port = v_engine->local_sdp_port = (short unsigned int) atoi (port);
      if (r_ip != 0B && r_port != 0B)
        {
          v_engine->cur_payload_map->remote_sdp_ip = (char *) r_ip;
          v_engine->cur_payload_map->remote_sdp_port = (short unsigned int) atoi (r_port);
        }
    }
  switch_core_media_gen_local_sdp (session, 0, 0B, 0, 0B, 1);
  switch_core_media_set_video_codec (session, 1);
  if ((unsigned int) switch_core_media_activate_rtp (session) != 0)
    {
      return;
    }
  switch_core_session_get_recovery_crypto_key (session, 0);
  switch_core_session_get_recovery_crypto_key (session, 1);
  if ((tmp = switch_channel_get_variable_dup (session->channel, (const char *) "rtp_last_audio_local_crypto_key", 1, -1)) != 0B && a_engine->ssec[(unsigned int) a_engine->crypto_type].remote_crypto_key != 0B)
    {
      {
        int idx = atoi (tmp);

                int idx = atoi (tmp);
        a_engine->ssec[(unsigned int) a_engine->crypto_type].local_crypto_key = switch_core_perform_session_strdup (session, tmp, (const char *) "src/switch_core_media.c", (const char *) &__func__, 8690);
        switch_core_media_add_crypto ((struct switch_secure_settings_t *) &a_engine->ssec + (unsigned int) ((unsigned int) a_engine->crypto_type * 144), (const char *) a_engine->ssec[(unsigned int) a_engine->crypto_type].local_crypto_key, 0);
        switch_core_media_add_crypto ((struct switch_secure_settings_t *) &a_engine->ssec + (unsigned int) ((unsigned int) a_engine->crypto_type * 144), (const char *) a_engine->ssec[(unsigned int) a_engine->crypto_type].remote_crypto_key, 1);
        switch_channel_set_flag_value (smh->session->channel, 92, 1);
        switch_rtp_add_crypto_key (a_engine->rtp_session, 0, (uint32_t) idx, a_engine->crypto_type, (unsigned char *) &a_engine->ssec[(unsigned int) a_engine->crypto_type].local_raw_key, (switch_size_t) SUITES[(unsigned int) a_engine->crypto_type].keylen);
        switch_rtp_add_crypto_key (a_engine->rtp_session, 1, (uint32_t) a_engine->ssec[(unsigned int) a_engine->crypto_type].crypto_tag, a_engine->crypto_type, (unsigned char *) &a_engine->ssec[(unsigned int) a_engine->crypto_type].remote_raw_key, (switch_size_t) SUITES[(unsigned int) a_engine->crypto_type].keylen);
      }
    }
  if ((unsigned char) switch_core_media_ready (session, 0) != 0)
    {
      switch_rtp_set_telephony_event (a_engine->rtp_session, smh->mparams->te);
      switch_rtp_set_telephony_recv_event (a_engine->rtp_session, smh->mparams->recv_te);
    }
}



;; Function switch_core_media_init (null)
;; enabled by -tree-original

{
  switch_core_gen_certs ((const char *) "dtls-srtp.pem");
}



;; Function switch_core_media_deinit (null)
;; enabled by -tree-original

{
  
}


